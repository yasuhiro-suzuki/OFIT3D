var tipuesearch = {"pages":[{"title":" OFIT3D ","text":"OFIT3D Developer Info Yasuhiro Suzuki","tags":"home","loc":"index.html"},{"title":"genrand_state – OFIT3D ","text":"type, public :: genrand_state Contents Variables ini cnt val Components Type Visibility Attributes Name Initial logical(kind=wi), public :: ini = .false._wi integer(kind=wi), public :: cnt = n+1_wi integer(kind=wi), public, dimension(n) :: val = 0_wi","tags":"","loc":"type/genrand_state.html"},{"title":"genrand_srepr – OFIT3D ","text":"type, public :: genrand_srepr Contents Variables repr Components Type Visibility Attributes Name Initial character(len=clen), public :: repr","tags":"","loc":"type/genrand_srepr.html"},{"title":"file_close – OFIT3D","text":"subroutine file_close() Uses param2 cylindrical_coord_mod Arguments None Contents None","tags":"","loc":"proc/file_close.html"},{"title":"file_open – OFIT3D","text":"subroutine file_open() Uses param2 file_name_mod cylindrical_coord_mod Arguments None Contents None","tags":"","loc":"proc/file_open.html"},{"title":"upsilon_cal – OFIT3D","text":"function upsilon_cal(x) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x Return Value real(kind=8) Contents None","tags":"","loc":"proc/upsilon_cal.html"},{"title":"xsi_cal – OFIT3D","text":"function xsi_cal(x) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x Return Value real(kind=8) Contents None","tags":"","loc":"proc/xsi_cal.html"},{"title":"funphi – OFIT3D","text":"function funphi(t) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: t Return Value real(kind=8) Contents None","tags":"","loc":"proc/funphi.html"},{"title":"qsimp – OFIT3D","text":"subroutine qsimp(func, a, b, s) Arguments Type Intent Optional Attributes Name real(kind=8), EXTERNAL :: func real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(out) :: s Contents None","tags":"","loc":"proc/qsimp.html"},{"title":"trapzd – OFIT3D","text":"subroutine trapzd(func, a, b, s, n) Arguments Type Intent Optional Attributes Name real(kind=8), EXTERNAL :: func real(kind=8), intent(in) :: a real(kind=8), intent(in) :: b real(kind=8), intent(out) :: s integer, intent(in) :: n Contents None","tags":"","loc":"proc/trapzd.html"},{"title":"mgcpu – OFIT3D","text":"subroutine mgcpu(itime, mess) Uses mpi_param_mod mpi kind_spec Arguments Type Intent Optional Attributes Name integer :: itime character(len=20) :: mess Contents None","tags":"","loc":"proc/mgcpu.html"},{"title":"polint – OFIT3D","text":"subroutine polint(xa, ya, n, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: xa (n) real(kind=rkind), intent(in) :: ya (n) integer(kind=ikind), intent(in) :: n real(kind=rkind), intent(in) :: x real(kind=rkind), intent(out) :: y real(kind=rkind), intent(out) :: dy Contents None","tags":"","loc":"proc/polint.html"},{"title":"fun_mesor – OFIT3D","text":"subroutine fun_mesor(t, yy, yp) Uses param1 kind_spec cylindrical_coord_mod Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: t real(kind=RP), intent(in) :: yy (6) real(kind=RP), intent(out) :: yp (6) Contents None","tags":"","loc":"proc/fun_mesor.html"},{"title":"readin – OFIT3D","text":"subroutine readin() Uses info_mod vessel_mod collision_parameter_mod param2 divertor_mod mpi kind_spec cylindrical_coord_mod Arguments None Contents None","tags":"","loc":"proc/readin.html"},{"title":"rkg6 – OFIT3D","text":"subroutine rkg6(x0, h, n, fun, y0, iout) Uses kind_spec Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: x0 real(kind=RP), intent(in) :: h integer, intent(in) :: n real :: fun real(kind=RP), intent(inout) :: y0 (n) integer, intent(out) :: iout Contents None","tags":"","loc":"proc/rkg6.html"},{"title":"single_particles – OFIT3D","text":"subroutine single_particles() Uses param1 mpi_param_mod param2 kind_spec Arguments None Contents None","tags":"","loc":"proc/single_particles.html"},{"title":"mesor – OFIT3D","text":"subroutine mesor(rstart, pstart, zstart, w_in, stalam, dt_in, nstep, loss, loss_time, trap) Uses vessel_mod param1 param2 kind_spec cylindrical_coord_mod Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: rstart real(kind=RP), intent(in) :: pstart real(kind=RP), intent(in) :: zstart real(kind=RP), intent(in) :: w_in real(kind=RP), intent(in) :: stalam real(kind=RP), intent(in) :: dt_in integer, intent(in) :: nstep integer, intent(out) :: loss real(kind=RP), intent(out) :: loss_time integer, intent(out) :: trap Contents None","tags":"","loc":"proc/mesor.html"},{"title":"driver – OFIT3D","text":"subroutine driver() Uses mpi_param_mod info_mod vessel_mod param2 divertor_mod mpi kind_spec Arguments None Contents None","tags":"","loc":"proc/driver.html"},{"title":"gcr – OFIT3D","text":"subroutine gcr(rstart, pstart, zstart, w_in, stalam, dt_in, nstep, loss, loss_time, trap) Uses inv_val_mod mt95 vessel_mod param1 collision_parameter_mod param2 divertor_mod kind_spec cylindrical_coord_mod Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: rstart real(kind=RP), intent(in) :: pstart real(kind=RP), intent(in) :: zstart real(kind=RP), intent(in) :: w_in real(kind=RP), intent(in) :: stalam real(kind=RP), intent(in) :: dt_in integer, intent(in) :: nstep integer, intent(out) :: loss real(kind=RP), intent(out) :: loss_time integer, intent(out) :: trap Contents None","tags":"","loc":"proc/gcr.html"},{"title":"fun_gcr – OFIT3D","text":"subroutine fun_gcr(t, y, yp, iout) Uses param1 inv_val_mod kind_spec cylindrical_coord_mod Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: t real(kind=RP), intent(in) :: y (4) real(kind=RP), intent(out) :: yp (4) integer, intent(out) :: iout Contents None","tags":"","loc":"proc/fun_gcr.html"},{"title":"multi_particles – OFIT3D","text":"subroutine multi_particles() Uses mpi_param_mod param1 param2 mpi kind_spec cylindrical_coord_mod Arguments None Contents None","tags":"","loc":"proc/multi_particles.html"},{"title":"precal – OFIT3D","text":"subroutine precal() Uses mpi_param_mod info_mod param1 collision_parameter_mod param2 mpi kind_spec cylindrical_coord_mod Arguments None Contents None","tags":"","loc":"proc/precal.html"},{"title":"para_range – OFIT3D","text":"public subroutine para_range(m1, m2, mprocs, mrank, msta, mend) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m1 integer, intent(in) :: m2 integer, intent(in) :: mprocs integer, intent(in) :: mrank integer, intent(out) :: msta integer, intent(out) :: mend Contents None","tags":"","loc":"proc/para_range.html"},{"title":"assignment( = ) – OFIT3D","text":"public interface assignment( = ) Contents Module Procedures genrand_load_state genrand_dump_state Module Procedures private elemental subroutine genrand_load_state(stt, rpr) Arguments Type Intent Optional Attributes Name type( genrand_state ), intent(out) :: stt type( genrand_srepr ), intent(in) :: rpr private elemental subroutine genrand_dump_state(rpr, stt) Arguments Type Intent Optional Attributes Name type( genrand_srepr ), intent(out) :: rpr type( genrand_state ), intent(in) :: stt","tags":"","loc":"interface/assignment( = ).html"},{"title":"genrand_init – OFIT3D","text":"public interface genrand_init Contents Module Procedures init_by_type init_by_scalar init_by_array Module Procedures private subroutine init_by_type(put, get) Arguments Type Intent Optional Attributes Name type( genrand_state ), intent(in), optional :: put type( genrand_state ), intent(out), optional :: get private subroutine init_by_scalar(put) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(in) :: put private subroutine init_by_array(put) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(in), dimension(:) :: put","tags":"","loc":"interface/genrand_init.html"},{"title":"genrand_int32 – OFIT3D","text":"public interface genrand_int32 Contents Module Procedures genrand_int32_0d genrand_int32_1d genrand_int32_2d genrand_int32_3d genrand_int32_4d genrand_int32_5d genrand_int32_6d genrand_int32_7d Module Procedures private subroutine genrand_int32_0d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out) :: y private subroutine genrand_int32_1d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:) :: y private subroutine genrand_int32_2d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:) :: y private subroutine genrand_int32_3d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:) :: y private subroutine genrand_int32_4d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:) :: y private subroutine genrand_int32_5d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:) :: y private subroutine genrand_int32_6d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:,:) :: y private subroutine genrand_int32_7d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:,:,:) :: y","tags":"","loc":"interface/genrand_int32.html"},{"title":"genrand_int31 – OFIT3D","text":"public interface genrand_int31 Contents Module Procedures genrand_int31_0d genrand_int31_1d genrand_int31_2d genrand_int31_3d genrand_int31_4d genrand_int31_5d genrand_int31_6d genrand_int31_7d Module Procedures private subroutine genrand_int31_0d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out) :: y private subroutine genrand_int31_1d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:) :: y private subroutine genrand_int31_2d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:) :: y private subroutine genrand_int31_3d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:) :: y private subroutine genrand_int31_4d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:) :: y private subroutine genrand_int31_5d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:) :: y private subroutine genrand_int31_6d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:,:) :: y private subroutine genrand_int31_7d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:,:,:) :: y","tags":"","loc":"interface/genrand_int31.html"},{"title":"genrand_real1 – OFIT3D","text":"public interface genrand_real1 Contents Module Procedures genrand_real1_0d genrand_real1_1d genrand_real1_2d genrand_real1_3d genrand_real1_4d genrand_real1_5d genrand_real1_6d genrand_real1_7d Module Procedures private subroutine genrand_real1_0d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out) :: r private subroutine genrand_real1_1d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:) :: r private subroutine genrand_real1_2d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:) :: r private subroutine genrand_real1_3d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:) :: r private subroutine genrand_real1_4d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:) :: r private subroutine genrand_real1_5d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:) :: r private subroutine genrand_real1_6d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:) :: r private subroutine genrand_real1_7d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:,:) :: r","tags":"","loc":"interface/genrand_real1.html"},{"title":"genrand_real2 – OFIT3D","text":"public interface genrand_real2 Contents Module Procedures genrand_real2_0d genrand_real2_1d genrand_real2_2d genrand_real2_3d genrand_real2_4d genrand_real2_5d genrand_real2_6d genrand_real2_7d Module Procedures private subroutine genrand_real2_0d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out) :: r private subroutine genrand_real2_1d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:) :: r private subroutine genrand_real2_2d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:) :: r private subroutine genrand_real2_3d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:) :: r private subroutine genrand_real2_4d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:) :: r private subroutine genrand_real2_5d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:) :: r private subroutine genrand_real2_6d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:) :: r private subroutine genrand_real2_7d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:,:) :: r","tags":"","loc":"interface/genrand_real2.html"},{"title":"genrand_real3 – OFIT3D","text":"public interface genrand_real3 Contents Module Procedures genrand_real3_0d genrand_real3_1d genrand_real3_2d genrand_real3_3d genrand_real3_4d genrand_real3_5d genrand_real3_6d genrand_real3_7d Module Procedures private subroutine genrand_real3_0d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out) :: r private subroutine genrand_real3_1d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:) :: r private subroutine genrand_real3_2d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:) :: r private subroutine genrand_real3_3d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:) :: r private subroutine genrand_real3_4d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:) :: r private subroutine genrand_real3_5d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:) :: r private subroutine genrand_real3_6d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:) :: r private subroutine genrand_real3_7d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:,:) :: r","tags":"","loc":"interface/genrand_real3.html"},{"title":"genrand_res53 – OFIT3D","text":"public interface genrand_res53 Contents Module Procedures genrand_res53_0d genrand_res53_1d genrand_res53_2d genrand_res53_3d genrand_res53_4d genrand_res53_5d genrand_res53_6d genrand_res53_7d Module Procedures private subroutine genrand_res53_0d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out) :: r private subroutine genrand_res53_1d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:) :: r private subroutine genrand_res53_2d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:) :: r private subroutine genrand_res53_3d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:) :: r private subroutine genrand_res53_4d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:) :: r private subroutine genrand_res53_5d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:) :: r private subroutine genrand_res53_6d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:) :: r private subroutine genrand_res53_7d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:,:) :: r","tags":"","loc":"interface/genrand_res53.html"},{"title":"free_mem_field – OFIT3D","text":"public subroutine free_mem_field() A subroutine that deallocates fortran arrays. Arguments None Contents None","tags":"","loc":"proc/free_mem_field.html"},{"title":"magset – OFIT3D","text":"public subroutine magset() A subroutine that read a table of the magnetic field, (\\f$B_R, B_{\\phi}, B_Z, B\\f$),\non the cylindrical coordinate, (\\f$R, \\phi, Z\\f$).\n@n\n@em NOTE: the right-handed system Arguments None Contents None","tags":"","loc":"proc/magset.html"},{"title":"mgval1 – OFIT3D","text":"public subroutine mgval1(r, phi, z, br, bp, bz, bb) A subroutine that interpolates magnetic fields, (\\f$B_R, B_{\\phi}, B_Z, B\\f$),\non a given coordinate, (\\f$R, \\phi, Z\\f$)\n@param[in] r \\f$ R \\f$ [m]\n@param[in] phi \\f$ \\phi \\f$ [rad]\n@param[in] z \\f$ Z \\f$ [m]\n@param[out] br \\f$ B_R \\f$ [T]\n@param[out] bp \\f$ B_{\\phi} \\f$ [T]\n@param[out] bz \\f$ B_Z \\f$ [T]\n@param[out] bb \\f$ |B| \\f$ [T] Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r real(kind=RP), intent(in) :: phi real(kind=RP), intent(in) :: z real(kind=RP), intent(out) :: br real(kind=RP), intent(out) :: bp real(kind=RP), intent(out) :: bz real(kind=RP), intent(out) :: bb Contents None","tags":"","loc":"proc/mgval1.html"},{"title":"mgval2 – OFIT3D","text":"public subroutine mgval2(r, phi, z, b, dbdr, dbdp, dbdz) A subroutine that interpolates magnetic fields, (\\f$B_R, B_{\\phi}, B_Z, B\\f$),\nand calculates 1st derivative, (\\f$ \\partial \\textbf{B} / \\partial R, \\partial \\textbf{B} / \\partial \\phi, \\partial \\textbf{B} / \\partial Z \\f$),\non a given coordinate, (\\f$R, \\phi, Z\\f$)\n@param[in] r \\f$ R \\f$ [m]\n@param[in] phi \\f$ \\phi \\f$ [rad]\n@param[in] z \\f$ Z \\f$ [m]\n@param[out] b (\\f$ B_R, B_{\\phi}, B_Z, |B| \\f$)[T]\n@param[out] dbdr (\\f$ \\partial B_R / \\partial R, \\partial B_{\\phi} / \\partial R, \\partial B_Z / \\partial R, \\partial B / \\partial R \\f$) [T/m]\n@param[out] dbdp (\\f$ \\partial B_R / \\partial \\phi, \\partial B_{\\phi} / \\partial \\phi, \\partial B_Z / \\partial \\phi, \\partial B / \\partial \\phi \\f$) [T/rad]\n@param[out] dbdz (\\f$ \\partial B_R / \\partial Z, \\partial B_{\\phi} / \\partial Z, \\partial B_Z / \\partial Z, \\partial B / \\partial Z \\f$) [T/m] Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r real(kind=RP), intent(in) :: phi real(kind=RP), intent(in) :: z real(kind=RP), intent(out) :: b (l3d) real(kind=RP), intent(out) :: dbdr (l3d) real(kind=RP), intent(out) :: dbdp (l3d) real(kind=RP), intent(out) :: dbdz (l3d) Contents None","tags":"","loc":"proc/mgval2.html"},{"title":"mgval3 – OFIT3D","text":"public subroutine mgval3(r, phi, z, s) A subroutine that interpolates normalized flux\non a given coordinate, (\\f$R, \\phi, Z\\f$)\n@param[in] r \\f$ R \\f$ [m]\n@param[in] phi \\f$ \\phi \\f$ [rad]\n@param[in] z \\f$ Z \\f$ [m]\n@param[out] s normalized flux Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r real(kind=RP), intent(in) :: phi real(kind=RP), intent(in) :: z real(kind=RP), intent(out) :: s Contents None","tags":"","loc":"proc/mgval3.html"},{"title":"free_mem_vessel – OFIT3D","text":"public subroutine free_mem_vessel() Arguments None Contents None","tags":"","loc":"proc/free_mem_vessel.html"},{"title":"read_vessel – OFIT3D","text":"public subroutine read_vessel() Arguments None Contents None","tags":"","loc":"proc/read_vessel.html"},{"title":"vessel – OFIT3D","text":"public subroutine vessel(phi, r1, z1) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: phi real(kind=RP), intent(out) :: r1 (nu) real(kind=RP), intent(out) :: z1 (nu) Contents None","tags":"","loc":"proc/vessel.html"},{"title":"check_vessel – OFIT3D","text":"public subroutine check_vessel(r, phi, z, iout) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r real(kind=RP), intent(in) :: phi real(kind=RP), intent(in) :: z integer, intent(out) :: iout Contents None","tags":"","loc":"proc/check_vessel.html"},{"title":"vessel_loss – OFIT3D","text":"public subroutine vessel_loss(r0, phi0, z0, r1, phi1, z1, intersect, beta, point) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r0 real(kind=RP), intent(in) :: phi0 real(kind=RP), intent(in) :: z0 real(kind=RP), intent(in) :: r1 real(kind=RP), intent(in) :: phi1 real(kind=RP), intent(in) :: z1 integer, intent(out) :: intersect real(kind=RP), intent(out) :: beta real(kind=RP), intent(out) :: point (3) Contents None","tags":"","loc":"proc/vessel_loss.html"},{"title":"splin1 – OFIT3D","text":"public subroutine splin1(xsd, xld) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xsd real(kind=RP), intent(in) :: xld Contents None","tags":"","loc":"proc/splin1.html"},{"title":"splin2 – OFIT3D","text":"public subroutine splin2(xsd, xld, ysd, yld) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xsd real(kind=RP), intent(in) :: xld real(kind=RP), intent(in) :: ysd real(kind=RP), intent(in) :: yld Contents None","tags":"","loc":"proc/splin2.html"},{"title":"splin3 – OFIT3D","text":"public subroutine splin3(xsd, xld, ysd, yld, zsd, zld) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xsd real(kind=RP), intent(in) :: xld real(kind=RP), intent(in) :: ysd real(kind=RP), intent(in) :: yld real(kind=RP), intent(in) :: zsd real(kind=RP), intent(in) :: zld Contents None","tags":"","loc":"proc/splin3.html"},{"title":"spl1df – OFIT3D","text":"public subroutine spl1df(xd, w0) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd real(kind=RP), intent(out) :: w0 (l1d) Contents None","tags":"","loc":"proc/spl1df.html"},{"title":"spl1dd – OFIT3D","text":"public subroutine spl1dd(xd, w0, wx) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd (2) real(kind=RP), intent(out) :: w0 (l1d) real(kind=RP), intent(out) :: wx (l1d) Contents None","tags":"","loc":"proc/spl1dd.html"},{"title":"spl2df – OFIT3D","text":"public subroutine spl2df(xd, w0) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd (2) real(kind=RP), intent(out) :: w0 (l2d) Contents None","tags":"","loc":"proc/spl2df.html"},{"title":"spl2dd – OFIT3D","text":"public subroutine spl2dd(xd, w0, wx, wy) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd (2) real(kind=RP), intent(out) :: w0 (l2d) real(kind=RP), intent(out) :: wx (l2d) real(kind=RP), intent(out) :: wy (l2d) Contents None","tags":"","loc":"proc/spl2dd.html"},{"title":"spl3df – OFIT3D","text":"public subroutine spl3df(xd, w0) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd (3) real(kind=RP), intent(out) :: w0 (l3d) Contents None","tags":"","loc":"proc/spl3df.html"},{"title":"spl3dd – OFIT3D","text":"public subroutine spl3dd(xd, w0, wx, wy, wz) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd (3) real(kind=RP), intent(out) :: w0 (l3d) real(kind=RP), intent(out) :: wx (l3d) real(kind=RP), intent(out) :: wy (l3d) real(kind=RP), intent(out) :: wz (l3d) Contents None","tags":"","loc":"proc/spl3dd.html"},{"title":"free_mem_divertor – OFIT3D","text":"public subroutine free_mem_divertor() Arguments None Contents None","tags":"","loc":"proc/free_mem_divertor.html"},{"title":"read_divertor – OFIT3D","text":"public subroutine read_divertor() Arguments None Contents None","tags":"","loc":"proc/read_divertor.html"},{"title":"divertor_loss – OFIT3D","text":"public subroutine divertor_loss(r0, phi0, z0, r1, phi1, z1, intersect, beta, point) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r0 real(kind=RP), intent(in) :: phi0 real(kind=RP), intent(in) :: z0 real(kind=RP), intent(in) :: r1 real(kind=RP), intent(in) :: phi1 real(kind=RP), intent(in) :: z1 integer, intent(out) :: intersect real(kind=RP), intent(out) :: beta real(kind=RP), intent(out) :: point (3) Contents None","tags":"","loc":"proc/divertor_loss.html"},{"title":"mpi_param_mod – OFIT3D","text":"Uses mpi kind_spec Contents Variables myrank nprocs nsta nend Subroutines para_range Variables Type Visibility Attributes Name Initial integer, public :: myrank integer, public :: nprocs integer, public :: nsta integer, public :: nend Subroutines public subroutine para_range (m1, m2, mprocs, mrank, msta, mend) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m1 integer, intent(in) :: m2 integer, intent(in) :: mprocs integer, intent(in) :: mrank integer, intent(out) :: msta integer, intent(out) :: mend","tags":"","loc":"module/mpi_param_mod.html"},{"title":"mt95 – OFIT3D","text":"Contents Variables genrand_intg genrand_real Interfaces assignment( = ) genrand_init genrand_int32 genrand_int31 genrand_real1 genrand_real2 genrand_real3 genrand_res53 Derived Types genrand_state genrand_srepr Variables Type Visibility Attributes Name Initial integer, public, parameter :: genrand_intg = selected_int_kind(9) integer, public, parameter :: genrand_real = selected_real_kind(15) Interfaces public interface assignment( = ) private elemental subroutine genrand_load_state(stt, rpr) Arguments Type Intent Optional Attributes Name type( genrand_state ), intent(out) :: stt type( genrand_srepr ), intent(in) :: rpr private elemental subroutine genrand_dump_state(rpr, stt) Arguments Type Intent Optional Attributes Name type( genrand_srepr ), intent(out) :: rpr type( genrand_state ), intent(in) :: stt public interface genrand_init private subroutine init_by_type(put, get) Arguments Type Intent Optional Attributes Name type( genrand_state ), intent(in), optional :: put type( genrand_state ), intent(out), optional :: get private subroutine init_by_scalar(put) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(in) :: put private subroutine init_by_array(put) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(in), dimension(:) :: put public interface genrand_int32 private subroutine genrand_int32_0d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out) :: y private subroutine genrand_int32_1d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:) :: y private subroutine genrand_int32_2d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:) :: y private subroutine genrand_int32_3d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:) :: y private subroutine genrand_int32_4d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:) :: y private subroutine genrand_int32_5d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:) :: y private subroutine genrand_int32_6d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:,:) :: y private subroutine genrand_int32_7d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:,:,:) :: y public interface genrand_int31 private subroutine genrand_int31_0d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out) :: y private subroutine genrand_int31_1d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:) :: y private subroutine genrand_int31_2d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:) :: y private subroutine genrand_int31_3d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:) :: y private subroutine genrand_int31_4d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:) :: y private subroutine genrand_int31_5d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:) :: y private subroutine genrand_int31_6d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:,:) :: y private subroutine genrand_int31_7d(y) Arguments Type Intent Optional Attributes Name integer(kind=wi), intent(out), dimension(:,:,:,:,:,:,:) :: y public interface genrand_real1 private subroutine genrand_real1_0d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out) :: r private subroutine genrand_real1_1d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:) :: r private subroutine genrand_real1_2d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:) :: r private subroutine genrand_real1_3d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:) :: r private subroutine genrand_real1_4d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:) :: r private subroutine genrand_real1_5d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:) :: r private subroutine genrand_real1_6d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:) :: r private subroutine genrand_real1_7d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:,:) :: r public interface genrand_real2 private subroutine genrand_real2_0d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out) :: r private subroutine genrand_real2_1d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:) :: r private subroutine genrand_real2_2d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:) :: r private subroutine genrand_real2_3d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:) :: r private subroutine genrand_real2_4d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:) :: r private subroutine genrand_real2_5d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:) :: r private subroutine genrand_real2_6d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:) :: r private subroutine genrand_real2_7d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:,:) :: r public interface genrand_real3 private subroutine genrand_real3_0d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out) :: r private subroutine genrand_real3_1d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:) :: r private subroutine genrand_real3_2d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:) :: r private subroutine genrand_real3_3d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:) :: r private subroutine genrand_real3_4d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:) :: r private subroutine genrand_real3_5d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:) :: r private subroutine genrand_real3_6d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:) :: r private subroutine genrand_real3_7d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:,:) :: r public interface genrand_res53 private subroutine genrand_res53_0d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out) :: r private subroutine genrand_res53_1d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:) :: r private subroutine genrand_res53_2d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:) :: r private subroutine genrand_res53_3d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:) :: r private subroutine genrand_res53_4d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:) :: r private subroutine genrand_res53_5d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:) :: r private subroutine genrand_res53_6d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:) :: r private subroutine genrand_res53_7d(r) Arguments Type Intent Optional Attributes Name real(kind=wr), intent(out), dimension(:,:,:,:,:,:,:) :: r Derived Types type, public :: genrand_state Components Type Visibility Attributes Name Initial logical(kind=wi), public :: ini = .false._wi integer(kind=wi), public :: cnt = n+1_wi integer(kind=wi), public, dimension(n) :: val = 0_wi type, public :: genrand_srepr Components Type Visibility Attributes Name Initial character(len=clen), public :: repr","tags":"","loc":"module/mt95.html"},{"title":"kind_spec – OFIT3D","text":"Contents Variables RP Variables Type Visibility Attributes Name Initial integer, public, parameter :: RP = SELECTED_REAL_KIND(15)","tags":"","loc":"module/kind_spec.html"},{"title":"param1 – OFIT3D","text":"Uses kind_spec Contents Variables ee mi mn me epsi0 pi pi2 pi4 qa qb ma mb qom_a qom_b Variables Type Visibility Attributes Name Initial real(kind=RP), public, parameter :: ee = 1.602176565E-19_RP real(kind=RP), public, parameter :: mi = 1.672621777E-27_RP real(kind=RP), public, parameter :: mn = 1.674927351E-27_RP real(kind=RP), public, parameter :: me = 9.10938291E-31_RP real(kind=RP), public, parameter :: epsi0 = 8.85418782E-12_RP real(kind=RP), public, parameter :: pi = 3.141592653589793238462643383279502884197_RP real(kind=RP), public, parameter :: pi2 = pi+pi real(kind=RP), public, parameter :: pi4 = pi2+pi2 real(kind=RP), public :: qa real(kind=RP), public :: qb real(kind=RP), public :: ma real(kind=RP), public :: mb real(kind=RP), public :: qom_a real(kind=RP), public :: qom_b","tags":"","loc":"module/param1.html"},{"title":"param2 – OFIT3D","text":"Uses kind_spec Contents Variables ladaptive lcoll lano lmonitor lpunc lvessel ldivertor lfile nparticles interval wk_in wp_in dt quit_t stalam rstart pstart pstart1 zstart slimit mode collision_type anomalous_type run_mode multi_mode Variables Type Visibility Attributes Name Initial logical, public :: ladaptive = .false. logical, public :: lcoll = .false. logical, public :: lano = .false. logical, public :: lmonitor = .false. logical, public :: lpunc = .false. logical, public :: lvessel = .true. logical, public :: ldivertor = .false. logical, public :: lfile = .false. integer, public :: nparticles = 100 integer, public :: interval = 1 real(kind=RP), public :: wk_in = 1.0E+03_RP real(kind=RP), public :: wp_in = 0.0E+00_RP real(kind=RP), public :: dt = 1.0E-08_RP real(kind=RP), public :: quit_t = 1.0E-03_RP real(kind=RP), public :: stalam = 0.0_RP real(kind=RP), public :: rstart = 0.0_RP real(kind=RP), public :: pstart = 0.0_RP real(kind=RP), public :: pstart1 = 0.0_RP real(kind=RP), public :: zstart = 0.0_RP real(kind=RP), public :: slimit = 0.98_RP character(len=20), public :: mode = 'proton' character(len=20), public :: collision_type = 'slow' character(len=20), public :: anomalous_type = 'classical' character(len=20), public :: run_mode = 'single' character(len=20), public :: multi_mode = ''","tags":"","loc":"module/param2.html"},{"title":"inv_val_mod – OFIT3D","text":"Uses kind_spec Contents Variables mu Variables Type Visibility Attributes Name Initial real(kind=RP), public :: mu","tags":"","loc":"module/inv_val_mod.html"},{"title":"collision_parameter_mod – OFIT3D","text":"Uses kind_spec Contents Variables collision_step n_e t_bg rho_col d_ano atomic_mass ln_lamda v_th_a v_th_b tau nu_ab nu_d nu_dxtau nu_e nu_extau Variables Type Visibility Attributes Name Initial integer, public :: collision_step (2) = 1 real(kind=RP), public :: n_e = 1.0E+19_RP real(kind=RP), public :: t_bg = 1.0E+03_RP real(kind=RP), public :: rho_col = 1.2E-03_RP real(kind=RP), public :: d_ano real(kind=RP), public :: atomic_mass real(kind=RP), public :: ln_lamda real(kind=RP), public :: v_th_a real(kind=RP), public :: v_th_b real(kind=RP), public :: tau real(kind=RP), public :: nu_ab real(kind=RP), public :: nu_d real(kind=RP), public :: nu_dxtau real(kind=RP), public :: nu_e real(kind=RP), public :: nu_extau","tags":"","loc":"module/collision_parameter_mod.html"},{"title":"wall_mod – OFIT3D","text":"Uses kind_spec Contents Variables rwall zwall awall Variables Type Visibility Attributes Name Initial real(kind=RP), public :: rwall real(kind=RP), public :: zwall real(kind=RP), public :: awall","tags":"","loc":"module/wall_mod.html"},{"title":"file_name_mod – OFIT3D","text":"Uses kind_spec Contents Variables mag_file flx_file gcr_file punc1_file punc2_file Variables Type Visibility Attributes Name Initial character(len=200), public :: mag_file character(len=200), public :: flx_file character(len=200), public :: gcr_file character(len=200), public :: punc1_file character(len=200), public :: punc2_file","tags":"","loc":"module/file_name_mod.html"},{"title":"info_mod – OFIT3D","text":"Uses kind_spec Contents Variables read_time pre_time drive_time tot_time date0 time0 zone0 ver_info Variables Type Visibility Attributes Name Initial real(kind=RP), public :: read_time = 0.0_RP real(kind=RP), public :: pre_time = 0.0_RP real(kind=RP), public :: drive_time = 0.0_RP real(kind=RP), public :: tot_time = 0.0_RP character(len=10), public :: date0 = '' character(len=10), public :: time0 = '' character(len=10), public :: zone0 = '' character(len=5), public :: ver_info = ''","tags":"","loc":"module/info_mod.html"},{"title":"cylindrical_coord_mod – OFIT3D","text":"@file cylindrical_coord_mod.f90\n@author\nYasuhiro Suzuki, National Institute for Fusion Science\n@brief\nsubroutines for the interpolation and derivation of the magnetic field\nand normalized flux distribution\n@date 19 Apr 2020\n@version Initial Version Uses mpi_param_mod hdf5 param1 spline_mod netcdf mpi kind_spec Contents Variables file_format mag_file mag_form version lflux flx_file flx_form lvacout lsymmetry mtor nr0b nt0b nz0b ipfcoil kstep igrid bmax sedge pi2m rmaxb rminb zmaxb zminb delrb delzb badjust bnorm cj extcur cturn cfact cpfcoil mbound rg zg Subroutines free_mem_field magset mgval1 mgval2 mgval3 Variables Type Visibility Attributes Name Initial character(len=6), public :: file_format = 'bin' FILE_FORMAT sets the file format\n@li 1. bin:    Fortran binary \n@li 2. netcdf: netCDF (optional)\n@li 3. hdf5:   HDF5 @em(not implemnted yet) character(len=200), public :: mag_file MAG_FILE sets the file name of the magnetic field character(len=20), public :: mag_form = '' MAG_FORM prescribes the table format of the magnetic field.\n@li 1. mgrid:   file format used in MAKEGRID\n@li 2. mgo:     file format used in KMAG/KMAG2\n@li 3. mag:     file format for the equilibrium field used in HINT\n@li 4. vac:     file format for the vacuum field used in HINT\n@li 5. movie:   file format used in the MIPS code\n@li 6. mips_eq: file format for the equilibrium field used in MIPS\n@li 7. ofmc:    file format for the equilibrium field used in OFMC character(len=20), public :: version = '' VERSION prescribes the version for the old legacy format.\n@li 1. ver2:  legacy HINT2 format logical, public :: lflux LFLUX switches on/off to read the flux distribution. character(len=200), public :: flx_file FLX_FILE sets the file name of the flux distribution character(len=20), public :: flx_form = 'xss' FLX_FORM prescribes the table format of the flux distribution\n@li 1. xss:    file format used in SMAP\n@li 2. flx:    file format used in HINT\n@li 3. eqdsk:  file format used in EFIT\n@li 4. eqdata: file format used in TOPICS logical, public :: lvacout LVACOUT switches on/off to output the magnetic field logical, public :: lsymmetry LSYMMETRY enforces the stellarator symmetry integer, public :: mtor integer, public :: nr0b integer, public :: nt0b integer, public :: nz0b integer, public :: ipfcoil (500) = 0 integer, public :: kstep = 99999 integer, public :: igrid (4) real(kind=RP), public :: bmax = 5.0_RP real(kind=RP), public :: sedge = 0.98_RP real(kind=RP), public :: pi2m real(kind=RP), public :: rmaxb real(kind=RP), public :: rminb real(kind=RP), public :: zmaxb real(kind=RP), public :: zminb real(kind=RP), public :: delrb real(kind=RP), public :: delzb real(kind=RP), public :: badjust = 1.0_RP real(kind=RP), public :: bnorm = 3.0_RP real(kind=RP), public :: cj (500) = 0.0_RP real(kind=RP), public :: extcur (500) = 0.0_RP real(kind=RP), public :: cturn (500) = 1.0_RP real(kind=RP), public :: cfact (500) = 1.0_RP real(kind=RP), public :: cpfcoil (500) = 1.0_RP real(kind=RP), public :: mbound (4) = 0.0_RP real(kind=RP), public, ALLOCATABLE :: rg (:) real(kind=RP), public, ALLOCATABLE :: zg (:) Subroutines public subroutine free_mem_field () A subroutine that deallocates fortran arrays. Arguments None public subroutine magset () A subroutine that read a table of the magnetic field, (\\f$B_R, B_{\\phi}, B_Z, B\\f$),\non the cylindrical coordinate, (\\f$R, \\phi, Z\\f$).\n@n\n@em NOTE: the right-handed system Arguments None public subroutine mgval1 (r, phi, z, br, bp, bz, bb) A subroutine that interpolates magnetic fields, (\\f$B_R, B_{\\phi}, B_Z, B\\f$),\non a given coordinate, (\\f$R, \\phi, Z\\f$)\n@param[in] r \\f$ R \\f$ [m]\n@param[in] phi \\f$ \\phi \\f$ [rad]\n@param[in] z \\f$ Z \\f$ [m]\n@param[out] br \\f$ B_R \\f$ [T]\n@param[out] bp \\f$ B_{\\phi} \\f$ [T]\n@param[out] bz \\f$ B_Z \\f$ [T]\n@param[out] bb \\f$ |B| \\f$ [T] Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r real(kind=RP), intent(in) :: phi real(kind=RP), intent(in) :: z real(kind=RP), intent(out) :: br real(kind=RP), intent(out) :: bp real(kind=RP), intent(out) :: bz real(kind=RP), intent(out) :: bb public subroutine mgval2 (r, phi, z, b, dbdr, dbdp, dbdz) A subroutine that interpolates magnetic fields, (\\f$B_R, B_{\\phi}, B_Z, B\\f$),\nand calculates 1st derivative, (\\f$ \\partial \\textbf{B} / \\partial R, \\partial \\textbf{B} / \\partial \\phi, \\partial \\textbf{B} / \\partial Z \\f$),\non a given coordinate, (\\f$R, \\phi, Z\\f$)\n@param[in] r \\f$ R \\f$ [m]\n@param[in] phi \\f$ \\phi \\f$ [rad]\n@param[in] z \\f$ Z \\f$ [m]\n@param[out] b (\\f$ B_R, B_{\\phi}, B_Z, |B| \\f$)[T]\n@param[out] dbdr (\\f$ \\partial B_R / \\partial R, \\partial B_{\\phi} / \\partial R, \\partial B_Z / \\partial R, \\partial B / \\partial R \\f$) [T/m]\n@param[out] dbdp (\\f$ \\partial B_R / \\partial \\phi, \\partial B_{\\phi} / \\partial \\phi, \\partial B_Z / \\partial \\phi, \\partial B / \\partial \\phi \\f$) [T/rad]\n@param[out] dbdz (\\f$ \\partial B_R / \\partial Z, \\partial B_{\\phi} / \\partial Z, \\partial B_Z / \\partial Z, \\partial B / \\partial Z \\f$) [T/m] Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r real(kind=RP), intent(in) :: phi real(kind=RP), intent(in) :: z real(kind=RP), intent(out) :: b (l3d) real(kind=RP), intent(out) :: dbdr (l3d) real(kind=RP), intent(out) :: dbdp (l3d) real(kind=RP), intent(out) :: dbdz (l3d) public subroutine mgval3 (r, phi, z, s) A subroutine that interpolates normalized flux\non a given coordinate, (\\f$R, \\phi, Z\\f$)\n@param[in] r \\f$ R \\f$ [m]\n@param[in] phi \\f$ \\phi \\f$ [rad]\n@param[in] z \\f$ Z \\f$ [m]\n@param[out] s normalized flux Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r real(kind=RP), intent(in) :: phi real(kind=RP), intent(in) :: z real(kind=RP), intent(out) :: s","tags":"","loc":"module/cylindrical_coord_mod.html"},{"title":"vessel_mod – OFIT3D","text":"@file vessel_mod.f90\n@author\nYasuhiro Suzuki, National Institute for Fusion Science\n@brief @date 19 Apr 2020\n@version Initial Version Uses param1 kind_spec Contents Variables lvessel lcheck_vessel lintersect lvessel_vtk nu nv vessel_model vessel_file Subroutines free_mem_vessel read_vessel vessel check_vessel vessel_loss Variables Type Visibility Attributes Name Initial logical, public :: lvessel logical, public :: lcheck_vessel logical, public :: lintersect logical, public :: lvessel_vtk integer, public :: nu integer, public :: nv character(len=10), public :: vessel_model = '' character(len=300), public :: vessel_file = 'vessel.dat' Subroutines public subroutine free_mem_vessel () Arguments None public subroutine read_vessel () Arguments None public subroutine vessel (phi, r1, z1) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: phi real(kind=RP), intent(out) :: r1 (nu) real(kind=RP), intent(out) :: z1 (nu) public subroutine check_vessel (r, phi, z, iout) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r real(kind=RP), intent(in) :: phi real(kind=RP), intent(in) :: z integer, intent(out) :: iout public subroutine vessel_loss (r0, phi0, z0, r1, phi1, z1, intersect, beta, point) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r0 real(kind=RP), intent(in) :: phi0 real(kind=RP), intent(in) :: z0 real(kind=RP), intent(in) :: r1 real(kind=RP), intent(in) :: phi1 real(kind=RP), intent(in) :: z1 integer, intent(out) :: intersect real(kind=RP), intent(out) :: beta real(kind=RP), intent(out) :: point (3)","tags":"","loc":"module/vessel_mod.html"},{"title":"spline_mod – OFIT3D","text":"Contents Variables l1d l2d l3d nx1d nx2d ny2d nx3d ny3d nz3d f1d f2d f3d Subroutines splin1 splin2 splin3 spl1df spl1dd spl2df spl2dd spl3df spl3dd Variables Type Visibility Attributes Name Initial integer, public :: l1d = 1 integer, public :: l2d = 1 integer, public :: l3d = 3 integer, public :: nx1d integer, public :: nx2d integer, public :: ny2d integer, public :: nx3d integer, public :: ny3d integer, public :: nz3d real(kind=RP), public, ALLOCATABLE :: f1d (:,:) real(kind=RP), public, ALLOCATABLE :: f2d (:,:,:) real(kind=RP), public, ALLOCATABLE :: f3d (:,:,:,:) Subroutines public subroutine splin1 (xsd, xld) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xsd real(kind=RP), intent(in) :: xld public subroutine splin2 (xsd, xld, ysd, yld) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xsd real(kind=RP), intent(in) :: xld real(kind=RP), intent(in) :: ysd real(kind=RP), intent(in) :: yld public subroutine splin3 (xsd, xld, ysd, yld, zsd, zld) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xsd real(kind=RP), intent(in) :: xld real(kind=RP), intent(in) :: ysd real(kind=RP), intent(in) :: yld real(kind=RP), intent(in) :: zsd real(kind=RP), intent(in) :: zld public subroutine spl1df (xd, w0) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd real(kind=RP), intent(out) :: w0 (l1d) public subroutine spl1dd (xd, w0, wx) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd (2) real(kind=RP), intent(out) :: w0 (l1d) real(kind=RP), intent(out) :: wx (l1d) public subroutine spl2df (xd, w0) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd (2) real(kind=RP), intent(out) :: w0 (l2d) public subroutine spl2dd (xd, w0, wx, wy) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd (2) real(kind=RP), intent(out) :: w0 (l2d) real(kind=RP), intent(out) :: wx (l2d) real(kind=RP), intent(out) :: wy (l2d) public subroutine spl3df (xd, w0) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd (3) real(kind=RP), intent(out) :: w0 (l3d) public subroutine spl3dd (xd, w0, wx, wy, wz) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: xd (3) real(kind=RP), intent(out) :: w0 (l3d) real(kind=RP), intent(out) :: wx (l3d) real(kind=RP), intent(out) :: wy (l3d) real(kind=RP), intent(out) :: wz (l3d)","tags":"","loc":"module/spline_mod.html"},{"title":"divertor_mod – OFIT3D","text":"@file divertor_mod.f90\n@author\nYasuhiro Suzuki, National Institute for Fusion Science\n@brief @date 19 Apr 2020\n@version Initial Version Uses param1 kind_spec Contents Variables ldivertor ldivertor_vtk num_nodes num_elements divertor_model divertor_file nodes_file elements_file Subroutines free_mem_divertor read_divertor divertor_loss Variables Type Visibility Attributes Name Initial logical, public :: ldivertor = .false. logical, public :: ldivertor_vtk = .false. integer, public :: num_nodes = 18 integer, public :: num_elements = 20 character(len=10), public :: divertor_model = '' character(len=300), public :: divertor_file = '' character(len=300), public :: nodes_file = '' character(len=300), public :: elements_file = '' Subroutines public subroutine free_mem_divertor () Arguments None public subroutine read_divertor () Arguments None public subroutine divertor_loss (r0, phi0, z0, r1, phi1, z1, intersect, beta, point) Arguments Type Intent Optional Attributes Name real(kind=RP), intent(in) :: r0 real(kind=RP), intent(in) :: phi0 real(kind=RP), intent(in) :: z0 real(kind=RP), intent(in) :: r1 real(kind=RP), intent(in) :: phi1 real(kind=RP), intent(in) :: z1 integer, intent(out) :: intersect real(kind=RP), intent(out) :: beta real(kind=RP), intent(out) :: point (3)","tags":"","loc":"module/divertor_mod.html"},{"title":"GCR – OFIT3D","text":"Uses mpi_param_mod info_mod param2 mpi cylindrical_coord_mod Contents Variables fmt ierr Variables Type Attributes Name Initial character(len=100) :: fmt integer :: ierr","tags":"","loc":"program/gcr.html"},{"title":"file_close.f90 – OFIT3D","text":"Contents Subroutines file_close Source Code file_close.f90 Source Code !=file_close.f90 ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! SUBROUTINE file_close USE param2 , ONLY : lmonitor , & & lpunc USE cylindrical_coord_mod , ONLY : lflux IMPLICIT NONE CLOSE ( 25 ) IF ( lflux ) THEN CLOSE ( 26 ) END IF IF ( lmonitor ) THEN CLOSE ( 50 ) END IF IF ( lpunc ) THEN CLOSE ( 61 ) CLOSE ( 62 ) END IF END SUBROUTINE file_close","tags":"","loc":"sourcefile/file_close.f90.html"},{"title":"file_open.f90 – OFIT3D","text":"Contents Subroutines file_open Source Code file_open.f90 Source Code !=file_open ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! SUBROUTINE file_open USE param2 , ONLY : lmonitor , & & lpunc USE cylindrical_coord_mod , ONLY : lflux USE file_name_mod , ONLY : fopen , & & mag_file , & & flx_file , & & gcr_file , & & punc1_file , & & punc2_file IMPLICIT NONE READ ( 10 , fopen ) WRITE ( 6 , fopen ) OPEN ( 25 , FILE = mag_file , FORM = 'unformatted' ) IF ( lflux ) THEN OPEN ( 26 , FILE = flx_file , FORM = 'formatted' ) END IF IF ( lmonitor ) THEN OPEN ( 50 , FILE = gcr_file , FORM = 'formatted' ) END IF IF ( lpunc ) THEN OPEN ( 61 , FILE = punc1_file , FORM = 'formatted' ) OPEN ( 62 , FILE = punc2_file , FORM = 'formatted' ) END IF END SUBROUTINE file_open","tags":"","loc":"sourcefile/file_open.f90.html"},{"title":"libetc.f90 – OFIT3D","text":"Contents Functions upsilon_cal xsi_cal funphi Subroutines qsimp trapzd Source Code libetc.f90 Source Code FUNCTION upsilon_cal ( x & !(in) & ) IMPLICIT NONE !Arguments REAL ( 8 ), INTENT ( IN ) :: x !Local variables REAL ( 8 ), PARAMETER :: pi = 3.141592653589793238462643383279502884197_8 REAL ( 8 ) :: upsilon_cal , & & integral REAL ( 8 ), EXTERNAL :: funphi !---------------------------------------- CALL qsimp ( funphi , 0.0_8 , x , integral ) !---------------------------------------- upsilon_cal = 2.0_8 * integral / SQRT ( pi ) RETURN END FUNCTION upsilon_cal FUNCTION xsi_cal ( x & !(in) & ) IMPLICIT NONE !Arguments REAL ( 8 ), INTENT ( IN ) :: x !Local variables REAL ( 8 ), PARAMETER :: pi = 3.141592653589793238462643383279502884197_8 REAL ( 8 ) :: xsi_cal , & & upsilon , & & dupsilon REAL ( 8 ), EXTERNAL :: upsilon_cal upsilon = upsilon_cal ( x ) dupsilon = 2.0_8 / ( SQRT ( pi ) * EXP ( x ** 2 )) xsi_cal = ( upsilon - x * dupsilon ) / ( 2.0_8 * x ** 2 ) RETURN END FUNCTION xsi_cal FUNCTION funphi ( t & !(in) & ) IMPLICIT NONE !Arguments REAL ( 8 ), INTENT ( IN ) :: t !Local varibales REAL ( 8 ) :: funphi funphi = 1.0_8 / EXP ( t ** 2 ) RETURN END FUNCTION funphi SUBROUTINE qsimp ( func , a , b , & ! (in) & s & !(out) & ) IMPLICIT NONE REAL ( 8 ), INTENT ( IN ) :: a , & & b REAL ( 8 ), INTENT ( OUT ) :: s INTEGER , PARAMETER :: jmax = 20 INTEGER :: j REAL ( 8 ), PARAMETER :: eps = 1.0e-06_8 REAL ( 8 ) :: os , & & ost , & & st REAL ( 8 ), EXTERNAL :: func ost = - 1.0e+30_8 os = - 1.0e+30_8 loop010 : DO j = 1 , jmax CALL trapzd ( func , a , b , st , j ) s = ( 4.0_8 * st - ost ) / 3.0_8 IF ( j > 5 ) then IF (( ABS ( s - os ) < eps * ABS ( os )) . or . (( s == 0.0_8 ) . and . ( os == 0.0_8 ))) RETURN END IF os = s ost = st END DO loop010 STOP ' too many steps in qsimp ' END SUBROUTINE qsimp SUBROUTINE trapzd ( func , a , b , s , n ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: n REAL ( 8 ), INTENT ( IN ) :: a , & & b REAL ( 8 ), INTENT ( OUT ) :: s INTEGER :: it , & & j REAL ( 8 ) :: del , & & sum , & & tnm , & & x REAL ( 8 ), EXTERNAL :: func IF ( n == 1 ) THEN s = 0.5_8 * ( b - a ) * ( func ( a ) + func ( b )) ELSE it = 2 ** ( n - 2 ) tnm = it del = ( b - a ) / tnm x = a + 0.5_8 * del sum = 0.0_8 loop010 : DO j = 1 , it sum = sum + func ( x ) x = x + del END DO loop010 s = 0.5_8 * ( s + ( b - a ) * sum / tnm ) END IF RETURN END SUBROUTINE trapzd","tags":"","loc":"sourcefile/libetc.f90.html"},{"title":"main.f90 – OFIT3D","text":"Contents Programs GCR Source Code main.f90 Source Code !=main.f90 ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! PROGRAM GCR USE param2 , ONLY : lfile USE cylindrical_coord_mod , ONLY : free_mem_field USE info_mod USE mpi_param_mod , ONLY : nprocs , & & myrank USE mpi IMPLICIT NONE CHARACTER ( LEN = 100 ) :: fmt !for MPI INTEGER :: ierr CALL MPI_INIT ( ierr ) CALL MPI_COMM_SIZE ( MPI_COMM_WORLD , nprocs , ierr ) CALL MPI_COMM_RANK ( MPI_COMM_WORLD , myrank , ierr ) ver_info = '1.0.0' IF ( myrank == 0 ) THEN PRINT * PRINT * , ' GCR (MPI) --- GUIDING-CENTER ORBIT FOLLOWING CODE, VERSION ' , ver_info , ' ---' PRINT * END IF CALL readin CALL precal CALL driver CALL free_mem_field IF ( lfile ) CALL file_open tot_time = read_time + pre_time + drive_time IF ( myrank == 0 ) THEN fmt = '(A30, F15.4, A10)' PRINT * PRINT * PRINT fmt , 'TIME IN SUBROUTINE READIN  ' , read_time , 'SECONDS' PRINT fmt , 'TIME IN SUBROUTINE PRECALC ' , pre_time , 'SECONDS' PRINT fmt , 'TIME IN SUBROUTINE DRIVER  ' , drive_time , 'SECONDS' PRINT fmt , 'TOTAL COMPUTATIONAL TIME   ' , tot_time , 'SECONDS' fmt = '(2X, A6, A2, A1, A2, A1, A4, A6, A2, A1, A2, A1, A2)' CALL DATE_AND_TIME ( date0 , time0 , zone0 ) PRINT * PRINT fmt , ' DATE= ' , date0 ( 5 : 6 ), '/' , date0 ( 7 : 8 ), '/' , date0 ( 1 : 4 ), & ' TIME= ' , time0 ( 1 : 2 ), ':' , time0 ( 3 : 4 ), ':' , time0 ( 5 : 6 ) PRINT * PRINT * END IF CALL MPI_BARRIER ( MPI_COMM_WORLD , ierr ) CALL MPI_FINALIZE ( ierr ) END PROGRAM GCR","tags":"","loc":"sourcefile/main.f90.html"},{"title":"mgcpu.f90 – OFIT3D","text":"Contents Subroutines mgcpu Source Code mgcpu.f90 Source Code !=mgcpu.f90 ! !==Version ! ! $Revision: $ ! $Id: $ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! SUBROUTINE mgcpu ( itime , mess & ! (in) & ) USE kind_spec #ifdef MPI USE mpi_param_mod , ONLY : myrank USE mpi #endif IMPLICIT NONE INTEGER :: i , & & itime , & & min1 , & & min2 !INTEGER, SAVE :: it =  0 INTEGER , SAVE :: it = - 1 REAL ( DP ) :: ccp , & & sec1 , & & sec2 , & & etime , & & ta ( 2 ) REAL ( DP ), SAVE :: cpu1 ( 100 ), & & cpu2 ( 100 ) CHARACTER ( LEN = 20 ) :: mess , & & mess1 ( 100 ) CHARACTER ( LEN = 100 ) :: fmt #ifdef MPI IF ( myrank == 0 ) THEN #endif it = it + 1 #ifdef MPI ccp = MPI_WTIME () IF ( itime == - 1 ) THEN ta ( 1 ) = ccp ta ( 2 ) = ccp RETURN END IF #else !  ccp = etime(ta) CALL CPU_TIME ( ccp ) #endif IF ( it == 1 ) THEN cpu1 ( it ) = ccp cpu2 ( it ) = ccp cpu1 ( it ) = ccp cpu2 ( it ) = ccp ELSE cpu1 ( it ) = ccp cpu2 ( it ) = ccp - cpu1 ( it - 1 ) !cpu2(it) =  ccp - cpu2(it-1) !cpu1(it) =  cpu1(it-1) + cpu2(it) END IF mess1 ( it ) = mess IF ( itime == 0 ) RETURN PRINT * fmt = '(I4, 2X, A20, A15, I5, A4, F9.3, A4, A13, I5, A4, F9.3, A4)' loop010 : DO i = 1 , it min1 = cpu1 ( i ) / 60 min2 = cpu2 ( i ) / 60 sec1 = cpu1 ( i ) - min1 * 60 sec2 = cpu2 ( i ) - min2 * 60 PRINT fmt , i , mess1 ( i ), '; Exec Time ...' , min2 , ' min' , sec2 , ' sec' , & & '; Total ... ' , min1 , ' min' , sec1 , ' sec' END DO loop010 #ifdef MPI END IF #endif END SUBROUTINE mgcpu","tags":"","loc":"sourcefile/mgcpu.f90.html"},{"title":"mpi_param_mod.f90 – OFIT3D","text":"Contents Modules mpi_param_mod Source Code mpi_param_mod.f90 Source Code !=mpi_param_mod.f90 ! !==Version ! ! $Revision: $ ! $Id: $ ! !==Overview ! ! SUBROUTINEs for MPI communication ! !==Reference ! ! None ! !==Error Handlings ! ! None ! !==Known Bugs ! ! None ! !==Note ! ! None ! !==TODO ! ! Change to MPI2 ! MODULE mpi_param_mod USE kind_spec USE mpi IMPLICIT NONE PRIVATE !  include 'mpif.h' INTEGER :: myrank , & & nprocs , & & nsta , & & nend PUBLIC :: myrank , & & nprocs , & & nsta , & & nend , & & para_range CONTAINS SUBROUTINE para_range ( m1 , m2 , mprocs , mrank , & ! (in) & msta , mend & ! (out) & ) IMPLICIT NONE !Arguments INTEGER , INTENT ( IN ) :: m1 , & & m2 , & & mprocs , & & mrank INTEGER , INTENT ( OUT ) :: msta , & & mend !Local variables INTEGER :: mwork1 , & & mwork2 mwork1 = ( m2 - m1 + 1 ) / mprocs mwork2 = MOD ( m2 - m1 + 1 , mprocs ) msta = mrank * mwork1 + m1 + MIN ( mrank , mwork2 ) mend = msta + mwork1 - 1 IF ( mwork2 > mrank ) mend = mend + 1 RETURN END SUBROUTINE para_range END MODULE mpi_param_mod","tags":"","loc":"sourcefile/mpi_param_mod.f90.html"},{"title":"mt95.f90 – OFIT3D","text":"Contents Modules mt95 Source Code mt95.f90 Source Code ! A C-program for MT19937, with initialization improved 2002/1/26. ! Coded by Takuji Nishimura and Makoto Matsumoto. ! Code converted to Fortran 95 by José Rui Faustino de Sousa ! Date: 2002-02-01 ! Enhanced version by José Rui Faustino de Sousa ! Date: 2003-04-30 ! Interface: ! ! Kinds: !   genrand_intg !     Integer kind used must be at least 32 bits. !   genrand_real !     Real kind used ! ! Types: !   genrand_state !     Internal representation of the RNG state. !   genrand_srepr !     Public representation of the RNG state. Should be used to save the RNG state. ! ! Procedures: !   assignment(=) !     Converts from type genrand_state to genrand_srepr and vice versa. !   genrand_init !     Internal RNG state initialization subroutine accepts either an genrand_intg integer !     or a vector as seed or a new state using \"put=\" returns the present state using !     \"get=\". If it is called with \"get=\" before being seeded with \"put=\" returns a state !     initialized with a default seed. !   genrand_int32 !     Subroutine returns an array or scalar whose elements are random integer on the !     [0,0xffffffff] interval. !   genrand_int31 !     Subroutine returns an array or scalar whose elements are random integer on the !     [0,0x7fffffff] interval. !   genrand_real1 !     Subroutine returns an array or scalar whose elements are random real on the !     [0,1] interval. !   genrand_real2 !     Subroutine returns an array or scalar whose elements are random real on the !     [0,1[ interval. !   genrand_real3 !     Subroutine returns an array or scalar whose elements are random real on the !     ]0,1[ interval. !   genrand_res53 !     Subroutine returns an array or scalar whose elements are random real on the !     [0,1[ interval with 53-bit resolution. ! Before using, initialize the state by using genrand_init( put=seed ) ! This library is free software. ! This library is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ! Copyright (C) 1997, 2002 Makoto Matsumoto and Takuji Nishimura. ! Any feedback is very welcome. ! http://www.math.keio.ac.jp/matumoto/emt.html ! email: matumoto@math.keio.ac.jp module mt95 implicit none public :: genrand_init , assignment ( = ) public :: genrand_int32 , genrand_int31 , genrand_real1 public :: genrand_real2 , genrand_real3 , genrand_res53 private :: uiadd , uisub , uimlt , uidiv , uimod private :: init_by_type , init_by_scalar , init_by_array , next_state private :: genrand_encode , genrand_decode , genrand_load_state , genrand_dump_state private :: genrand_int32_0d , genrand_int32_1d , genrand_int32_2d , genrand_int32_3d private :: genrand_int32_4d , genrand_int32_5d , genrand_int32_6d , genrand_int32_7d private :: genrand_int31_0d , genrand_int31_1d , genrand_int31_2d , genrand_int31_3d private :: genrand_int31_4d , genrand_int31_5d , genrand_int31_6d , genrand_int31_7d private :: genrand_real1_0d , genrand_real1_1d , genrand_real1_2d , genrand_real1_3d private :: genrand_real1_4d , genrand_real1_5d , genrand_real1_6d , genrand_real1_7d private :: genrand_real2_0d , genrand_real2_1d , genrand_real2_2d , genrand_real2_3d private :: genrand_real2_4d , genrand_real2_5d , genrand_real2_6d , genrand_real2_7d private :: genrand_real3_0d , genrand_real3_1d , genrand_real3_2d , genrand_real3_3d private :: genrand_real3_4d , genrand_real3_5d , genrand_real3_6d , genrand_real3_7d private :: genrand_res53_0d , genrand_res53_1d , genrand_res53_2d , genrand_res53_3d private :: genrand_res53_4d , genrand_res53_5d , genrand_res53_6d , genrand_res53_7d intrinsic :: selected_int_kind , selected_real_kind integer , public , parameter :: genrand_intg = selected_int_kind ( 9 ) integer , public , parameter :: genrand_real = selected_real_kind ( 15 ) integer , private , parameter :: wi = genrand_intg integer , private , parameter :: wr = genrand_real ! Period parameters integer ( kind = wi ), private , parameter :: n = 624_wi integer ( kind = wi ), private , parameter :: m = 397_wi integer ( kind = wi ), private , parameter :: default_seed = 5489_wi integer ( kind = wi ), private , parameter :: fbs = 32_wi integer ( kind = wi ), private , parameter :: hbs = fbs / 2_wi integer ( kind = wi ), private , parameter :: qbs = hbs / 2_wi integer ( kind = wi ), private , parameter :: tbs = 3_wi * qbs real ( kind = wr ), private , parameter :: p231 = 214748364 8.0_wr real ( kind = wr ), private , parameter :: p232 = 429496729 6.0_wr real ( kind = wr ), private , parameter :: p232_1 = p232 - 1.0_wr real ( kind = wr ), private , parameter :: pi232 = 1.0_wr / p232 real ( kind = wr ), private , parameter :: pi232_1 = 1.0_wr / p232_1 real ( kind = wr ), private , parameter :: pi227 = 1.0_wr / 13421772 8.0_wr real ( kind = wr ), private , parameter :: pi253 = 1.0_wr / 900719925474099 2.0_wr real ( kind = wr ), private , parameter :: p231d232_1 = p231 / p232_1 real ( kind = wr ), private , parameter :: p231_5d232 = ( p231 + 0.5_wr ) / p232 character ( len =* ), private , parameter :: alph = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" character ( len =* ), private , parameter :: sepr = \"&\" integer ( kind = wi ), private , parameter :: alps = 62_wi integer ( kind = wi ), private , parameter :: clen = ( n + 1_wi ) * 7_wi !n * ( ceiling( fbs * log( 2.0 ) / log( alps ) ) + 1 ) type , public :: genrand_state private logical ( kind = wi ) :: ini = . false . _ wi integer ( kind = wi ) :: cnt = n + 1_wi integer ( kind = wi ), dimension ( n ) :: val = 0_wi end type genrand_state type , public :: genrand_srepr character ( len = clen ) :: repr end type genrand_srepr type ( genrand_state ), private , save :: state interface assignment ( = ) module procedure genrand_load_state module procedure genrand_dump_state end interface assignment ( = ) interface genrand_init module procedure init_by_type module procedure init_by_scalar module procedure init_by_array end interface genrand_init interface genrand_int32 module procedure genrand_int32_0d module procedure genrand_int32_1d module procedure genrand_int32_2d module procedure genrand_int32_3d module procedure genrand_int32_4d module procedure genrand_int32_5d module procedure genrand_int32_6d module procedure genrand_int32_7d end interface genrand_int32 interface genrand_int31 module procedure genrand_int31_0d module procedure genrand_int31_1d module procedure genrand_int31_2d module procedure genrand_int31_3d module procedure genrand_int31_4d module procedure genrand_int31_5d module procedure genrand_int31_6d module procedure genrand_int31_7d end interface genrand_int31 interface genrand_real1 module procedure genrand_real1_0d module procedure genrand_real1_1d module procedure genrand_real1_2d module procedure genrand_real1_3d module procedure genrand_real1_4d module procedure genrand_real1_5d module procedure genrand_real1_6d module procedure genrand_real1_7d end interface genrand_real1 interface genrand_real2 module procedure genrand_real2_0d module procedure genrand_real2_1d module procedure genrand_real2_2d module procedure genrand_real2_3d module procedure genrand_real2_4d module procedure genrand_real2_5d module procedure genrand_real2_6d module procedure genrand_real2_7d end interface genrand_real2 interface genrand_real3 module procedure genrand_real3_0d module procedure genrand_real3_1d module procedure genrand_real3_2d module procedure genrand_real3_3d module procedure genrand_real3_4d module procedure genrand_real3_5d module procedure genrand_real3_6d module procedure genrand_real3_7d end interface genrand_real3 interface genrand_res53 module procedure genrand_res53_0d module procedure genrand_res53_1d module procedure genrand_res53_2d module procedure genrand_res53_3d module procedure genrand_res53_4d module procedure genrand_res53_5d module procedure genrand_res53_6d module procedure genrand_res53_7d end interface genrand_res53 contains elemental function uiadd ( a , b ) result ( c ) intrinsic :: ibits , ior , ishft integer ( kind = wi ), intent ( in ) :: a , b integer ( kind = wi ) :: c integer ( kind = wi ) :: a1 , a2 , b1 , b2 , s1 , s2 a1 = ibits ( a , 0 , hbs ) a2 = ibits ( a , hbs , hbs ) b1 = ibits ( b , 0 , hbs ) b2 = ibits ( b , hbs , hbs ) s1 = a1 + b1 s2 = a2 + b2 + ibits ( s1 , hbs , hbs ) c = ior ( ishft ( s2 , hbs ), ibits ( s1 , 0 , hbs ) ) return end function uiadd elemental function uisub ( a , b ) result ( c ) intrinsic :: ibits , ior , ishft integer ( kind = wi ), intent ( in ) :: a , b integer ( kind = wi ) :: c integer ( kind = wi ) :: a1 , a2 , b1 , b2 , s1 , s2 a1 = ibits ( a , 0 , hbs ) a2 = ibits ( a , hbs , hbs ) b1 = ibits ( b , 0 , hbs ) b2 = ibits ( b , hbs , hbs ) s1 = a1 - b1 s2 = a2 - b2 + ibits ( s1 , hbs , hbs ) c = ior ( ishft ( s2 , hbs ), ibits ( s1 , 0 , hbs ) ) return end function uisub elemental function uimlt ( a , b ) result ( c ) intrinsic :: ibits , ior , ishft integer ( kind = wi ), intent ( in ) :: a , b integer ( kind = wi ) :: c integer ( kind = wi ) :: a0 , a1 , a2 , a3 integer ( kind = wi ) :: b0 , b1 , b2 , b3 integer ( kind = wi ) :: p0 , p1 , p2 , p3 a0 = ibits ( a , 0 , qbs ) a1 = ibits ( a , qbs , qbs ) a2 = ibits ( a , hbs , qbs ) a3 = ibits ( a , tbs , qbs ) b0 = ibits ( b , 0 , qbs ) b1 = ibits ( b , qbs , qbs ) b2 = ibits ( b , hbs , qbs ) b3 = ibits ( b , tbs , qbs ) p0 = a0 * b0 p1 = a1 * b0 + a0 * b1 + ibits ( p0 , qbs , tbs ) p2 = a2 * b0 + a1 * b1 + a0 * b2 + ibits ( p1 , qbs , tbs ) p3 = a3 * b0 + a2 * b1 + a1 * b2 + a0 * b3 + ibits ( p2 , qbs , tbs ) c = ior ( ishft ( p1 , qbs ), ibits ( p0 , 0 , qbs ) ) c = ior ( ishft ( p2 , hbs ), ibits ( c , 0 , hbs ) ) c = ior ( ishft ( p3 , tbs ), ibits ( c , 0 , tbs ) ) return end function uimlt elemental function uidiv ( a , b ) result ( c ) intrinsic :: btest , ishft integer ( kind = wi ), intent ( in ) :: a , b integer ( kind = wi ) :: c integer ( kind = wi ) :: dl , rl if ( btest ( a , fbs - 1 ) ) then if ( btest ( b , fbs - 1 ) ) then if ( a < b ) then c = 0 else c = 1 end if else dl = ishft ( ishft ( a , - 1 ) / b , 1 ) rl = uisub ( a , uimlt ( b , dl ) ) if ( rl < b ) then c = dl else c = uiadd ( dl , 1 ) end if end if else if ( btest ( b , fbs - 1 ) ) then c = 0 else c = a / b end if end if return end function uidiv elemental function uimod ( a , b ) result ( c ) intrinsic :: modulo , btest , ishft integer ( kind = wi ), intent ( in ) :: a , b integer ( kind = wi ) :: c integer ( kind = wi ) :: dl , rl if ( btest ( a , fbs - 1 ) ) then if ( btest ( b , fbs - 1 ) ) then if ( a < b ) then c = a else c = uisub ( a , b ) end if else dl = ishft ( ishft ( a , - 1 ) / b , 1 ) rl = uisub ( a , uimlt ( b , dl ) ) if ( rl < b ) then c = rl else c = uisub ( rl , b ) end if end if else if ( btest ( b , fbs - 1 ) ) then c = a else c = modulo ( a , b ) end if end if return end function uimod subroutine init_by_type ( put , get ) intrinsic :: present type ( genrand_state ), optional , intent ( in ) :: put type ( genrand_state ), optional , intent ( out ) :: get if ( present ( put ) ) then if ( put % ini ) state = put else if ( present ( get ) ) then if ( . not . state % ini ) call init_by_scalar ( default_seed ) get = state else call init_by_scalar ( default_seed ) end if return end subroutine init_by_type ! initializes mt[N] with a seed subroutine init_by_scalar ( put ) intrinsic :: ishft , ieor , ibits integer ( kind = wi ), parameter :: mult_a = 1812433253_wi !z'6C078965' integer ( kind = wi ), intent ( in ) :: put integer ( kind = wi ) :: i state % ini = . true . _ wi state % val ( 1 ) = ibits ( put , 0 , fbs ) do i = 2 , n , 1 state % val ( i ) = ieor ( state % val ( i - 1 ), ishft ( state % val ( i - 1 ), - 30 ) ) state % val ( i ) = uimlt ( state % val ( i ), mult_a ) state % val ( i ) = uiadd ( state % val ( i ), i - 1_wi ) ! See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. ! In the previous versions, MSBs of the seed affect ! only MSBs of the array mt[]. ! 2002/01/09 modified by Makoto Matsumoto state % val ( i ) = ibits ( state % val ( i ), 0 , fbs ) ! for >32 bit machines end do state % cnt = n + 1_wi return end subroutine init_by_scalar ! initialize by an array with array-length ! init_key is the array for initializing keys ! key_length is its length subroutine init_by_array ( put ) intrinsic :: size , max , ishft , ieor , ibits integer ( kind = wi ), parameter :: seed_d = 19650218_wi !z'12BD6AA' integer ( kind = wi ), parameter :: mult_a = 1664525_wi !z'19660D' integer ( kind = wi ), parameter :: mult_b = 1566083941_wi !z'5D588B65' integer ( kind = wi ), parameter :: msb1_d = ishft ( 1_wi , fbs - 1 ) !z'80000000' integer ( kind = wi ), dimension (:), intent ( in ) :: put integer ( kind = wi ) :: i , j , k , tp , key_length call init_by_scalar ( seed_d ) key_length = size ( put , dim = 1 ) i = 2_wi j = 1_wi do k = max ( n , key_length ), 1 , - 1 tp = ieor ( state % val ( i - 1 ), ishft ( state % val ( i - 1 ), - 30 ) ) tp = uimlt ( tp , mult_a ) state % val ( i ) = ieor ( state % val ( i ), tp ) state % val ( i ) = uiadd ( state % val ( i ), uiadd ( put ( j ), j - 1_wi ) ) ! non linear state % val ( i ) = ibits ( state % val ( i ), 0 , fbs ) ! for WORDSIZE > 32 machines i = i + 1_wi j = j + 1_wi if ( i > n ) then state % val ( 1 ) = state % val ( n ) i = 2_wi end if if ( j > key_length ) j = 1_wi end do do k = n - 1 , 1 , - 1 tp = ieor ( state % val ( i - 1 ), ishft ( state % val ( i - 1 ), - 30 ) ) tp = uimlt ( tp , mult_b ) state % val ( i ) = ieor ( state % val ( i ), tp ) state % val ( i ) = uisub ( state % val ( i ), i - 1_wi ) ! non linear state % val ( i ) = ibits ( state % val ( i ), 0 , fbs ) ! for WORDSIZE > 32 machines i = i + 1_wi if ( i > n ) then state % val ( 1 ) = state % val ( n ) i = 2_wi end if end do state % val ( 1 ) = msb1_d ! MSB is 1; assuring non-zero initial array return end subroutine init_by_array subroutine next_state ( ) intrinsic :: ishft , ieor , btest , ibits , mvbits integer ( kind = wi ), parameter :: matrix_a = - 1727483681_wi !z'9908b0df' integer ( kind = wi ) :: i , mld if ( . not . state % ini ) call init_by_scalar ( default_seed ) do i = 1 , n - m , 1 mld = ibits ( state % val ( i + 1 ), 0 , 31 ) call mvbits ( state % val ( i ), 31 , 1 , mld , 31 ) state % val ( i ) = ieor ( state % val ( i + m ), ishft ( mld , - 1 ) ) if ( btest ( state % val ( i + 1 ), 0 ) ) state % val ( i ) = ieor ( state % val ( i ), matrix_a ) end do do i = n - m + 1 , n - 1 , 1 mld = ibits ( state % val ( i + 1 ), 0 , 31 ) call mvbits ( state % val ( i ), 31 , 1 , mld , 31 ) state % val ( i ) = ieor ( state % val ( i + m - n ), ishft ( mld , - 1 ) ) if ( btest ( state % val ( i + 1 ), 0 ) ) state % val ( i ) = ieor ( state % val ( i ), matrix_a ) end do mld = ibits ( state % val ( 1 ), 0 , 31 ) call mvbits ( state % val ( n ), 31 , 1 , mld , 31 ) state % val ( n ) = ieor ( state % val ( m ), ishft ( mld , - 1 ) ) if ( btest ( state % val ( 1 ), 0 ) ) state % val ( n ) = ieor ( state % val ( n ), matrix_a ) state % cnt = 1_wi return end subroutine next_state elemental subroutine genrand_encode ( chr , val ) intrinsic :: len character ( len =* ), intent ( out ) :: chr integer ( kind = wi ), intent ( in ) :: val integer ( kind = wi ) :: i , m , d d = val chr = \"\" do i = 1 , len ( chr ), 1 m = uimod ( d , alps ) + 1 chr ( i : i ) = alph ( m : m ) d = uidiv ( d , alps ) if ( d == 0 ) exit end do return end subroutine genrand_encode elemental subroutine genrand_decode ( val , chr ) intrinsic :: len , len_trim , trim , adjustl , scan integer ( kind = wi ), intent ( out ) :: val character ( len =* ), intent ( in ) :: chr integer ( kind = wi ) :: i , e , p character ( len = len ( chr )) :: c e = 1 c = trim ( adjustl ( chr ) ) val = 0 do i = 1 , len_trim ( c ), 1 p = scan ( alph , c ( i : i ) ) - 1 if ( p >= 0 ) then val = uiadd ( val , uimlt ( p , e ) ) e = uimlt ( e , alps ) end if end do return end subroutine genrand_decode elemental subroutine genrand_load_state ( stt , rpr ) intrinsic :: scan type ( genrand_state ), intent ( out ) :: stt type ( genrand_srepr ), intent ( in ) :: rpr integer ( kind = wi ) :: i , j character ( len = clen ) :: c i = 1 c = rpr % repr do j = scan ( c , sepr ) if ( j /= 0 ) then call genrand_decode ( stt % val ( i ), c (: j - 1 ) ) i = i + 1 c = c ( j + 1 :) else exit end if end do call genrand_decode ( stt % cnt , c ) stt % ini = . true . _ wi return end subroutine genrand_load_state elemental subroutine genrand_dump_state ( rpr , stt ) intrinsic :: len_trim type ( genrand_srepr ), intent ( out ) :: rpr type ( genrand_state ), intent ( in ) :: stt integer ( kind = wi ) :: i , j j = 1 rpr % repr = \"\" do i = 1 , n , 1 call genrand_encode ( rpr % repr ( j :), stt % val ( i ) ) j = len_trim ( rpr % repr ) + 1 rpr % repr ( j : j ) = sepr j = j + 1 end do call genrand_encode ( rpr % repr ( j :), stt % cnt ) return end subroutine genrand_dump_state ! generates a random number on [0,0xffffffff]-interval subroutine genrand_int32_0d ( y ) intrinsic :: ieor , iand , ishft integer ( kind = wi ), parameter :: temper_a = - 1658038656_wi !z'9D2C5680' integer ( kind = wi ), parameter :: temper_b = - 272236544_wi !z'EFC60000' integer ( kind = wi ), intent ( out ) :: y if ( state % cnt > n ) call next_state ( ) y = state % val ( state % cnt ) state % cnt = state % cnt + 1_wi ! Tempering y = ieor ( y , ishft ( y , - 11 ) ) y = ieor ( y , iand ( ishft ( y , 7 ), temper_a ) ) y = ieor ( y , iand ( ishft ( y , 15 ), temper_b ) ) y = ieor ( y , ishft ( y , - 18 ) ) return end subroutine genrand_int32_0d subroutine genrand_int32_1d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 1 ), 1 call genrand_int32_0d ( y ( i ) ) end do return end subroutine genrand_int32_1d subroutine genrand_int32_2d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 2 ), 1 call genrand_int32_1d ( y (:, i ) ) end do return end subroutine genrand_int32_2d subroutine genrand_int32_3d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 3 ), 1 call genrand_int32_2d ( y (:,:, i ) ) end do return end subroutine genrand_int32_3d subroutine genrand_int32_4d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:,:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 4 ), 1 call genrand_int32_3d ( y (:,:,:, i ) ) end do return end subroutine genrand_int32_4d subroutine genrand_int32_5d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:,:,:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 5 ), 1 call genrand_int32_4d ( y (:,:,:,:, i ) ) end do return end subroutine genrand_int32_5d subroutine genrand_int32_6d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:,:,:,:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 6 ), 1 call genrand_int32_5d ( y (:,:,:,:,:, i ) ) end do return end subroutine genrand_int32_6d subroutine genrand_int32_7d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:,:,:,:,:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 7 ), 1 call genrand_int32_6d ( y (:,:,:,:,:,:, i ) ) end do return end subroutine genrand_int32_7d ! generates a random number on [0,0x7fffffff]-interval subroutine genrand_int31_0d ( y ) intrinsic :: ishft integer ( kind = wi ), intent ( out ) :: y call genrand_int32_0d ( y ) y = ishft ( y , - 1 ) return end subroutine genrand_int31_0d subroutine genrand_int31_1d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 1 ), 1 call genrand_int31_0d ( y ( i ) ) end do return end subroutine genrand_int31_1d subroutine genrand_int31_2d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 2 ), 1 call genrand_int31_1d ( y (:, i ) ) end do return end subroutine genrand_int31_2d subroutine genrand_int31_3d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 3 ), 1 call genrand_int31_2d ( y (:,:, i ) ) end do return end subroutine genrand_int31_3d subroutine genrand_int31_4d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:,:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 4 ), 1 call genrand_int31_3d ( y (:,:,:, i ) ) end do return end subroutine genrand_int31_4d subroutine genrand_int31_5d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:,:,:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 5 ), 1 call genrand_int31_4d ( y (:,:,:,:, i ) ) end do return end subroutine genrand_int31_5d subroutine genrand_int31_6d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:,:,:,:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 6 ), 1 call genrand_int31_5d ( y (:,:,:,:,:, i ) ) end do return end subroutine genrand_int31_6d subroutine genrand_int31_7d ( y ) intrinsic :: size integer ( kind = wi ), dimension (:,:,:,:,:,:,:), intent ( out ) :: y integer ( kind = wi ) :: i do i = 1 , size ( y , 7 ), 1 call genrand_int31_6d ( y (:,:,:,:,:,:, i ) ) end do return end subroutine genrand_int31_7d ! generates a random number on [0,1]-real-interval subroutine genrand_real1_0d ( r ) intrinsic :: real real ( kind = wr ), intent ( out ) :: r integer ( kind = wi ) :: a call genrand_int32_0d ( a ) r = real ( a , kind = wr ) * pi232_1 + p231d232_1 ! divided by 2&#94;32-1 return end subroutine genrand_real1_0d subroutine genrand_real1_1d ( r ) intrinsic :: size real ( kind = wr ), dimension (:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 1 ), 1 call genrand_real1_0d ( r ( i ) ) end do return end subroutine genrand_real1_1d subroutine genrand_real1_2d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 2 ), 1 call genrand_real1_1d ( r (:, i ) ) end do return end subroutine genrand_real1_2d subroutine genrand_real1_3d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 3 ), 1 call genrand_real1_2d ( r (:,:, i ) ) end do return end subroutine genrand_real1_3d subroutine genrand_real1_4d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 4 ), 1 call genrand_real1_3d ( r (:,:,:, i ) ) end do return end subroutine genrand_real1_4d subroutine genrand_real1_5d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 5 ), 1 call genrand_real1_4d ( r (:,:,:,:, i ) ) end do return end subroutine genrand_real1_5d subroutine genrand_real1_6d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 6 ), 1 call genrand_real1_5d ( r (:,:,:,:,:, i ) ) end do return end subroutine genrand_real1_6d subroutine genrand_real1_7d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 7 ), 1 call genrand_real1_6d ( r (:,:,:,:,:,:, i ) ) end do return end subroutine genrand_real1_7d ! generates a random number on [0,1)-real-interval subroutine genrand_real2_0d ( r ) intrinsic :: real real ( kind = wr ), intent ( out ) :: r integer ( kind = wi ) :: a call genrand_int32_0d ( a ) r = real ( a , kind = wr ) * pi232 + 0.5_wr ! divided by 2&#94;32 return end subroutine genrand_real2_0d subroutine genrand_real2_1d ( r ) intrinsic :: size real ( kind = wr ), dimension (:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 1 ), 1 call genrand_real2_0d ( r ( i ) ) end do return end subroutine genrand_real2_1d subroutine genrand_real2_2d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 2 ), 1 call genrand_real2_1d ( r (:, i ) ) end do return end subroutine genrand_real2_2d subroutine genrand_real2_3d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 3 ), 1 call genrand_real2_2d ( r (:,:, i ) ) end do return end subroutine genrand_real2_3d subroutine genrand_real2_4d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 4 ), 1 call genrand_real2_3d ( r (:,:,:, i ) ) end do return end subroutine genrand_real2_4d subroutine genrand_real2_5d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 5 ), 1 call genrand_real2_4d ( r (:,:,:,:, i ) ) end do return end subroutine genrand_real2_5d subroutine genrand_real2_6d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 6 ), 1 call genrand_real2_5d ( r (:,:,:,:,:, i ) ) end do return end subroutine genrand_real2_6d subroutine genrand_real2_7d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 7 ), 1 call genrand_real2_6d ( r (:,:,:,:,:,:, i ) ) end do return end subroutine genrand_real2_7d ! generates a random number on (0,1)-real-interval subroutine genrand_real3_0d ( r ) intrinsic :: real real ( kind = wr ), intent ( out ) :: r integer ( kind = wi ) :: a call genrand_int32_0d ( a ) r = real ( a , kind = wr ) * pi232 + p231_5d232 ! divided by 2&#94;32 return end subroutine genrand_real3_0d subroutine genrand_real3_1d ( r ) intrinsic :: size real ( kind = wr ), dimension (:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 1 ), 1 call genrand_real3_0d ( r ( i ) ) end do return end subroutine genrand_real3_1d subroutine genrand_real3_2d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 2 ), 1 call genrand_real3_1d ( r (:, i ) ) end do return end subroutine genrand_real3_2d subroutine genrand_real3_3d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 3 ), 1 call genrand_real3_2d ( r (:,:, i ) ) end do return end subroutine genrand_real3_3d subroutine genrand_real3_4d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 4 ), 1 call genrand_real3_3d ( r (:,:,:, i ) ) end do return end subroutine genrand_real3_4d subroutine genrand_real3_5d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 5 ), 1 call genrand_real3_4d ( r (:,:,:,:, i ) ) end do return end subroutine genrand_real3_5d subroutine genrand_real3_6d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 6 ), 1 call genrand_real3_5d ( r (:,:,:,:,:, i ) ) end do return end subroutine genrand_real3_6d subroutine genrand_real3_7d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 7 ), 1 call genrand_real3_6d ( r (:,:,:,:,:,:, i ) ) end do return end subroutine genrand_real3_7d ! generates a random number on [0,1) with 53-bit resolution subroutine genrand_res53_0d ( r ) intrinsic :: ishft , real real ( kind = wr ), intent ( out ) :: r integer ( kind = wi ) :: a , b call genrand_int32_0d ( a ) call genrand_int32_0d ( b ) a = ishft ( a , - 5 ) b = ishft ( b , - 6 ) r = real ( a , kind = wr ) * pi227 + real ( b , kind = wr ) * pi253 return end subroutine genrand_res53_0d subroutine genrand_res53_1d ( r ) intrinsic :: size real ( kind = wr ), dimension (:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 1 ), 1 call genrand_res53_0d ( r ( i ) ) end do return end subroutine genrand_res53_1d subroutine genrand_res53_2d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 2 ), 1 call genrand_res53_1d ( r (:, i ) ) end do return end subroutine genrand_res53_2d subroutine genrand_res53_3d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 3 ), 1 call genrand_res53_2d ( r (:,:, i ) ) end do return end subroutine genrand_res53_3d subroutine genrand_res53_4d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 4 ), 1 call genrand_res53_3d ( r (:,:,:, i ) ) end do return end subroutine genrand_res53_4d subroutine genrand_res53_5d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 5 ), 1 call genrand_res53_4d ( r (:,:,:,:, i ) ) end do return end subroutine genrand_res53_5d subroutine genrand_res53_6d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 6 ), 1 call genrand_res53_5d ( r (:,:,:,:,:, i ) ) end do return end subroutine genrand_res53_6d subroutine genrand_res53_7d ( r ) intrinsic :: size real ( kind = wr ), dimension (:,:,:,:,:,:,:), intent ( out ) :: r integer ( kind = wi ) :: i do i = 1 , size ( r , 7 ), 1 call genrand_res53_6d ( r (:,:,:,:,:,:, i ) ) end do return end subroutine genrand_res53_7d ! These real versions are due to Isaku Wada, 2002/01/09 added ! Altered by Jos・Sousa genrand_real[1-3] will not return exactely ! the same values but should have the same properties and are faster end module mt95","tags":"","loc":"sourcefile/mt95.f90.html"},{"title":"polint.f90 – OFIT3D","text":"Contents Subroutines polint Source Code polint.f90 Source Code subroutine polint ( xa , ya , n , x , & ! (in) & y , dy & ! (out) & ) implicit none integer , parameter :: ikind = 4 , & & rkind = 8 !Arguments integer ( kind = ikind ), intent ( in ) :: n real ( kind = rkind ), intent ( in ) :: x , & & xa ( n ), & & ya ( n ) real ( kind = rkind ), intent ( out ) :: y , & & dy !Local variables integer ( kind = ikind ) :: i , & & m , & & ns real ( kind = rkind ) :: den , & & dif , & & dift , & & ho , & & hp , & & w , & & c ( n ), & & d ( n ) ns = 1 dif = abs ( x - xa ( 1 ) ) loop100 : do i = 1 , n dift = abs ( x - xa ( i ) ) if ( dift < dif ) then ns = i dif = dift endif c ( i ) = ya ( i ) d ( i ) = ya ( i ) end do loop100 y = ya ( ns ) ns = ns - 1 loop200 : do m = 1 , n - 1 loop210 : do i = 1 , n - m ho = xa ( i ) - x hp = xa ( i + m ) - x w = c ( i + 1 ) - d ( i ) den = ho - hp if ( den == 0.0_rkind ) stop 'failure in polint' den = w / den d ( i ) = hp * den c ( i ) = ho * den end do loop210 if ( 2 * ns < n - m ) then dy = c ( ns + 1 ) else dy = d ( ns ) ns = ns - 1 end if y = y + dy end do loop200 return end subroutine polint","tags":"","loc":"sourcefile/polint.f90.html"},{"title":"fun_mesor.f90 – OFIT3D","text":"Contents Subroutines fun_mesor Source Code fun_mesor.f90 Source Code SUBROUTINE fun_mesor ( t , yy , & !(in) & yp & !(out) & ) USE kind_spec USE param1 , ONLY : qom_a USE cylindrical_coord_mod , ONLY : mgval1 IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: t , & & yy ( 6 ) REAL ( RP ), INTENT ( OUT ) :: yp ( 6 ) !Local variable REAL ( RP ) :: vr , & & vp , & & vz , & & br , & & bp , & & bz , & & bb , & & r , & & phi , & & z vr = yy ( 1 ) vp = yy ( 2 ) vz = yy ( 3 ) r = yy ( 4 ) phi = yy ( 5 ) z = yy ( 6 ) CALL mgval1 ( r , phi , z , br , bp , bz , bb ) IF ( bb == 0.0_RP ) THEN yp ( 1 : 6 ) = 0.0_RP RETURN END IF yp ( 1 ) = qom_a * ( r * vp * bz - vz * bp ) + r * vp ** 2 yp ( 2 ) = qom_a * ( vz * br - vr * bz ) / r - 2 * vr * vp / r yp ( 3 ) = qom_a * ( vr * bp - r * vp * br ) yp ( 4 ) = vr yp ( 5 ) = vp yp ( 6 ) = vz RETURN END SUBROUTINE fun_mesor","tags":"","loc":"sourcefile/fun_mesor.f90.html"},{"title":"readin.f90 – OFIT3D","text":"Contents Subroutines readin Source Code readin.f90 Source Code !=READin.f90 ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! SUBROUTINE readin USE kind_spec USE param2 , ONLY : ladaptive , & & lcoll , & & lmonitor , & & lpunc , & & lvessel , & & ldivertor , & & lfile , & & nparticles , & & interval , & & wk_in , & & wp_in , & & dt , & & quit_t , & & stalam , & & rstart , & & zstart , & & pstart , & & pstart1 , & & mode , & & collision_type , & & anomalous_type , & & run_mode , & & multi_mode USE collision_parameter_mod , ONLY : collision_step , & & n_e , & & t_bg , & & rho_col , & & atomic_mass , & & nu_d USE vessel_mod , ONLY : vessel_model , & & lvessel_vtk USE divertor_mod , ONLY : ldivertor_vtk USE cylindrical_coord_mod , ONLY : mag_form , & & flx_form , & & version , & & lflux , & & cj , & & cturn , & & cfact , & & badjust , & & bnorm , & & igrid , & & mbound , & & kstep , & & nlinp_coil_dat USE info_mod , ONLY : read_time USE mpi IMPLICIT NONE REAL ( RP ) :: t1 , & & t2 !for MPI INTEGER :: ierr NAMELIST / nlinp1 / mode , & & run_mode , & & multi_mode , & & ladaptive , & & lvessel , & & ldivertor , & & lcoll , & & lmonitor , & & lpunc , & & lfile , & & nparticles , & & interval , & & wk_in , & & wp_in , & & dt , & & quit_t , & & stalam , & & rstart , & & zstart , & & pstart , & & pstart1 , & & vessel_model , & & lvessel_vtk , & & ldivertor_vtk NAMELIST / nlinp2 / collision_type , & & anomalous_type , & & collision_step , & & n_e , & & t_bg , & & rho_col , & & atomic_mass , & & nu_d t1 = MPI_WTIME () READ ( 10 , nlinp1 ) !WRITE(6, nlinp1) IF ( lcoll ) THEN READ ( 10 , nlinp2 ) !WRITE(6, nlinp2) END IF READ ( 10 , nlinp_coil_dat ) IF ( lfile ) CALL file_open !for fail safe lvessel = . true . !  lflux     =  .true. !default setting is the HINT for the vacuum !  mag_form  =  'vac' !  flx_form  =  'flx' t2 = MPI_WTIME () read_time = t2 - t1 CALL MPI_BARRIER ( MPI_COMM_WORLD , ierr ) END SUBROUTINE readin","tags":"","loc":"sourcefile/readin.f90.html"},{"title":"rkg6.f90 – OFIT3D","text":"Contents Subroutines rkg6 Source Code rkg6.f90 Source Code SUBROUTINE rkg6 ( x0 , h , n , fun , & !(in) & y0 , & !(inout) & iout & !(out) & ) ! !    This subroutine is written by Y. Suzuki !        at Graduate School of Energy Science (Kyoto Univ) !         2002/12/28 ! !    Based program is wrtten by K. Hamamatsu !        at Faculty of Science (Hiroshima Univ.) !          1980/12/18 ! !  Runge-Kutta-Huta Formulas  ( Sixth order 8-stage ) ! !  <<< Reference >>> !  \" Improved Sixth-order Runge-kutta formulas and Approximate !    Continuous Solution of Ordinary Differential Equation \" !  by D. Sarafyan:  J. Math. Anal. Appl. 40, 436-455 (1972) ! USE kind_spec IMPLICIT NONE INTEGER , INTENT ( IN ) :: n INTEGER , INTENT ( OUT ) :: iout REAL ( RP ), INTENT ( IN ) :: x0 , & & h REAL ( RP ), INTENT ( INOUT ) :: y0 ( n ) REAL ( RP ) :: x1 , & & c01 , & & c02 , & & c03 , & & c04 , & & c05 , & & c06 , & & c07 , & & c08 , & & c09 , & & c10 , & & c11 , & & c12 , & & c13 , & & c14 , & & c15 , & & c16 , & & c17 , & & c18 , & & c19 , & & c20 , & & c21 , & & c22 , & & c23 , & & c24 , & & c25 , & & c26 , & & c27 REAL ( RP ) :: f ( n , 9 ) EXTERNAL :: fun c01 = h / 9.0_RP c02 = h * 0.4166666666666667e-01_RP c03 = h * 0.125_RP c04 = h / 6.0_RP c05 = h * 0.5_RP c06 = h * 0.6666666666666667_RP c07 = h / 3.0_RP c08 = h * 0.375_RP c09 = h * 0.1333333333333333e+01_RP c10 = h * 0.3333333333333333e+01_RP c11 = h * 0.7e+01_RP c12 = h * 0.9666666666666667e+01_RP c13 = h * 0.1533333333333333e+02_RP c14 = h * 0.6111111111111111_RP c15 = h * 0.1166666666666667e+01_RP c16 = h * 0.1375e+01_RP c17 = h * 0.8333333333333333_RP c18 = h * 0.4390243902439024_RP c19 = h * 0.8780487804878049_RP c20 = h * 0.1304878048780488e+01_RP c21 = h * 0.2097560975609756e+01_RP c22 = h * 0.2963414634146341e+01_RP c23 = h * 0.4317073170731707e+01_RP c24 = h * 0.3214285714285714e-01_RP c25 = h * 0.4880952380952381e-01_RP c26 = h * 0.2571428571428571_RP c27 = h * 0.3238095238095238_RP f (:,:) = 0.0_RP f (:, 1 ) = y0 (:) ! !... 1-stage ! x1 = x0 CALL fun ( x1 , f (:, 1 ), f (:, 3 ), iout ) f (:, 2 ) = c01 * f (:, 3 ) & & + f (:, 1 ) ! !... 2-stage ! x1 = x0 + c01 CALL fun ( x1 , f (:, 2 ), f (:, 4 ), iout ) f (:, 2 ) = c02 * f (:, 3 ) & & + c03 * f (:, 4 ) & & + f (:, 1 ) ! !... 3-stage ! x1 = x0 + c04 CALL fun ( x1 , f (:, 2 ), f (:, 5 ), iout ) f (:, 2 ) = c04 * f (:, 3 ) & & - c05 * f (:, 4 ) & & + c06 * f (:, 5 ) & & + f (:, 1 ) ! !... 4-stage ! x1 = x0 + c07 CALL fun ( x1 , f (:, 2 ), f (:, 6 ), iout ) f (:, 2 ) = c03 * f (:, 3 ) & & + c08 * f (:, 6 ) & & + f (:, 1 ) ! !... 5-stage ! x1 = x0 + c05 CALL fun ( x1 , f (:, 2 ), f (:, 7 ), iout ) f (:, 2 ) = - c09 * f (:, 3 ) & & + c10 * f (:, 7 ) & & - c11 * f (:, 4 ) & & - c12 * f (:, 6 ) & & + c13 * f (:, 5 ) & & + f (:, 1 ) ! !... 6-stage ! x1 = x0 + c06 CALL fun ( x1 , f (:, 2 ), f (:, 8 ), iout ) f (:, 2 ) = - c01 * f (:, 3 ) & & + c03 * f (:, 8 ) & & + c14 * f (:, 7 ) & & - c15 * f (:, 5 ) & & + c16 * f (:, 4 ) & & + f (:, 1 ) ! !... 7-stage ! x1 = x0 + c17 CALL fun ( x1 , f (:, 2 ), f (:, 9 ), iout ) f (:, 2 ) = - c18 * f (:, 8 ) & & + c19 * f (:, 9 ) & & + c20 * f (:, 3 ) & & - c21 * f (:, 7 ) & & - c22 * f (:, 4 ) & & + c23 * f (:, 6 ) & & + f (:, 1 ) ! !... 8-stage ! x1 = x0 + h CALL fun ( x1 , f (:, 2 ), f (:, 4 ), iout ) f (:, 1 ) = c24 * ( f (:, 6 ) + f (:, 8 )) & & + c25 * ( f (:, 3 ) + f (:, 4 )) & & + c26 * ( f (:, 5 ) + f (:, 9 )) & & + c27 * f (:, 7 ) & & + f (:, 1 ) y0 (:) = f (:, 1 ) RETURN END SUBROUTINE rkg6","tags":"","loc":"sourcefile/rkg6.f90.html"},{"title":"single.f90 – OFIT3D","text":"Contents Subroutines single_particles Source Code single.f90 Source Code !=driver.f90 ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! SUBROUTINE single_particles USE kind_spec USE param1 , ONLY : pi USE param2 , ONLY : ladaptive , & & lcoll , & & lano , & & lmonitor , & & lpunc , & & lvessel , & & ldivertor , & & lfile , & & mode , & & rstart , & & zstart , & & pstart , & & pstart1 , & & wk_in , & & stalam , & & dt , & & quit_t USE mpi_param_mod , ONLY : myrank IMPLICIT NONE INTEGER :: nend , & & loss , & & trap , ii , i REAL ( RP ) :: loss_time , & & x , & & y , temp CHARACTER ( LEN = 100 ) :: fmt IF ( myrank == 0 ) THEN PRINT * PRINT * , '  RUN CONTROL PARAMETERS ' PRINT * PRINT * , '  ladaptive   lcoll     lano' PRINT * , '-------------------------------' fmt = '(3X, L5, 5X, L5, 5X, L5)' PRINT fmt , ladaptive , lcoll , lano PRINT * , '   lvessel  ldivertor' PRINT * , '------------------------' PRINT fmt , lvessel , ldivertor PRINT * , '   lmonitor   lpunc     lfile' PRINT * , '--------------------------------' PRINT fmt , lmonitor , lpunc , lfile PRINT * PRINT * PRINT * , '  RUN_MODE: SINGLE_PARTICLE' PRINT * PRINT * , '   mode' PRINT * , '-----------' fmt = '(A10)' PRINT fmt , TRIM ( mode ) END IF DO i = 1 , 231 READ ( 60 , * ) ii , rstart , zstart , pstart , wk_in , stalam , temp pstart = pstart1 * pi / 18 0.0_RP nend = quit_t / dt nend = quit_t / ABS ( dt ) IF ( myrank == 0 ) THEN fmt = '(A18, I12, A1, I12)' PRINT * PRINT * , '    R[m]      phi[deg]      Z[m]       lamda      E_K[keV]' PRINT * , '-------------------------------------------------------------' fmt = '(5ES12.4)' PRINT fmt , rstart , pstart * 18 0.0_RP / pi , zstart , COS ( stalam * pi ), 1.0e-03_RP * wk_in PRINT * PRINT * , '    dt[s]     t_end[s]       nstep' PRINT * , '-------------------------------------' fmt = '(2ES12.4, I12)' PRINT fmt , dt , quit_t , nend END IF #ifdef GC !------------------------------------------------------------------------------------ CALL gcr ( rstart , pstart , zstart , wk_in , stalam , dt , nend , loss , loss_time , trap ) !------------------------------------------------------------------------------------ #elif FULL !------------------------------------------------------------------------------------ CALL mesor ( rstart , pstart , zstart , wk_in , stalam , dt , nend , loss , loss_time , trap ) !------------------------------------------------------------------------------------ #endif IF ( myrank == 0 ) THEN PRINT * PRINT * , '  t_loss[s]' PRINT * , '-----------------------------------' x = COS ( stalam * pi ) y = SIN ( stalam * pi ) fmt = '(ES12.4, A22)' #ifdef DIGOUT1 IF (( loss == 0 ) . AND . ( trap == 0 )) THEN PRINT fmt , loss_time , \"    'untrapped unloss'\" WRITE ( 88 , '(13(ES12.4, A), I3, A)' ) rstart , ',' , pstart , ',' , zstart , ',' , stalam , ',' , x , ',' , y , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , loss_time , ',' , 1 , ',' WRITE ( 89 , '(8(ES12.4, A))' ) rstart , ',' , stalam , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' ELSE IF (( loss == 0 ) . AND . ( trap == 1 )) THEN PRINT fmt , loss_time , \"    'trapped unloss'\" WRITE ( 88 , '(13(ES12.4, A), I3, A)' ) rstart , ',' , pstart , ',' , zstart , ',' , stalam , ',' , 0.0 , ',' , 0.0 , ',' , x , ',' , y , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , loss_time , ',' , 2 , ',' WRITE ( 89 , '(8(ES12.4, A))' ) 0.0 , ',' , 0.0 , ',' , rstart , ',' , stalam , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' ELSE IF (( loss == 1 ) . and . ( trap == 0 )) THEN PRINT fmt , loss_time , \"    'untrapped loss'\" WRITE ( 88 , '(13(ES12.4, A), I3, A)' ) rstart , ',' , pstart , ',' , zstart , ',' , stalam , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , x , ',' , y , ',' , 0.0 , ',' , 0.0 , ',' , loss_time , ',' , 3 , ',' WRITE ( 89 , '(8(ES12.4, A))' ) 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , rstart , ',' , stalam , ',' , 0.0 , ',' , 0.0 , ',' ELSE IF (( loss == 1 ) . and . ( trap == 1 )) THEN PRINT fmt , loss_time , \"    'trapped loss'\" WRITE ( 88 , '(13(ES12.4, A), I3, A)' ) rstart , ',' , pstart , ',' , zstart , ',' , stalam , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , x , ',' , y , ',' , loss_time , ',' , 4 , ',' WRITE ( 89 , '(8(ES12.4, A))' ) 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , rstart , ',' , stalam , ',' END IF #endif PRINT * PRINT * END IF END DO END SUBROUTINE single_particles","tags":"","loc":"sourcefile/single.f90.html"},{"title":"module.f90 – OFIT3D","text":"Contents Modules kind_spec param1 param2 inv_val_mod collision_parameter_mod wall_mod file_name_mod info_mod Source Code module.f90 Source Code !=module.f90 ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! MODULE kind_spec INTEGER , PARAMETER :: RP = SELECTED_REAL_KIND ( 15 ) END MODULE kind_spec MODULE param1 USE kind_spec IMPLICIT NONE REAL ( RP ), PARAMETER :: ee = 1.602176565E-19_RP , & ! elementary electric charge & mi = 1.672621777E-27_RP , & ! mass of proton & mn = 1.674927351E-27_RP , & ! mass of nuetron & me = 9.10938291E-31_RP , & ! mass of electron & epsi0 = 8.85418782E-12_RP , & ! permittivity & pi = 3.141592653589793238462643383279502884197_RP , & ! pi & pi2 = pi + pi , & ! 2 pi & pi4 = pi2 + pi2 ! 4 pi REAL ( RP ) :: qa , & ! charge of test particle & qb , & ! charge of background & ma , & ! mass of test particle & mb , & ! mass of background & qom_a , & ! ratio of charge and mass for test particle & qom_b ! ratio of charge and mass for background END MODULE param1 MODULE param2 USE kind_spec IMPLICIT NONE LOGICAL :: ladaptive = . false ., & & lcoll = . false ., & & lano = . false ., & & lmonitor = . false ., & & lpunc = . false ., & & lvessel = . true ., & & ldivertor = . false ., & & lfile = . false . INTEGER :: nparticles = 100 , & & interval = 1 REAL ( RP ) :: wk_in = 1.0E+03_RP , & ! enegy [eV] & wp_in = 0.0E+00_RP , & ! potential [V] & dt = 1.0E-08_RP , & ! time step for DOE [s] & quit_t = 1.0E-03_RP , & & stalam = 0.0_RP , & ! normalized pitch angle & rstart = 0.0_RP , & ! strating point along R [m] & pstart = 0.0_RP , & ! strating point along phi [deg] & pstart1 = 0.0_RP , & ! strating point along phi & zstart = 0.0_RP , & ! strating point along Z [m] & slimit = 0.98_RP CHARACTER ( LEN = 20 ) :: mode = 'proton' , & & collision_type = 'slow' , & & anomalous_type = 'classical' , & & run_mode = 'single' , & & multi_mode = '' END MODULE param2 MODULE inv_val_mod USE kind_spec IMPLICIT NONE REAL ( RP ) :: mu END MODULE inv_val_mod MODULE collision_parameter_mod USE kind_spec IMPLICIT NONE INTEGER :: collision_step ( 2 ) = 1 REAL ( RP ) :: n_e = 1.0E+19_RP , & & t_bg = 1.0E+03_RP , & & rho_col = 1.2E-03_RP , & & d_ano , & & atomic_mass , & & ln_lamda , & & v_th_a , & & v_th_b , & & tau , & & nu_ab , & & nu_d , & & nu_dxtau , & & nu_e , & & nu_extau END MODULE collision_parameter_mod MODULE wall_mod USE kind_spec IMPLICIT NONE REAL ( RP ) :: rwall , & & zwall , & & awall END MODULE wall_mod MODULE file_name_mod USE kind_spec IMPLICIT NONE CHARACTER ( LEN = 200 ) :: mag_file , & & flx_file , & & gcr_file , & & punc1_file , & & punc2_file NAMELIST / fopen / mag_file , & & flx_file , & & gcr_file , & & punc1_file , & & punc2_file END MODULE file_name_mod MODULE info_mod USE kind_spec IMPLICIT NONE REAL ( RP ) :: read_time = 0.0_RP , & & pre_time = 0.0_RP , & & drive_time = 0.0_RP , & & tot_time = 0.0_RP CHARACTER ( LEN = 10 ) :: date0 = '' , & & time0 = '' , & & zone0 = '' CHARACTER ( LEN = 5 ) :: ver_info = '' END MODULE info_mod","tags":"","loc":"sourcefile/module.f90.html"},{"title":"cylindrical_coord_mod.f90 – OFIT3D","text":"Contents Modules cylindrical_coord_mod Source Code cylindrical_coord_mod.f90 Source Code !> @file cylindrical_coord_mod.f90 !------------------------------------------------------------------------------ ! ! MODULE: cylindrical_coord_mod ! !> @author !> Yasuhiro Suzuki, National Institute for Fusion Science ! ! DESCRIPTION: !> @brief !> subroutines for the interpolation and derivation of the magnetic field !! and normalized flux distribution ! ! REVISION HISTORY: !> @date 19 Apr 2020 ! !> @version Initial Version ! !------------------------------------------------------------------------------ MODULE cylindrical_coord_mod USE kind_spec USE param1 , ONLY : pi2 USE spline_mod , ONLY : l2d , & & l3d , & & f2d , & & f3d , & & nx2d , & & ny2d , & & nx3d , & & ny3d , & & nz3d , & & splin2 , & & spl2df , & & splin3 , & & spl3df , & & spl3dd USE hdf5 USE netcdf #ifdef MPI USE mpi_param_mod , ONLY : myrank USE mpi #endif IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !> FILE_FORMAT sets the file format ! !> @li 1. bin:    Fortran binary !> @li 2. netcdf: netCDF (optional) !> @li 3. hdf5:   HDF5 @em(not implemnted yet) !---------------------------------------------------------------------------- CHARACTER ( LEN = 6 ) :: file_format = 'bin' !---------------------------------------------------------------------------- !> MAG_FILE sets the file name of the magnetic field !---------------------------------------------------------------------------- CHARACTER ( LEN = 200 ) :: mag_file !---------------------------------------------------------------------------- !> MAG_FORM prescribes the table format of the magnetic field. ! !> @li 1. mgrid:   file format used in MAKEGRID !> @li 2. mgo:     file format used in KMAG/KMAG2 !> @li 3. mag:     file format for the equilibrium field used in HINT !> @li 4. vac:     file format for the vacuum field used in HINT !> @li 5. movie:   file format used in the MIPS code !> @li 6. mips_eq: file format for the equilibrium field used in MIPS !> @li 7. ofmc:    file format for the equilibrium field used in OFMC !---------------------------------------------------------------------------- CHARACTER ( LEN = 20 ) :: mag_form = '' !---------------------------------------------------------------------------- !> VERSION prescribes the version for the old legacy format. ! !> @li 1. ver2:  legacy HINT2 format !---------------------------------------------------------------------------- CHARACTER ( LEN = 20 ) :: version = '' !---------------------------------------------------------------------------- !> LFLUX switches on/off to read the flux distribution. !---------------------------------------------------------------------------- LOGICAL :: lflux !---------------------------------------------------------------------------- !> FLX_FILE sets the file name of the flux distribution !---------------------------------------------------------------------------- CHARACTER ( LEN = 200 ) :: flx_file !---------------------------------------------------------------------------- !> FLX_FORM prescribes the table format of the flux distribution ! !> @li 1. xss:    file format used in SMAP !> @li 2. flx:    file format used in HINT !> @li 3. eqdsk:  file format used in EFIT !> @li 4. eqdata: file format used in TOPICS !---------------------------------------------------------------------------- CHARACTER ( LEN = 20 ) :: flx_form = 'xss' !---------------------------------------------------------------------------- !> LVACOUT switches on/off to output the magnetic field !---------------------------------------------------------------------------- LOGICAL :: lvacout !---------------------------------------------------------------------------- !> LSYMMETRY enforces the stellarator symmetry !---------------------------------------------------------------------------- LOGICAL :: lsymmetry ! INTEGER :: mtor , & !< toroidal field period & nr0b , & !< grid number along R-direction & nt0b , & !< grid number along phi-direction & nz0b , & !< grid number along Z-direction ! & ipfcoil ( 500 ) = 0 , & !< index of PF coil to specify the magnetic axis !                                        !  CAUTION! array size is 500 (max) ! & kstep = 99999 , & !< time steps of MIPS & igrid ( 4 ) !< grid number of MIPS REAL ( RP ) :: bmax = 5.0_RP , & !< torelance of maximum B field & sedge = 0.98_RP , & !< the edge toroidal flux (default) & pi2m , & !< one toroidal field period [rad] & rmaxb , & !< R_max of computational domain [m] & rminb , & !< R_min of computational domain [m] & zmaxb , & !< Z_max of computational domain [m] & zminb , & !< Z_min of the computational domain [m] & delrb , & !< Delta_R [m] & delzb , & !< Delta_Z [m] & badjust = 1.0_RP , & !< normalization factor of magnetic field & bnorm = 3.0_RP , & !< normalization factor of magnetic field & cj ( 500 ) = 0.0_RP , & !< work array to store coil current in each coils [A] !                                        !  CAUTION! array size is 500 (max) & extcur ( 500 ) = 0.0_RP , & !< work array to store coil current in each coils [A] !                                        !  #NOTE# compatibility for MAKEGRID of VMEC !                                        !  CAUTION! array size is 500 (max) & cturn ( 500 ) = 1.0_RP , & !< work array to store coil current in each coils [A] !                                        !  CAUTION! array size is 500 (max) & cfact ( 500 ) = 1.0_RP , & !< work array to store coil current in each coils [A] !                                        !  CAUTION! array size is 500 (max) & cpfcoil ( 500 ) = 1.0_RP , & !< factors of PF coils to fix the magnetic axis & mbound ( 4 ) = 0.0_RP !< 1D array to fix the boundary in MIPS !                                        !  mbound(1) = Rmin [m] !                                        !  mbound(2) = Rmax [m] !                                        !  mbound(3) = Zmin [m] !                                        !  mbound(4) = Zmax [m] REAL ( RP ), ALLOCATABLE :: rg (:), & !< 1D array of R [m] & zg (:) !< 1D array of Z [m] NAMELIST / nlinp_coil_dat / file_format , & & mag_form , & & mag_file , & & flx_form , & & flx_file , & & version , & & lflux , & & lsymmetry , & & lvacout , & & cj , & & extcur , & & cturn , & & cfact , & & bmax , & & sedge , & & badjust , & & ipfcoil , & & cpfcoil , & & bnorm , & & igrid , & & mbound , & & kstep PUBLIC :: file_format , & & mag_file , & & flx_file , & & mag_form , & & flx_form , & & version , & & lflux , & & lsymmetry , & & lvacout , & & cj , & & extcur , & & cturn , & & cfact , & & bmax , & & sedge , & & badjust , & & ipfcoil , & & cpfcoil , & & bnorm , & & igrid , & & mbound , & & kstep , & & pi2m , & & mtor , & & nr0b , & & nt0b , & & nz0b , & & rminb , & & rmaxb , & & zminb , & & zmaxb , & & delrb , & & delzb , & & rg , & & zg , & & free_mem_field , & & magset , & & mgval1 , & & mgval2 , & & mgval3 , & & nlinp_coil_dat CONTAINS SUBROUTINE read_field IMPLICIT NONE l3d = 4 IF ( lflux ) THEN l3d = 5 END IF SELECT CASE ( TRIM ( mag_form )) CASE ( 'mgrid' , \"MGRID\" ) CALL read_mgrid CASE ( 'mgo' , \"MGO\" ) CALL read_mgo CASE ( 'mag' , \"MAG\" ) CALL read_hint_eq CASE ( 'vac' , \"VAC\" ) CALL read_hint_vac CASE ( 'mips' , \"MIPS\" ) CALL read_mips CASE ( 'mips_eq' , \"MIPS_EQ\" ) CALL read_mips_eq CASE ( 'ofmc' , \"OFMC\" ) CALL read_ofmc CASE DEFAULT CALL read_mgrid END SELECT IF ( lflux ) THEN SELECT CASE ( TRIM ( flx_form )) CASE ( 'xss' ) CALL read_xss CASE ( 'flx' ) CALL read_flx CASE ( 'eqdsk' ) CALL read_eqdsk CASE ( 'eqdata' ) CALL read_eqdata CASE DEFAULT CALL read_xss END SELECT END IF END SUBROUTINE read_field SUBROUTINE read_mgrid IMPLICIT NONE INTEGER , SAVE :: isave = 1 INTEGER :: nextcur , & & i , & & j , & & k , & & n REAL ( RP ), ALLOCATABLE :: raw_coil_current (:), & & br (:,:,:), & & bp (:,:,:), & & bz (:,:,:) CHARACTER ( LEN = 30 ), ALLOCATABLE :: curlabel (:) CHARACTER ( LEN = 100 ) :: fmt LOGICAL :: lstyle2000 !For netCDF INTEGER :: ncid , & & ir_varid , & & jz_varid , & & kp_varid , & & mtor_varid , & & rmin_varid , & & rmax_varid , & & zmin_varid , & & zmax_varid , & & nextcur_varid , & & coilgrp_varid , & & coilcur_varid , & & br_varid , & & bp_varid , & & bz_varid , & & x_dimid , & & y_dimid , & & z_dimid , & & dim3ids ( 3 ) REAL ( RP ), ALLOCATABLE :: w3d (:,:,:) CHARACTER ( LEN = 100 ) :: vname #ifdef MPI !For MPI INTEGER :: icode , & & ierr #endif SELECT CASE ( TRIM ( file_format )) CASE ( 'netcdf' , \"NETCDF\" ) IF ( LEN ( TRIM ( mag_file )) == 0 ) mag_file = 'mgrid.nc' CALL check ( NF90_OPEN ( TRIM ( mag_file ), NF90_NOWRITE , ncid )) CALL check ( NF90_INQ_VARID ( ncid , 'ir' , ir_varid )) CALL check ( NF90_INQ_VARID ( ncid , 'jz' , jz_varid )) CALL check ( NF90_INQ_VARID ( ncid , 'kp' , kp_varid )) CALL check ( NF90_INQ_VARID ( ncid , 'nfp' , mtor_varid )) CALL check ( NF90_INQ_VARID ( ncid , 'nextcur' , nextcur_varid )) CALL check ( NF90_GET_VAR ( ncid , ir_varid , nr0b )) CALL check ( NF90_GET_VAR ( ncid , jz_varid , nz0b )) CALL check ( NF90_GET_VAR ( ncid , kp_varid , nt0b )) CALL check ( NF90_GET_VAR ( ncid , mtor_varid , mtor )) CALL check ( NF90_GET_VAR ( ncid , nextcur_varid , nextcur )) CALL check ( NF90_INQ_VARID ( ncid , 'rmin' , rmin_varid )) CALL check ( NF90_INQ_VARID ( ncid , 'rmax' , rmax_varid )) CALL check ( NF90_INQ_VARID ( ncid , 'zmin' , zmin_varid )) CALL check ( NF90_INQ_VARID ( ncid , 'zmax' , zmax_varid )) CALL check ( NF90_GET_VAR ( ncid , rmin_varid , rminb )) CALL check ( NF90_GET_VAR ( ncid , rmax_varid , rmaxb )) CALL check ( NF90_GET_VAR ( ncid , zmin_varid , zminb )) CALL check ( NF90_GET_VAR ( ncid , zmax_varid , zmaxb )) CASE ( 'bin' , \"BIN\" ) REWIND 25 READ ( 25 ) nr0b , nz0b , nt0b , mtor , nextcur READ ( 25 ) rminb , zminb , rmaxb , zmaxb IF ( nextcur < 0 ) lstyle2000 = . true . nextcur = ABS ( nextcur ) END SELECT #ifdef MPI IF ( nextcur > 500 ) THEN PRINT * , ' nextcur > 500' CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) END IF #else IF ( nextcur > 500 ) STOP ' nextcur > 500' #endif ALLOCATE ( curlabel ( nextcur ), raw_coil_current ( nextcur )) IF ( isave == 1 ) THEN ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) isave = 0 END IF f3d (:,:,:,:) = 0.0_RP ALLOCATE ( br ( nr0b , nz0b , nt0b ), bp ( nr0b , nz0b , nt0b ), bz ( nr0b , nz0b , nt0b )) SELECT CASE ( TRIM ( file_format )) CASE ( 'netcdf' , \"NETCDF\" ) CALL check ( NF90_INQ_VARID ( ncid , 'coil_group' , coilgrp_varid )) CALL check ( NF90_INQ_VARID ( ncid , 'raw_coil_cur' , coilcur_varid )) CALL check ( NF90_GET_VAR ( ncid , coilgrp_varid , curlabel )) CALL check ( NF90_GET_VAR ( ncid , coilcur_varid , raw_coil_current )) CASE ( 'bin' , \"BIN\" ) READ ( 25 ) ( curlabel ( i ), i = 1 , nextcur ) END SELECT fmt = '(I7, ES17.6, I7, ES12.4)' #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading coil data' PRINT * PRINT * PRINT * , ' coil No    c_I [A/T]      trun  c_factor ' PRINT * , '--------------------------------------------' IF (( SUM ( cj (:)) == 0.0_RP ) . AND . ( SUM ( extcur (:)) /= 0.0_RP )) cj (:) = extcur (:) DO n = 1 , nextcur PRINT fmt , n , cj ( n ), INT ( cturn ( n )), cfact ( n ) END DO PRINT * #ifdef MPI END IF #endif fmt = '(A10, I3, A20, A6, ES15.7, A4)' SELECT CASE ( TRIM ( file_format )) CASE ( 'netcdf' , \"NETCDF\" ) loop010 : DO n = 1 , nextcur #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT fmt , ' coil NO: ' , n , TRIM ( curlabel ( n )), ' c_I: ' , cj ( n ) * cfact ( n ) * cturn ( n ) * badjust , ' [A]' #ifdef MPI END IF #endif WRITE ( vname , '(I3.3)' ) n vname = 'br_' // vname CALL check ( NF90_INQ_VARID ( ncid , TRIM ( vname ), br_varid )) CALL check ( NF90_GET_VAR ( ncid , br_varid , br )) WRITE ( vname , '(I3.3)' ) n vname = 'bp_' // vname CALL check ( NF90_INQ_VARID ( ncid , TRIM ( vname ), bp_varid )) CALL check ( NF90_GET_VAR ( ncid , bp_varid , bp )) WRITE ( vname , '(I3.3)' ) n vname = 'bz_' // vname CALL check ( NF90_INQ_VARID ( ncid , TRIM ( vname ), bz_varid )) CALL check ( NF90_GET_VAR ( ncid , bz_varid , bz )) f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) + cj ( n ) * cfact ( n ) * cturn ( n ) * badjust * br ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) !< B_R f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) + cj ( n ) * cfact ( n ) * cturn ( n ) * badjust * bp ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) !< B_phi f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) + cj ( n ) * cfact ( n ) * cturn ( n ) * badjust * bz ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) !< B_Z END DO loop010 CALL check ( NF90_CLOSE ( ncid )) IF ( lvacout ) THEN CALL check ( NF90_CREATE ( 'vacfile.nc' , NF90_CLOBBER , ncid )) CALL check ( NF90_DEF_VAR ( ncid , \"mtor\" , NF90_INT , mtor_varid )) CALL check ( NF90_DEF_VAR ( ncid , \"rminb\" , NF90_REAL8 , rmin_varid )) CALL check ( NF90_DEF_VAR ( ncid , \"rmaxb\" , NF90_REAL8 , rmax_varid )) CALL check ( NF90_DEF_VAR ( ncid , \"zminb\" , NF90_REAL8 , zmin_varid )) CALL check ( NF90_DEF_VAR ( ncid , \"zmaxb\" , NF90_REAL8 , zmax_varid )) CALL check ( NF90_DEF_DIM ( ncid , \"R\" , nr0b , x_dimid )) CALL check ( NF90_DEF_DIM ( ncid , \"Z\" , nz0b , y_dimid )) CALL check ( NF90_DEF_DIM ( ncid , \"phi\" , nt0b , z_dimid )) dim3ids = ( / x_dimid , y_dimid , z_dimid / ) CALL check ( NF90_DEF_VAR ( ncid , \"B_R\" , NF90_REAL8 , dim3ids , br_varid )) CALL check ( NF90_DEF_VAR ( ncid , \"B_phi\" , NF90_REAL8 , dim3ids , bp_varid )) CALL check ( NF90_DEF_VAR ( ncid , \"B_Z\" , NF90_REAL8 , dim3ids , bz_varid )) CALL check ( NF90_ENDDEF ( ncid )) CALL check ( NF90_PUT_VAR ( ncid , mtor_varid , mtor )) CALL check ( NF90_PUT_VAR ( ncid , rmin_varid , rminb )) CALL check ( NF90_PUT_VAR ( ncid , rmax_varid , rmaxb )) CALL check ( NF90_PUT_VAR ( ncid , zmin_varid , zminb )) CALL check ( NF90_PUT_VAR ( ncid , zmax_varid , zmaxb )) ALLOCATE ( w3d ( nr0b , nz0b , nt0b )) w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) = f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL check ( NF90_PUT_VAR ( ncid , br_varid , w3d )) w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) = f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL check ( NF90_PUT_VAR ( ncid , bp_varid , w3d )) w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) = f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL check ( NF90_PUT_VAR ( ncid , bz_varid , w3d )) CALL check ( NF90_CLOSE ( ncid )) DEALLOCATE ( w3d ) END IF CASE ( 'bin' , \"BIN\" ) loop020 : DO n = 1 , nextcur #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT fmt , ' coil NO: ' , n , TRIM ( curlabel ( n )), ' c_I: ' , cj ( n ) * cfact ( n ) * cturn ( n ) * badjust , ' [A]' #ifdef MPI END IF #endif IF ( lstyle2000 ) THEN READ ( 25 ) br , bp , bz ELSE READ ( 25 ) ((( br ( i , j , k ), bz ( i , j , k ), bp ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) END IF f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) + cj ( n ) * cfact ( n ) * cturn ( n ) * badjust * br ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) !< B_R f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) + cj ( n ) * cfact ( n ) * cturn ( n ) * badjust * bp ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) !< B_phi f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) + cj ( n ) * cfact ( n ) * cturn ( n ) * badjust * bz ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) !< B_Z END DO loop020 IF ( lvacout ) THEN !WRITE(35) nr0b, nz0b, nt0b, mtor !WRITE(35) rminb, zminb, rmaxb, zmaxb !WRITE(35) (((f3d(1,i,j,k), f3d(2,i,j,k), f3d(3,i,j,k), i=1,nr0b), j=1,nz0b), k=1,nt0b) WRITE ( 35 ) nr0b , nz0b , nt0b , mtor WRITE ( 35 ) rminb , zminb , rmaxb , zmaxb DO k = 1 , nt0b WRITE ( 35 ) (( f3d ( 1 , i , j , k ), f3d ( 3 , i , j , k ), f3d ( 2 , i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ) END DO END IF END SELECT DEALLOCATE ( br , bp , bz ) DEALLOCATE ( curlabel ) END SUBROUTINE read_mgrid SUBROUTINE read_mgo IMPLICIT NONE INTEGER :: i , & & j , & & k REAL ( RP ), ALLOCATABLE :: br (:,:,:), & & bp (:,:,:), & & bz (:,:,:) CHARACTER ( LEN = 100 ) :: fmt READ ( 25 ) nr0b , nz0b , nt0b , mtor READ ( 25 ) rminb , zminb , rmaxb , zmaxb ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP ALLOCATE ( br ( nr0b , nz0b , nt0b ), bp ( nr0b , nz0b , nt0b ), bz ( nr0b , nz0b , nt0b )) #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading magnetic field data as MGO format' PRINT * #ifdef MPI END IF #endif loop010 : DO k = 1 , nt0b READ ( 25 ) (( br ( i , j , k ), bz ( i , j , k ), bp ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ) END DO loop010 f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = br ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) !< B_R f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bp ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) !< B_phi f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bz ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) !< B_Z DEALLOCATE ( br , bp , bz ) END SUBROUTINE read_mgo SUBROUTINE read_hint_eq IMPLICIT NONE !for HDF5 INTEGER ( HID_T ) :: h5id , & & group_id , & & dset_id , & & dspace_id , & & mspace_id , & & crp_id , & & attr_id INTEGER ( HSIZE_T ) :: dim1id_h5 ( 1 ), & & maxdim_h5 ( 1 ), & & dim3ids_h5 ( 3 ) INTEGER :: ierror CHARACTER ( LEN = 10 ) :: group_name !for netCDF4 INTEGER :: ncid , & & t_varid , & & mtor_varid , & & rmin_varid , & & rmax_varid , & & zmin_varid , & & zmax_varid , & & br_varid , & & bp_varid , & & bz_varid , & & vr_varid , & & vp_varid , & & vz_varid , & & p_varid , & & x_dimid , & & y_dimid , & & z_dimid , & & t_dimid , & & start2 ( 2 ), & & count2 ( 2 ), & & start4 ( 4 ), & & count4 ( 4 ) REAL ( RP ), ALLOCATABLE :: w1d (:), & & w3d (:,:,:) INTEGER :: nt0bh , & & nt1b , & & kstep , & & i , & & j , & & jq , & & k , & & itemp ( 4 ) REAL ( RP ) :: time , & & kpitch , & & dt , & & temp REAL ( RP ), ALLOCATABLE :: br (:,:,:), & & bp (:,:,:), & & bz (:,:,:) CHARACTER ( LEN = 100 ) :: fmt time = 999 9.0_RP SELECT CASE ( TRIM ( file_format )) CASE ( 'hdf5' , \"HDF5\" ) IF ( LEN ( TRIM ( mag_file )) == 0 ) mag_file = 'magfile.h5' CALL h5open_f ( ierror ) CALL h5fopen_f ( TRIM ( mag_file ), H5F_ACC_RDWR_F , h5id , ierror ) CALL h5dopen_f ( h5id , 'kstep' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_INTEGER , kstep , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'nr' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_INTEGER , nr0b , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'nz' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_INTEGER , nz0b , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'ntor' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_INTEGER , nt0b , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'mtor' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_INTEGER , mtor , dim1id_h5 , ierror ) ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP CALL h5dopen_f ( h5id , 'rminb' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , rminb , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'rmaxb' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , rmaxb , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'zminb' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , zminb , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'zmaxb' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , zmaxb , dim1id_h5 , ierror ) CALL h5dclose_f ( dset_id , ierror ) ALLOCATE ( w1d ( kstep ), w3d ( nr0b , nz0b , nt0b )) CALL h5dopen_f ( h5id , 't_snap' , dset_id , ierror ) CALL h5dget_space_f ( dset_id , dspace_id , ierror ) CALL h5dget_create_plist_f ( dset_id , crp_id , ierror ) dim1id_h5 = ( / kstep / ) CALL h5screate_simple_f ( 1 , dim1id_h5 , mspace_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , w1d , dim1id_h5 , ierror , mspace_id , dspace_id ) CALL h5pclose_f ( crp_id , ierror ) CALL h5sclose_f ( dspace_id , ierror ) CALL h5dclose_f ( dset_id , ierror ) k = 1 DO #ifdef MPI IF ( myrank == 0 ) THEN #endif WRITE ( 6 , '(A7, I5, 2F12.4)' ) ' time= ' , k , w1d ( k ), time #ifdef MPI END IF #endif IF (( w1d ( k ) >= time ) . OR . ( k >= kstep )) EXIT k = k + 1 END DO time = w1d ( k ) WRITE ( group_name , '(F10.4)' ) time CALL h5gopen_f ( h5id , group_name , group_id , ierror ) dim3ids_h5 = ( / nr0b , nz0b , nt0b / ) CALL h5dopen_f ( group_id , 'B_R' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , w3d , dim3ids_h5 , ierror ) f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL h5dopen_f ( group_id , 'B_phi' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , w3d , dim3ids_h5 , ierror ) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL h5dopen_f ( group_id , 'B_Z' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , w3d , dim3ids_h5 , ierror ) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL h5dclose_f ( dset_id , ierror ) CALL h5gclose_f ( group_id , ierror ) CALL h5fclose_f ( h5id , ierror ) CALL h5close_f ( ierror ) DEALLOCATE ( w1d , w3d ) CASE ( 'netcdf' , \"NETCDF\" ) IF ( LEN ( TRIM ( mag_file )) == 0 ) mag_file = 'magfile.nc' CALL check ( NF90_OPEN ( TRIM ( mag_file ), NF90_NOWRITE , ncid )) CALL check ( NF90_INQ_DIMID ( ncid , 'R' , x_dimid )) CALL check ( NF90_INQ_DIMID ( ncid , 'Z' , y_dimid )) CALL check ( NF90_INQ_DIMID ( ncid , 'phi' , z_dimid )) CALL check ( NF90_INQUIRE_DIMENSION ( ncid , x_dimid , len = nr0b )) CALL check ( NF90_INQUIRE_DIMENSION ( ncid , y_dimid , len = nz0b )) CALL check ( NF90_INQUIRE_DIMENSION ( ncid , z_dimid , len = nt0b )) ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP CALL check ( NF90_INQ_DIMID ( ncid , 'time' , t_dimid )) CALL check ( NF90_INQUIRE_DIMENSION ( ncid , t_dimid , len = kstep )) ALLOCATE ( w1d ( kstep ), w3d ( nr0b , nz0b , nt0b )) CALL check ( NF90_INQ_VARID ( ncid , \"t_snap\" , t_varid )) count2 = ( / 1 , kstep / ) start2 = ( / 1 , 1 / ) CALL check ( NF90_GET_VAR ( ncid , t_varid , w1d , count = count2 , start = start2 )) k = 1 DO #ifdef MPI IF ( myrank == 0 ) THEN #endif WRITE ( 6 , '(A7, I5, 2F12.4)' ) ' time= ' , k , w1d ( k ), time #ifdef MPI END IF #endif IF (( w1d ( k ) >= time ) . OR . ( k >= kstep )) EXIT k = k + 1 END DO time = w1d ( k ) CALL check ( NF90_INQ_VARID ( ncid , \"mtor\" , mtor_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"rminb\" , rmin_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"rmaxb\" , rmax_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"zminb\" , zmin_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"zmaxb\" , zmax_varid )) CALL check ( NF90_GET_VAR ( ncid , mtor_varid , mtor )) CALL check ( NF90_GET_VAR ( ncid , rmin_varid , rminb )) CALL check ( NF90_GET_VAR ( ncid , rmax_varid , rmaxb )) CALL check ( NF90_GET_VAR ( ncid , zmin_varid , zminb )) CALL check ( NF90_GET_VAR ( ncid , zmax_varid , zmaxb )) CALL check ( NF90_INQ_VARID ( ncid , \"B_R\" , br_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"B_phi\" , bp_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"B_Z\" , bz_varid )) count4 = ( / nr0b , nz0b , nt0b , 1 / ) start4 = ( / 1 , 1 , 1 , k / ) CALL check ( NF90_GET_VAR ( ncid , br_varid , w3d , count = count4 , start = start4 )) f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL check ( NF90_GET_VAR ( ncid , bp_varid , w3d , count = count4 , start = start4 )) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL check ( NF90_GET_VAR ( ncid , bz_varid , w3d , count = count4 , start = start4 )) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL check ( NF90_CLOSE ( ncid )) DEALLOCATE ( w1d , w3d ) CASE ( 'bin' , \"BIN\" ) SELECT CASE ( TRIM ( version )) CASE ( 'ver2' ) READ ( 25 ) time READ ( 25 ) nr0b , nz0b , nt1b , mtor READ ( 25 ) rminb , zminb , rmaxb , zmaxb , kpitch IF ( kpitch == 0.5_RP ) THEN PRINT * PRINT * , ' !!! kpitch=0.5 !!!: assumed helical symmetry.' PRINT * nt0bh = nt1b - 4 nt0b = 2 * ( nt1b - 5 ) ELSE nt0b = nt1b - 5 mtor = mtor / kpitch END IF ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP ALLOCATE ( br ( nr0b , nz0b , nt1b ), bp ( nr0b , nz0b , nt1b ), bz ( nr0b , nz0b , nt1b )) #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading magnetic field data as HINT2 format' PRINT * #ifdef MPI END IF #endif REWIND 25 1 CONTINUE READ ( 25 , END = 2 ) time READ ( 25 ) ( itemp ( i ), i = 1 , 4 ) READ ( 25 ) temp , temp , temp , temp , temp READ ( 25 ) temp fmt = '(A7,ES12.4)' #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT fmt , ' time= ' , time #ifdef MPI END IF #endif loop010 : DO k = 1 , nt1b READ ( 25 ) (( br ( i , j , k ), bz ( i , j , k ), bp ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ) READ ( 25 ) (( temp , temp , temp , i = 1 , nr0b ), j = 1 , nz0b ) READ ( 25 ) (( temp , i = 1 , nr0b ), j = 1 , nz0b ) END DO loop010 GOTO 1 2 CONTINUE IF ( kpitch == 0.5_RP ) THEN f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0bh ) = br ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0bh ) = bp ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0bh ) = bz ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) DO k = 1 , nt0bh - 1 DO j = 1 , nz0b jq = nz0b - j + 1 DO i = 1 , nr0b f3d ( 1 , i , j , nt0b + 2 - k ) = - f3d ( 1 , i , jq , k ) f3d ( 2 , i , j , nt0b + 2 - k ) = f3d ( 2 , i , jq , k ) f3d ( 3 , i , j , nt0b + 2 - k ) = f3d ( 3 , i , jq , k ) END DO END DO END DO ELSE f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b + 1 ) = br ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b + 1 ) = bp ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b + 1 ) = bz ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) END IF CASE DEFAULT READ ( 25 ) kstep READ ( 25 ) time READ ( 25 ) nr0b , nz0b , nt0b , mtor READ ( 25 ) rminb , zminb , rmaxb , zmaxb ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP ALLOCATE ( br ( nr0b , nz0b , nt0b ), bp ( nr0b , nz0b , nt0b ), bz ( nr0b , nz0b , nt0b )) #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading magnetic field data as HINT format' PRINT * #ifdef MPI END IF #endif REWIND 25 3 CONTINUE READ ( 25 , END = 4 ) kstep READ ( 25 ) time READ ( 25 ) ( itemp ( i ), i = 1 , 4 ) READ ( 25 ) temp , temp , temp , temp fmt = '(A7,ES12.4)' #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT fmt , ' time= ' , time #ifdef MPI END IF #endif READ ( 25 ) ((( br ( i , j , k ), bp ( i , j , k ), bz ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) READ ( 25 ) ((( temp , temp , temp , i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) READ ( 25 ) ((( temp , i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) GOTO 3 4 CONTINUE f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = br ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bp ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bz ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) END SELECT DEALLOCATE ( br , bp , bz ) END SELECT END SUBROUTINE read_hint_eq SUBROUTINE read_hint_vac IMPLICIT NONE !for HDF5 INTEGER ( HID_T ) :: h5id , & & group_id , & & dset_id INTEGER ( HSIZE_T ) :: dim1id_h5 ( 1 ), & & dim3ids_h5 ( 3 ) INTEGER :: ierror !for netCDF4 INTEGER :: ncid , & & mtor_varid , & & rmin_varid , & & rmax_varid , & & zmin_varid , & & zmax_varid , & & br_varid , & & bp_varid , & & bz_varid , & & x_dimid , & & y_dimid , & & z_dimid REAL ( RP ), ALLOCATABLE :: w3d (:,:,:) INTEGER :: nt0bh , & & nt1b , & & i , & & j , & & jq , & & k REAL ( RP ) :: kpitch REAL ( RP ), ALLOCATABLE :: br (:,:,:), & & bp (:,:,:), & & bz (:,:,:) CHARACTER ( LEN = 100 ) :: fmt SELECT CASE ( TRIM ( file_format )) CASE ( 'hdf5' , \"HDF5\" ) IF ( LEN ( TRIM ( mag_file )) == 0 ) mag_file = 'vacfile.h5' CALL h5open_f ( ierror ) CALL h5fopen_f ( TRIM ( mag_file ), H5F_ACC_RDONLY_F , h5id , ierror ) CALL h5dopen_f ( h5id , 'nr' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_INTEGER , nr0b , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'nz' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_INTEGER , nz0b , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'ntor' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_INTEGER , nt0b , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'mtor' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_INTEGER , mtor , dim1id_h5 , ierror ) ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP CALL h5dopen_f ( h5id , 'rminb' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , rminb , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'rmaxb' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , rmaxb , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'zminb' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , zminb , dim1id_h5 , ierror ) CALL h5dopen_f ( h5id , 'zmaxb' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , zmaxb , dim1id_h5 , ierror ) CALL h5dclose_f ( dset_id , ierror ) ALLOCATE ( w3d ( nr0b , nz0b , nt0b )) CALL h5gopen_f ( h5id , 'Vaccum_field' , group_id , ierror ) dim3ids_h5 = ( / nr0b , nz0b , nt0b / ) CALL h5dopen_f ( group_id , 'Bvac_R' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , w3d , dim3ids_h5 , ierror ) f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL h5dopen_f ( group_id , 'Bvac_phi' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , w3d , dim3ids_h5 , ierror ) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL h5dopen_f ( group_id , 'Bvac_Z' , dset_id , ierror ) CALL h5dread_f ( dset_id , H5T_NATIVE_DOUBLE , w3d , dim3ids_h5 , ierror ) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL h5dclose_f ( dset_id , ierror ) CALL h5gclose_f ( group_id , ierror ) CALL h5fclose_f ( h5id , ierror ) CALL h5close_f ( ierror ) DEALLOCATE ( w3d ) CASE ( 'netcdf' , \"NETCDF\" ) IF ( LEN ( TRIM ( mag_file )) == 0 ) mag_file = 'vacfile.nc' CALL check ( NF90_OPEN ( TRIM ( mag_file ), NF90_NOWRITE , ncid )) CALL check ( NF90_INQ_DIMID ( ncid , 'R' , x_dimid )) CALL check ( NF90_INQ_DIMID ( ncid , 'Z' , y_dimid )) CALL check ( NF90_INQ_DIMID ( ncid , 'phi' , z_dimid )) CALL check ( NF90_INQUIRE_DIMENSION ( ncid , x_dimid , len = nr0b )) CALL check ( NF90_INQUIRE_DIMENSION ( ncid , y_dimid , len = nz0b )) CALL check ( NF90_INQUIRE_DIMENSION ( ncid , z_dimid , len = nt0b )) ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP CALL check ( NF90_INQ_VARID ( ncid , \"mtor\" , mtor_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"rminb\" , rmin_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"rmaxb\" , rmax_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"zminb\" , zmin_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"zmaxb\" , zmax_varid )) CALL check ( NF90_GET_VAR ( ncid , mtor_varid , mtor )) CALL check ( NF90_GET_VAR ( ncid , rmin_varid , rminb )) CALL check ( NF90_GET_VAR ( ncid , rmax_varid , rmaxb )) CALL check ( NF90_GET_VAR ( ncid , zmin_varid , zminb )) CALL check ( NF90_GET_VAR ( ncid , zmax_varid , zmaxb )) ALLOCATE ( w3d ( nr0b , nz0b , nt0b )) CALL check ( NF90_INQ_VARID ( ncid , \"Bvac_R\" , br_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"Bvac_phi\" , bp_varid )) CALL check ( NF90_INQ_VARID ( ncid , \"Bvac_Z\" , bz_varid )) CALL check ( NF90_GET_VAR ( ncid , br_varid , w3d )) f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL check ( NF90_GET_VAR ( ncid , bp_varid , w3d )) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL check ( NF90_GET_VAR ( ncid , bz_varid , w3d )) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = w3d ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) CALL check ( NF90_CLOSE ( ncid )) DEALLOCATE ( w3d ) CASE ( 'bin' , \"BIN\" ) SELECT CASE ( TRIM ( version )) CASE ( 'ver2' ) READ ( 25 ) nr0b , nz0b , nt1b , mtor READ ( 25 ) rminb , zminb , rmaxb , zmaxb , kpitch IF ( kpitch == 0.5_RP ) THEN #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * PRINT * , ' !!! kpitch=0.5 !!!: assumed helical symmetry.' PRINT * #ifdef MPI END IF #endif nt0bh = nt1b - 4 nt0b = 2 * ( nt1b - 5 ) ELSE nt0b = nt1b - 5 mtor = mtor / kpitch END IF ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP ALLOCATE ( br ( nr0b , nz0b , nt1b ), bp ( nr0b , nz0b , nt1b ), bz ( nr0b , nz0b , nt1b )) #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading magnetic field data as legacy HINT2 format' PRINT * #ifdef MPI END IF #endif loop010 : DO k = 1 , nt1b READ ( 25 ) (( br ( i , j , k ), bz ( i , j , k ), bp ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ) END DO loop010 IF ( kpitch == 0.5_RP ) THEN f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0bh ) = br ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0bh ) = bp ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0bh ) = bz ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) DO k = 1 , nt0bh - 1 DO j = 1 , nz0b jq = nz0b - j + 1 DO i = 1 , nr0b f3d ( 1 , i , j , nt0b + 2 - k ) = - f3d ( 1 , i , jq , k ) f3d ( 2 , i , j , nt0b + 2 - k ) = f3d ( 2 , i , jq , k ) f3d ( 3 , i , j , nt0b + 2 - k ) = f3d ( 3 , i , jq , k ) END DO END DO END DO ELSE f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b + 1 ) = br ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b + 1 ) = bp ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b + 1 ) = bz ( 1 : nr0b , 1 : nz0b , 3 : nt1b - 2 ) END IF CASE DEFAULT READ ( 25 ) nr0b , nz0b , nt0b , mtor READ ( 25 ) rminb , zminb , rmaxb , zmaxb ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP ALLOCATE ( br ( nr0b , nz0b , nt0b ), bp ( nr0b , nz0b , nt0b ), bz ( nr0b , nz0b , nt0b )) #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading vacuum magnetic field data as HINT format' PRINT * #ifdef MPI END IF #endif READ ( 25 ) ((( br ( i , j , k ), bp ( i , j , k ), bz ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = br ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bp ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bz ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) END SELECT DEALLOCATE ( br , bp , bz ) END SELECT END SUBROUTINE read_hint_vac SUBROUTINE read_mips_eq IMPLICIT NONE INTEGER :: itemp , & & jtemp , & & ktemp REAL ( RP ) :: pminb , & & pmaxb , & & dtempr , & & dtempz , & & dtempt REAL ( RP ), ALLOCATABLE :: br (:,:,:), & & bp (:,:,:), & & bz (:,:,:), & & p (:,:,:) mtor = igrid ( 4 ) IF ( mtor <= 0 ) mtor = 1 nr0b = igrid ( 1 ) nz0b = igrid ( 2 ) nt0b = igrid ( 3 ) - 4 ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP ALLOCATE ( br ( nr0b , nz0b , nt0b + 4 ), bp ( nr0b , nz0b , nt0b + 4 ), bz ( nr0b , nz0b , nt0b + 4 ), p ( nr0b , nz0b , nt0b + 4 )) #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading magnetic field data as MIPS format' PRINT * #ifdef MPI END IF #endif SELECT CASE ( TRIM ( file_format )) CASE ( 'large' , \"Large\" ) READ ( 25 ) itemp , jtemp , ktemp , & & rminb , rmaxb , & & zminb , zmaxb , & & pminb , pmaxb , & & dtempr , dtempz , dtempt , & & br READ ( 26 ) bz READ ( 27 ) bp CASE DEFAULT READ ( 25 ) itemp , jtemp , ktemp , & & rminb , rmaxb , & & zminb , zmaxb , & & pminb , pmaxb , & & dtempr , dtempz , dtempt , & & br , bz , bp , p END SELECT f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = br ( 1 : nr0b , 1 : nz0b , 3 : nt0b + 2 ) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bp ( 1 : nr0b , 1 : nz0b , 3 : nt0b + 2 ) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bz ( 1 : nr0b , 1 : nz0b , 3 : nt0b + 2 ) DEALLOCATE ( br , bp , bz , p ) END SUBROUTINE read_mips_eq SUBROUTINE read_mips IMPLICIT NONE INTEGER :: i , j , k REAL ( RP ) :: temp , bmax REAL ( RP ), ALLOCATABLE :: br (:,:,:), & & bp (:,:,:), & & bz (:,:,:) !bmax =  2.333413159206456_RP !bmax =  2.18529336349835_RP !bmax =  2.891266292494260_RP bmax = 2.2970294120056542 READ ( 25 ) READ ( 25 ) READ ( 25 ) nr0b , nz0b , nt0b , mtor READ ( 25 ) rminb , zminb , rmaxb , zmaxb ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP ALLOCATE ( br ( nr0b , nz0b , nt0b ), bp ( nr0b , nz0b , nt0b ), bz ( nr0b , nz0b , nt0b )) #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading vacuum magnetic field data as HINT format' PRINT * #ifdef MPI END IF #endif !    DO k=1,nt0b !      READ(25) ((br(i,j,k), bz(i,j,k), bp(i,j,k), i=1,nr0b), j=1,nz0b) !      READ(25) ((temp, temp, temp, i=1,nr0b), j=1,nz0b) !      READ(25) ((temp, temp, i=1,nr0b), j=1,nz0b) !    END DO READ ( 25 ) ((( br ( i , j , k ), bp ( i , j , k ), bz ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) READ ( 25 ) ((( temp , temp , temp , i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) READ ( 25 ) ((( temp , temp , i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = br ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) * bmax f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bp ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) * bmax f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bz ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) * bmax DEALLOCATE ( br , bp , bz ) RETURN END SUBROUTINE read_mips SUBROUTINE read_ofmc IMPLICIT NONE INTEGER :: i , & & j , & & k REAL ( RP ), ALLOCATABLE :: br (:,:,:), & & bp (:,:,:), & & bz (:,:,:) SELECT CASE ( TRIM ( file_format )) CASE ( 'large' , \"Large\" ) READ ( 25 , * ) nr0b , nz0b , nt0b , mtor ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP ALLOCATE ( br ( nr0b , nz0b , nt0b ), bp ( nr0b , nz0b , nt0b ), bz ( nr0b , nz0b , nt0b )) rminb = mbound ( 1 ) rmaxb = mbound ( 2 ) zminb = mbound ( 3 ) zmaxb = mbound ( 4 ) #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading magnetic field data as MIPS format' PRINT * #ifdef MPI END IF #endif READ ( 25 , * ) ((( br ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) READ ( 26 , * ) READ ( 26 , * ) ((( bz ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) READ ( 27 , * ) READ ( 27 , * ) ((( bp ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) CASE DEFAULT READ ( 25 , * ) nr0b , nz0b , nt0b , mtor ALLOCATE ( f3d ( l3d , - 2 : nr0b + 3 , - 2 : nz0b + 3 , - 2 : nt0b + 4 )) f3d (:,:,:,:) = 0.0_RP ALLOCATE ( br ( nr0b , nz0b , nt0b ), bp ( nr0b , nz0b , nt0b ), bz ( nr0b , nz0b , nt0b )) rminb = mbound ( 1 ) rmaxb = mbound ( 2 ) zminb = mbound ( 3 ) zmaxb = mbound ( 4 ) #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading magnetic field data as MIPS format' PRINT * #ifdef MPI END IF #endif READ ( 25 , * ) ((( br ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) READ ( 25 , * ) ((( bz ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) READ ( 25 , * ) ((( bp ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) END SELECT f3d ( 1 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = br ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) f3d ( 2 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bp ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) f3d ( 3 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = bz ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) DEALLOCATE ( br , bp , bz ) END SUBROUTINE read_ofmc SUBROUTINE read_xss IMPLICIT NONE INTEGER :: itemp , & & jtemp , & & ktemp , & & mtemp , & & i , & & j , & & k REAL ( RP ) :: r1temp , & & r2temp , & & z1temp , & & z2temp REAL ( RP ), ALLOCATABLE :: ss (:,:,:) CHARACTER ( LEN = 100 ) :: fmt #ifdef MPI !For MPI INTEGER :: icode , & & ierr #endif #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * PRINT * , ' ----------------------------------------------------------------' PRINT * , '          SUBROUTINE READ_XSS                                    ' PRINT * , ' ----------------------------------------------------------------' PRINT * #ifdef MPI END IF #endif READ ( 26 ) itemp , jtemp , ktemp , mtemp READ ( 26 ) r1temp , z1temp , r2temp , z2temp IF ( itemp /= nr0b ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_xss: parameter error  itemp =  ' , itemp , '  nr0b  = ' , nr0b #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( jtemp /= nz0b ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_xss: parameter error  jtemp =  ' , jtemp , '  nz0b  = ' , nz0b #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( ktemp /= nt0b ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_xss: parameter error  ktemp =  ' , ktemp , '  nt0b  = ' , nt0b #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( mtemp /= mtor ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_xss: parameter error  mtemp =  ' , mtemp , '  mtor  = ' , mtor #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( r1temp /= rminb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_xss: parameter error  r1temp = ' , r1temp , '  rminb = ' , rminb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( r2temp /= rmaxb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_xss: parameter error  r2temp = ' , r2temp , '  rmaxb = ' , rmaxb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( z1temp /= zminb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_xss: parameter error  z1temp = ' , z1temp , '  zminb = ' , zminb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( z2temp /= zmaxb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_xss: parameter error  z2temp = ' , z2temp , '  zmaxb = ' , zmaxb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF ALLOCATE ( ss ( nr0b , nz0b , nt0b )) ss (:,:,:) = 0.0_RP #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading normalized toroidal flux as XSS format' PRINT * #ifdef MPI END IF #endif loop010 : DO k = 1 , nt0b READ ( 26 ) (( ss ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ) END DO loop010 f3d ( 5 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = ss ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) DEALLOCATE ( ss ) END SUBROUTINE read_xss SUBROUTINE read_flx IMPLICIT NONE INTEGER :: itemp , & & jtemp , & & ktemp , & & mtemp , & & i , & & j , & & k REAL ( RP ) :: r1temp , & & r2temp , & & z1temp , & & z2temp REAL ( RP ), ALLOCATABLE :: ss (:,:,:) CHARACTER ( LEN = 100 ) :: fmt #ifdef MPI !For MPI INTEGER :: icode , & & ierr #endif #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * PRINT * , ' ----------------------------------------------------------------' PRINT * , '          SUBROUTINE READ_FLX                                    ' PRINT * , ' ----------------------------------------------------------------' PRINT * #ifdef MPI END IF #endif READ ( 26 ) itemp , jtemp , ktemp , mtemp READ ( 26 ) r1temp , z1temp , r2temp , z2temp IF ( itemp /= nr0b ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_flx: parameter error  itemp =  ' , itemp , '  nr0b  = ' , nr0b #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( jtemp /= nz0b ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_flx: parameter error  jtemp =  ' , jtemp , '  nz0b  = ' , nz0b #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( ktemp /= nt0b ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_flx: parameter error  ktemp =  ' , ktemp , '  nt0b  = ' , nt0b #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( mtemp /= mtor ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_flx: parameter error  mtemp =  ' , mtemp , '  mtor  = ' , mtor #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( r1temp /= rminb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_flx: parameter error  r1temp = ' , r1temp , '  rminb = ' , rminb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( r2temp /= rmaxb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_flx: parameter error  r2temp = ' , r2temp , '  rmaxb = ' , rmaxb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( z1temp /= zminb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_flx: parameter error  z1temp = ' , z1temp , '  zminb = ' , zminb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( z2temp /= zmaxb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_flx: parameter error  z2temp = ' , z2temp , '  zmaxb = ' , zmaxb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF ALLOCATE ( ss ( nr0b , nz0b , nt0b )) ss (:,:,:) = 0.0_RP #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading normalized toroidal flux as HINT format' PRINT * #ifdef MPI END IF #endif READ ( 26 ) ((( ss ( i , j , k ), i = 1 , nr0b ), j = 1 , nz0b ), k = 1 , nt0b ) f3d ( 5 , 1 : nr0b , 1 : nz0b , 1 : nt0b ) = ss ( 1 : nr0b , 1 : nz0b , 1 : nt0b ) DEALLOCATE ( ss ) END SUBROUTINE read_flx SUBROUTINE read_eqdsk IMPLICIT NONE INTEGER :: nr , & & nz , & & ns , & & i , & & j , & & k REAL ( RP ) :: rdim , & & zdim , & & rleft , & & zmid , & & psi0 , & & psia , & & rmin , & & rmax , & & zmin , & & zmax , & & r , & & z , & & dr , & & dz , & & eps , & & temp , & & x2d ( 2 ), & & w2d ( 1 ) REAL ( RP ), ALLOCATABLE :: psig (:,:) CHARACTER ( LEN = 10 ) :: header ( 6 ) CHARACTER ( LEN = 100 ) :: fmt #ifdef MPI !For MPI INTEGER :: icode , & & ierr #endif #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * PRINT * , ' ----------------------------------------------------------------' PRINT * , '          SUBROUTINE READ_EQDSK                                  ' PRINT * , ' ----------------------------------------------------------------' PRINT * #ifdef MPI END IF #endif READ ( 26 , '( 6A8, 3I4 )' ) ( header ( i ), i = 1 , 6 ), j , nr , nz ns = nr READ ( 26 , '( 5E16.9 )' ) rdim , zdim , temp , rleft , zmid READ ( 26 , '( 5E16.9 )' ) temp , temp , psi0 , psia , temp READ ( 26 , '( 5E16.9 )' ) temp , temp , temp , temp , temp READ ( 26 , '( 5E16.9 )' ) temp , temp , temp , temp , temp rmin = rleft rmax = rleft + rdim zmin = zmid - 0.5_RP * zdim zmax = zmid + 0.5_RP * zdim #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * PRINT * , '   COORDINATES SYSTEMS ' PRINT * , '  --------------------------------------------------------' PRINT * , '       RMIN          RMAX          ZMIN          ZMAX ' fmt = '(2X,4F14.9)' PRINT fmt , rmin , rmax , zmin , zmax PRINT * PRINT * , '   RESOLUSIONS' PRINT * , '  ------------------------' PRINT * , '      NR      NZ      NS ' fmt = '(2X,3I8)' PRINT fmt , nr , nz , ns PRINT * PRINT * , '   EQUILIBRIUM PARAMETRS ' PRINT * , '  ----------------------------' PRINT * , '       PSI0          PSIA ' fmt = '(2x,2F14.9)' PRINT fmt , psi0 , psia PRINT * PRINT * #ifdef MPI END IF #endif ALLOCATE ( psig ( nr , nz )) READ ( 26 , '( 5E16.9 )' ) ( temp , i = 1 , ns ) READ ( 26 , '( 5E16.9 )' ) ( temp , i = 1 , ns ) READ ( 26 , '( 5E16.9 )' ) ( temp , i = 1 , ns ) READ ( 26 , '( 5E16.9 )' ) ( temp , i = 1 , ns ) READ ( 26 , '( 5E16.9 )' ) (( psig ( i , j ), i = 1 , nr ), j = 1 , nz ) IF ( rmin /= rminb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_eqdsk: parameter error  rleft       =' , rmin , '  rminb = ' , rminb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( rmax /= rmaxb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_eqdsk: parameter error  rleft+rdim  =' , rmax , '  rmaxb = ' , rmaxb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( zmin /= zminb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_eqdsk: parameter error  zmid-zdim/2 =' , zmin , '  zminb = ' , zminb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( zmax /= zmaxb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_eqdsk: parameter error  zmid+zdim/2 =' , zmax , '  zminb = ' , zminb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading normalized poloidal flux as EQDSK format' PRINT * #ifdef MPI END IF #endif !psig(:,:) =  psig(:,:) - psia !psig(:,:) =  psig(:,:) / (psia - psi0) + 1.0_RP psig (:,:) = 1.0_RP - ( psig (:,:) - psia ) / ( psi0 - psia ) IF (( nr /= nr0b ) . OR . ( nz /= nz0b )) THEN #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * PRINT * PRINT * #ifdef MPI END IF #endif l2d = 1 ALLOCATE ( rg ( nr ), zg ( nz ), f2d ( l2d , - 2 : nr + 3 , - 2 : nz + 3 )) f2d ( 1 , 1 : nr , 1 : nz ) = psig ( 1 : nr , 1 : nz ) dr = ( rmaxb - rminb ) / ( nr - 1 ) dz = ( zmaxb - zminb ) / ( nz - 1 ) DO i = 1 , nr rg ( i ) = rminb + dr * ( i - 1 ) END DO DO j = 1 , nz zg ( j ) = zminb + dz * ( j - 1 ) END DO #ifdef MPI IF ( myrank == 0 ) THEN #endif DO j = 1 , nz DO i = 1 , nr WRITE ( 71 , '(10ES15.7)' ) rg ( i ), zg ( j ), psig ( i , j ) END DO WRITE ( 71 , * ) END DO #ifdef MPI END IF #endif DO j = 1 , nz DO i = 1 , 3 r = rg ( 1 ) - dr * ( 4 - i ) CALL polint ( rg ( 1 : 4 ), f2d ( 1 , 1 : 4 , j ), 4 , r , f2d ( 1 , i - 3 , j ), eps ) r = rg ( nr ) + dr * i CALL polint ( rg ( nr - 3 : nr ), f2d ( 1 , nr - 3 : nr , j ), 4 , r , f2d ( 1 , nr + i , j ), eps ) END DO END DO DO i =- 2 , nr + 3 DO j = 1 , 3 z = zg ( 1 ) - dz * ( 4 - j ) CALL polint ( zg ( 1 : 4 ), f2d ( 1 , i , 1 : 4 ), 4 , z , f2d ( 1 , i , j - 3 ), eps ) z = zg ( nz ) + dz * j CALL polint ( zg ( nz - 3 : nz ), f2d ( 1 , i , nz - 3 : nz ), 4 , z , f2d ( 1 , i , nz + j ), eps ) END DO END DO nx2d = nr ny2d = nz CALL splin2 ( rminb , rmaxb , zminb , zmaxb ) dr = ( rmaxb - rminb ) / ( nr0b - 1 ) dz = ( zmaxb - zminb ) / ( nz0b - 1 ) #ifdef MPI IF ( myrank == 0 ) THEN #endif DO j = 1 , nz0b DO i = 1 , nr0b x2d ( 1 ) = rminb + dr * ( i - 1 ) x2d ( 2 ) = zminb + dz * ( j - 1 ) CALL spl2df ( x2d , w2d ) f3d ( 5 , i , j , k ) = w2d ( 1 ) WRITE ( 72 , '(10ES15.7)' ) x2d ( 1 ), x2d ( 2 ), w2d ( 1 ) END DO WRITE ( 72 , * ) END DO #ifdef MPI END IF #endif DO k = 1 , nt0b DO j = 1 , nz0b DO i = 1 , nr0b x2d ( 1 ) = rminb + dr * ( i - 1 ) x2d ( 2 ) = zminb + dz * ( j - 1 ) CALL spl2df ( x2d , w2d ) f3d ( 5 , i , j , k ) = w2d ( 1 ) END DO END DO END DO DEALLOCATE ( rg , zg , f2d ) ELSE DO k = 1 , nt0b f3d ( 5 , 1 : nr0b , 1 : nz0b , k ) = psig ( 1 : nr0b , 1 : nz0b ) END DO END IF DEALLOCATE ( psig ) END SUBROUTINE read_eqdsk SUBROUTINE read_eqdata IMPLICIT NONE INTEGER :: irdm , & & izdm2 , & & irzdm2 , & & ivdm , & & i , & & j , & & k , & & itemp ( 10 ) REAL ( RP ) :: saxis , & & temp REAL ( RP ), ALLOCATABLE :: rr (:), & & zz (:), & & psi (:), & & psig (:,:) CHARACTER ( LEN = 10 ) :: header ( 6 ) #ifdef MPI !For MPI INTEGER :: icode , & & ierr #endif #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * PRINT * , ' ----------------------------------------------------------------' PRINT * , '          SUBROUTINE READ_EQDATA                                 ' PRINT * , ' ----------------------------------------------------------------' PRINT * #ifdef MPI END IF #endif READ ( 26 , * ) itemp ( 1 ), temp READ ( 26 , * ) irdm , izdm2 , irzdm2 , itemp ( 1 ), itemp ( 2 ), ivdm , itemp ( 3 ), itemp ( 4 ), itemp ( 5 ) ALLOCATE ( rr ( irdm ), zz ( izdm2 ), psi ( irzdm2 )) READ ( 26 , * ) ( psi ( i ), temp , i = 1 , irzdm2 ) READ ( 26 , * ) ( rr ( i ), i = 1 , irdm ) READ ( 26 , * ) ( temp , i = 1 , irdm ) READ ( 26 , * ) ( zz ( i ), i = 1 , izdm2 ) READ ( 26 , * ) ( temp , i = 1 , ivdm ) READ ( 26 , * ) ( temp , temp , temp , i = 1 , ivdm ) READ ( 26 , * ) temp , temp , temp , saxis , temp , temp , temp , temp , temp , temp , temp , temp , temp , temp , temp ALLOCATE ( psig ( irdm , izdm2 )) k = 0 DO j = 1 , izdm2 DO i = 1 , irdm k = k + 1 psig ( i , j ) = psi ( k ) END DO END DO IF ( irdm /= nr0b ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_eqdata: parameter error  irdm      = ' , irdm , '  nr0b  = ' , nr0b #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( izdm2 /= nz0b ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_eqdata: parameter error  izdm2     = ' , izdm2 , '  nz0b  = ' , nz0b #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( rr ( 1 ) /= rminb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_eqdata: parameter error  rr(1)     =' , rr ( 1 ), '  rminb = ' , rminb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( rr ( irdm ) /= rmaxb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_eqdata: parameter error  rr(irdm)  =' , rr ( irdm ), '  rmaxb = ' , rmaxb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( zz ( 1 ) /= zminb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_eqdata: parameter error  zz(1)     =' , zz ( 1 ), '  zminb = ' , zminb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF IF ( zz ( izdm2 ) /= zmaxb ) THEN #ifdef MPI IF ( myrank == 0 ) & #endif PRINT * , 'read_eqdata: parameter error  zz(izdm2) =' , zz ( izdm2 ), '  zminb = ' , zminb #ifdef MPI CALL MPI_ABORT ( MPI_COMM_WORLD , icode , ierr ) #else STOP #endif END IF #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * , ' Reading normalized poloidal flux as EQDATA format' PRINT * #ifdef MPI END IF #endif psig (:,:) = psig (:,:) - saxis psig (:,:) = psig (:,:) / ABS ( saxis ) DO k = 1 , nt0b f3d ( 5 , 1 : nr0b , 1 : nz0b , k ) = psig ( 1 : nr0b , 1 : nz0b ) END DO DEALLOCATE ( rr , zz , psi , psig ) END SUBROUTINE read_eqdata !> A subroutine that deallocates fortran arrays. SUBROUTINE free_mem_field IMPLICIT NONE DEALLOCATE ( f3d ) END SUBROUTINE free_mem_field !> A subroutine that read a table of the magnetic field, (\\f$B_R, B_{\\phi}, B_Z, B\\f$), !! on the cylindrical coordinate, (\\f$R, \\phi, Z\\f$). !> @n !> @em NOTE: the right-handed system SUBROUTINE magset IMPLICIT NONE INTEGER :: i , & & j , & & jq , & & k , & & l REAL ( RP ) :: r , & & z , & & bb , & & eps CHARACTER ( LEN = 100 ) :: fmt #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * PRINT * , ' ----------------------------------------------------------------' PRINT * , '          SUBROUTINE MAGSET                                      ' PRINT * , ' ----------------------------------------------------------------' PRINT * #ifdef MPI END IF #endif CALL read_field ALLOCATE ( rg ( nr0b ), zg ( nz0b )) pi2m = pi2 / mtor nx3d = nr0b ny3d = nz0b nz3d = nt0b + 1 delrb = ( rmaxb - rminb ) / ( nr0b - 1 ) delzb = ( zmaxb - zminb ) / ( nz0b - 1 ) DO i = 1 , nr0b rg ( i ) = rminb + delrb * ( i - 1 ) END DO DO j = 1 , nz0b zg ( j ) = zminb + delzb * ( j - 1 ) END DO CALL splin3 ( rminb , rmaxb , zminb , zmaxb , 0.0_RP , pi2m ) f3d ( 4 ,:,:,:) = SQRT ( f3d ( 1 ,:,:,:) ** 2 + f3d ( 2 ,:,:,:) ** 2 + f3d ( 3 ,:,:,:) ** 2 ) DO k = 1 , nt0b DO j = 1 , nz0b DO i = 1 , nr0b bb = f3d ( 4 , i , j , k ) IF ( bb > bmax ) THEN f3d ( 1 , i , j , k ) = bmax * f3d ( 1 , i , j , k ) / bb f3d ( 2 , i , j , k ) = bmax * f3d ( 2 , i , j , k ) / bb f3d ( 3 , i , j , k ) = bmax * f3d ( 3 , i , j , k ) / bb END IF END DO END DO END DO f3d ( 4 ,:,:,:) = SQRT ( f3d ( 1 ,:,:,:) ** 2 + f3d ( 2 ,:,:,:) ** 2 + f3d ( 3 ,:,:,:) ** 2 ) DO k = 1 , nt0b DO j = 1 , nz0b DO i = 1 , 3 DO l = 1 , l3d r = rminb - delrb * ( 4 - i ) CALL polint ( rg ( 1 : 4 ), f3d ( l , 1 : 4 , j , k ), 4 , r , f3d ( l , i - 3 , j , k ), eps ) r = rmaxb + delrb * i CALL polint ( rg ( nr0b - 3 : nr0b ), f3d ( l , nr0b - 3 : nr0b , j , k ), 4 , r , f3d ( l , nr0b + i , j , k ), eps ) END DO END DO END DO END DO DO k = 1 , nt0b DO i =- 2 , nr0b + 3 DO j = 1 , 3 DO l = 1 , l3d z = zminb - delzb * ( 4 - j ) CALL polint ( zg ( 1 : 4 ), f3d ( l , i , 1 : 4 , k ), 4 , z , f3d ( l , i , j - 3 , k ), eps ) z = zmaxb + delzb * j CALL polint ( zg ( nz0b - 3 : nz0b ), f3d ( l , i , nz0b - 3 : nz0b , k ), 4 , z , f3d ( l , i , nz0b + j , k ), eps ) END DO END DO END DO END DO IF ( nt0b == 1 ) THEN f3d (:,:,:, nt0b + 1 ) = f3d (:,:,:, 1 ) f3d (:,:,:, nt0b + 2 ) = f3d (:,:,:, 1 ) f3d (:,:,:, nt0b + 3 ) = f3d (:,:,:, 1 ) f3d (:,:,:, nt0b + 4 ) = f3d (:,:,:, 1 ) f3d (:,:,:, - 2 ) = f3d (:,:,:, 1 ) f3d (:,:,:, - 1 ) = f3d (:,:,:, 1 ) f3d (:,:,:, 0 ) = f3d (:,:,:, 1 ) ELSE !      IF(lsymmetry)THEN !        IF(mod(nt0b,2) /= 0)THEN #ifdef MPI !          IF(myrank == 0)THEN #endif !          PRINT * !          PRINT *, ' parameter nt0b is NOT even number!!!' !          PRINT * #ifdef MPI !          END IF #endif !          STOP !        END IF !        f3d(:,:,:,1)        =  0.5_RP * (f3d(:,:,:,2)      + f3d(:,:,:,nt0b)) !        f3d(:,:,:,nt0b/2+1) =  0.5_RP * (f3d(:,:,:,nt0b/2) + f3d(:,:,:,nt0b/2+2)) !      END IF f3d (:,:,:, nt0b + 1 ) = f3d (:,:,:, 1 ) f3d (:,:,:, nt0b + 2 ) = f3d (:,:,:, 2 ) f3d (:,:,:, nt0b + 3 ) = f3d (:,:,:, 3 ) f3d (:,:,:, nt0b + 4 ) = f3d (:,:,:, 4 ) f3d (:,:,:, - 2 ) = f3d (:,:,:, nt0b - 2 ) f3d (:,:,:, - 1 ) = f3d (:,:,:, nt0b - 1 ) f3d (:,:,:, 0 ) = f3d (:,:,:, nt0b ) END IF #ifdef MPI IF ( myrank == 0 ) THEN #endif PRINT * PRINT * , ' COORDINATES SYSTEMS ' PRINT * , '------------------------------------------' PRINT * , '   M    Rmin     Rmax     Zmin     Zmax' fmt = '(I5, 4F9.4)' PRINT fmt , mtor , rminb , rmaxb , zminb , zmaxb PRINT * PRINT * , ' RESOLUSIONS' PRINT * , '----------------------------------------------------' PRINT * , '   nr0b    nt0b    nz0b   delrb     dphi    delzb' fmt = '(3I8, 4F9.4)' PRINT fmt , nr0b , nt0b , nz0b , delrb , pi2m / nt0b , delzb #ifdef MPI END IF #endif #ifdef BCHECK OPEN ( 70 , FILE = 'bcheck.txt' , FORM = 'FORMATTED' , STATUS = 'UNKNOWN' ) DO k = 1 , nt0b DO j = 1 , nz0b DO i = 1 , nr0b WRITE ( 70 , '(10(ES23.15,A))' ) rg ( i ), ',' , zg ( j ), ',' , f3d ( 1 , i , j , k ), ',' , f3d ( 2 , i , j , k ), ',' , f3d ( 3 , i , j , k ), ',' , f3d ( 4 , i , j , k ), ',' END DO END DO END DO CLOSE ( 70 ) #endif DEALLOCATE ( rg , zg ) END SUBROUTINE magset !> A subroutine that interpolates magnetic fields, (\\f$B_R, B_{\\phi}, B_Z, B\\f$), !! on a given coordinate, (\\f$R, \\phi, Z\\f$) !! @param[in] r \\f$ R \\f$ [m] !! @param[in] phi \\f$ \\phi \\f$ [rad] !! @param[in] z \\f$ Z \\f$ [m] !! @param[out] br \\f$ B_R \\f$ [T] !! @param[out] bp \\f$ B_{\\phi} \\f$ [T] !! @param[out] bz \\f$ B_Z \\f$ [T] !! @param[out] bb \\f$ |B| \\f$ [T] SUBROUTINE mgval1 ( r , phi , z , & ! (in) & br , bp , bz , bb & ! (out) & ) IMPLICIT NONE REAL ( RP ), INTENT ( IN ) :: r , & ! R [m] & phi , & ! toroidal angle, phi [rad] & z ! Z [m] REAL ( RP ), INTENT ( OUT ) :: br , & ! B_R [T] & bp , & ! B_phi [T] & bz , & ! B_Z [T] & bb ! |B| [T] INTEGER :: iphi REAL ( RP ) :: phi1 , & & xd ( 3 ), & & w0 ( l3d ) iphi = phi / pi2m phi1 = phi - pi2m * iphi IF ( phi1 < 0.0_RP ) phi1 = phi1 + pi2m IF ( phi1 >= pi2m ) phi1 = phi1 - pi2m xd ( 1 ) = r xd ( 2 ) = z xd ( 3 ) = phi1 CALL spl3df ( xd (:), w0 (:)) br = w0 ( 1 ) bp = w0 ( 2 ) bz = w0 ( 3 ) bb = w0 ( 4 ) RETURN END SUBROUTINE mgval1 !> A subroutine that interpolates magnetic fields, (\\f$B_R, B_{\\phi}, B_Z, B\\f$), !! and calculates 1st derivative, (\\f$ \\partial \\textbf{B} / \\partial R, \\partial \\textbf{B} / \\partial \\phi, \\partial \\textbf{B} / \\partial Z \\f$), !! on a given coordinate, (\\f$R, \\phi, Z\\f$) !! @param[in] r \\f$ R \\f$ [m] !! @param[in] phi \\f$ \\phi \\f$ [rad] !! @param[in] z \\f$ Z \\f$ [m] !! @param[out] b (\\f$ B_R, B_{\\phi}, B_Z, |B| \\f$)[T] !! @param[out] dbdr (\\f$ \\partial B_R / \\partial R, \\partial B_{\\phi} / \\partial R, \\partial B_Z / \\partial R, \\partial B / \\partial R \\f$) [T/m] !! @param[out] dbdp (\\f$ \\partial B_R / \\partial \\phi, \\partial B_{\\phi} / \\partial \\phi, \\partial B_Z / \\partial \\phi, \\partial B / \\partial \\phi \\f$) [T/rad] !! @param[out] dbdz (\\f$ \\partial B_R / \\partial Z, \\partial B_{\\phi} / \\partial Z, \\partial B_Z / \\partial Z, \\partial B / \\partial Z \\f$) [T/m] SUBROUTINE mgval2 ( r , phi , z , & ! (in) & b , dbdr , dbdp , dbdz & ! (out) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: r , & ! major radius in computational region [m] & phi , & ! toroidal angle in computational region [rad] & z ! height in computational region [m] REAL ( RP ), INTENT ( OUT ) :: b ( l3d ), & ! B vector (1:BR,2:BT,3:BZ,4:B) & dbdr ( l3d ), & ! R-derivative of B vector (1:BR,2:BZ,3:BT,4:B) & dbdp ( l3d ), & ! phi-derivative of B vector (1:BR,2:BZ,3:BT,4:B) & dbdz ( l3d ) ! Z-derivative of B vector (1:BR,2:BZ,3:BT,4:B) !Local variables INTEGER :: iphi REAL ( RP ) :: phi1 , & & xd ( 3 ), & & w0 ( l3d ), & & wx ( l3d ), & & wy ( l3d ), & & wz ( l3d ) iphi = phi / pi2m phi1 = phi - pi2m * iphi IF ( phi1 < 0.0_RP ) phi1 = phi1 + pi2m IF ( phi1 >= pi2m ) phi1 = phi1 - pi2m xd ( 1 ) = r xd ( 2 ) = z xd ( 3 ) = phi1 CALL spl3dd ( xd (:), w0 (:), wx (:), wy (:), wz (:)) b (:) = w0 (:) dbdr (:) = wx (:) dbdz (:) = wy (:) dbdp (:) = wz (:) RETURN END SUBROUTINE mgval2 !> A subroutine that interpolates normalized flux !! on a given coordinate, (\\f$R, \\phi, Z\\f$) !! @param[in] r \\f$ R \\f$ [m] !! @param[in] phi \\f$ \\phi \\f$ [rad] !! @param[in] z \\f$ Z \\f$ [m] !! @param[out] s normalized flux SUBROUTINE mgval3 ( r , phi , z , & ! (in) & s & ! (out) & ) IMPLICIT NONE REAL ( RP ), INTENT ( IN ) :: r , & ! major radius in computational region [m] & phi , & ! toroidal angle in computational region [rad] & z ! height in computational region [m] REAL ( RP ), INTENT ( OUT ) :: s ! flux label INTEGER :: iphi REAL ( RP ) :: phi1 , & & xd ( 3 ), & & w0 ( l3d ) iphi = phi / pi2m phi1 = phi - pi2m * iphi IF ( phi1 < 0.0_RP ) phi1 = phi1 + pi2m IF ( phi1 >= pi2m ) phi1 = phi1 - pi2m xd ( 1 ) = r xd ( 2 ) = z xd ( 3 ) = phi1 CALL spl3df ( xd (:), w0 (:)) s = w0 ( 5 ) RETURN END SUBROUTINE mgval3 SUBROUTINE polint ( xa , ya , n , x , & ! (in) & y , dy & ! (out) & ) IMPLICIT NONE !Arguments INTEGER , INTENT ( IN ) :: n REAL ( RP ), INTENT ( IN ) :: x , & & xa ( n ), & & ya ( n ) REAL ( RP ), INTENT ( OUT ) :: y , & & dy !Local variables INTEGER :: m , & & ns , & & i REAL ( RP ) :: den , & & dif , & & dift , & & ho , & & hp , & & w , & & c ( n ), & & d ( n ) ns = 1 dif = ABS ( x - xa ( 1 )) loop100 : DO i = 1 , n dift = ABS ( x - xa ( i )) IF ( dift < dif ) THEN ns = i dif = dift END IF c ( i ) = ya ( i ) d ( i ) = ya ( i ) END DO loop100 y = ya ( ns ) ns = ns - 1 loop200 : DO m = 1 , n - 1 loop210 : DO i = 1 , n - m ho = xa ( i ) - x hp = xa ( i + m ) - x w = c ( i + 1 ) - d ( i ) den = ho - hp IF ( den == 0.0_RP ) STOP 'failure in polint' den = w / den d ( i ) = hp * den c ( i ) = ho * den END DO loop210 IF ( 2 * ns < n - m ) THEN dy = c ( ns + 1 ) ELSE dy = d ( ns ) ns = ns - 1 END IF y = y + dy END DO loop200 RETURN END SUBROUTINE polint SUBROUTINE check ( status ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: status IF ( STATUS /= NF90_NOERR ) THEN PRINT * , TRIM ( NF90_STRERROR ( status )) STOP \"Stopped\" END IF END SUBROUTINE check END MODULE cylindrical_coord_mod","tags":"","loc":"sourcefile/cylindrical_coord_mod.f90.html"},{"title":"vessel_mod.f90 – OFIT3D","text":"Contents Modules vessel_mod Source Code vessel_mod.f90 Source Code !> @file vessel_mod.f90 !------------------------------------------------------------------------------ ! ! MODULE: vessel_mod ! !> @author !> Yasuhiro Suzuki, National Institute for Fusion Science ! ! DESCRIPTION: !> @brief !> ! ! REVISION HISTORY: !> @date 19 Apr 2020 ! !> @version Initial Version ! !------------------------------------------------------------------------------ MODULE vessel_mod USE kind_spec USE param1 , ONLY : pi , & & pi2 IMPLICIT NONE PRIVATE LOGICAL :: lvessel , & !< & lcheck_vessel , & & lintersect , & & lvessel_vtk , & & lvessel_txt INTEGER :: mtor , & & nu , & & nv CHARACTER ( LEN = 10 ) :: vessel_model = '' CHARACTER ( LEN = 300 ) :: vessel_file = 'vessel.dat' REAL ( RP ) :: pi2m , & & dtor REAL ( RP ), ALLOCATABLE :: xx (:,:), & & yy (:,:), & & zz (:,:), & & rr (:,:) PUBLIC :: lvessel , & & lcheck_vessel , & & lintersect , & & lvessel_vtk , & & vessel_model , & & vessel_file , & & nu , & & nv , & & read_vessel , & & free_mem_vessel , & & vessel , & & check_vessel , & & vessel_loss CONTAINS SUBROUTINE make_mem_vessel IMPLICIT NONE ALLOCATE ( xx ( nu , nv ), yy ( nu , nv ), zz ( nu , nv ), rr ( nu , nv )) END SUBROUTINE make_mem_vessel SUBROUTINE free_mem_vessel IMPLICIT NONE DEALLOCATE ( xx , yy , zz , rr ) END SUBROUTINE free_mem_vessel SUBROUTINE read_vessel IMPLICIT NONE SELECT CASE ( TRIM ( vessel_model )) CASE ( \"2d\" , \"2D\" ) CALL read_vessel_2d CASE ( \"old\" , \"OLD\" ) CALL read_vessel_old CASE ( \"ana\" , \"ANA\" ) CALL read_vessel_ana CASE DEFAULT CALL read_vessel_3d END SELECT IF ( lvessel_vtk ) CALL write_vessel_vtk END SUBROUTINE read_vessel SUBROUTINE read_vessel_3d IMPLICIT NONE !Local variables INTEGER :: i , & & j REAL ( RP ) :: phi READ ( 30 , * ) mtor , nu , nv pi2m = pi2 / mtor dtor = pi2m / nv nv = nv + 1 CALL make_mem_vessel DO j = 1 , nv - 1 DO i = 1 , nu READ ( 30 , * ) rr ( i , j ), zz ( i , j ) END DO END DO DO i = 1 , nu rr ( i , nv ) = rr ( i , 1 ) zz ( i , nv ) = zz ( i , 1 ) END DO DO j = 1 , nv phi = dtor * ( j - 1 ) DO i = 1 , nu xx ( i , j ) = rr ( i , j ) * COS ( phi ) yy ( i , j ) = rr ( i , j ) * SIN ( phi ) END DO END DO END SUBROUTINE read_vessel_3d SUBROUTINE read_vessel_3d_old IMPLICIT NONE !Local variables INTEGER :: i , & & j REAL ( RP ) :: phi READ ( 30 , * ) mtor , nu , nv pi2m = pi2 / mtor dtor = pi2m / ( nv - 1 ) CALL make_mem_vessel DO j = 1 , nv DO i = 1 , nu READ ( 30 , * ) rr ( i , j ), zz ( i , j ) END DO END DO DO j = 1 , nv phi = dtor * ( j - 1 ) DO i = 1 , nu xx ( i , j ) = rr ( i , j ) * COS ( phi ) yy ( i , j ) = rr ( i , j ) * SIN ( phi ) END DO END DO END SUBROUTINE read_vessel_3d_old SUBROUTINE read_vessel_old IMPLICIT NONE !Local variables INTEGER :: i , & & j READ ( 30 , * ) mtor , nu , nv pi2m = pi2 / mtor dtor = pi2m / ( nv - 1 ) CALL make_mem_vessel DO j = 1 , nv DO i = 1 , nu READ ( 30 , * ) xx ( i , j ), yy ( i , j ), zz ( i , j ), rr ( i , j ) END DO END DO END SUBROUTINE read_vessel_old SUBROUTINE read_vessel_2d IMPLICIT NONE !Local variables INTEGER :: i , & & j REAL ( RP ) :: phi REAL ( RP ), ALLOCATABLE :: r1 (:), & & z1 (:) READ ( 30 , * ) nu ALLOCATE ( r1 ( nu ), z1 ( nu )) mtor = 1 nv = 120 pi2m = pi2 / mtor dtor = pi2m / ( nv - 1 ) CALL make_mem_vessel DO i = 1 , nu READ ( 30 , * ) r1 ( i ), z1 ( i ) END DO DO j = 1 , nv phi = dtor * ( j - 1 ) DO i = 1 , nu xx ( i , j ) = r1 ( i ) * COS ( phi ) yy ( i , j ) = r1 ( i ) * SIN ( phi ) zz ( i , j ) = z1 ( i ) rr ( i , j ) = r1 ( i ) END DO END DO DEALLOCATE ( r1 , z1 ) END SUBROUTINE read_vessel_2d SUBROUTINE read_vessel_ana IMPLICIT NONE !Local variables INTEGER :: i , & & j REAL ( RP ), PARAMETER :: r0 = 3.0_RP , & & a0 = 1.2_RP REAL ( RP ) :: theta , & & dtheta , & & phi , & & r , & & z mtor = 1 nv = 121 nu = 361 pi2m = pi2 / mtor dtor = pi2m / ( nv - 1 ) dtheta = pi2 / ( nu - 1 ) CALL make_mem_vessel DO j = 1 , nv phi = dtor * ( j - 1 ) DO i = 1 , nu theta = dtheta * ( i - 1 ) r = r0 + a0 * COS ( theta ) z = a0 * SIN ( theta ) xx ( i , j ) = r * COS ( phi ) yy ( i , j ) = r * SIN ( phi ) zz ( i , j ) = z rr ( i , j ) = r END DO END DO END SUBROUTINE read_vessel_ana SUBROUTINE write_vessel_vtk IMPLICIT NONE !Local variables INTEGER :: i1 , & & i2 , & & i3 , & & i , & & j OPEN ( 300 , FILE = 'vessel.vtk' , FORM = 'formatted' , STATUS = 'unknown' ) WRITE ( 300 , '(A)' ) '# vtk DataFile Version 3.0' WRITE ( 300 , '(A)' ) 'Unstructured Grid' WRITE ( 300 , '(A)' ) 'ASCII' WRITE ( 300 , * ) WRITE ( 300 , '(A)' ) 'DATASET UNSTRUCTURED_GRID' WRITE ( 300 , '(A,I12,A)' ) 'POINTS ' , nu * nv , ' double' DO j = 1 , nv DO i = 1 , nu WRITE ( 300 , '(3(ES15.7))' ) xx ( i , j ), yy ( i , j ), zz ( i , j ) END DO END DO WRITE ( 300 , * ) WRITE ( 300 , '(A,2I12)' ) 'CELLS' , 2 * ( nv - 1 ) * ( nu - 1 ), 6 * ( nv - 1 ) * ( nu - 1 ) + 2 * ( nv - 1 ) * ( nu - 1 ) DO j = 1 , nv - 1 DO i = 1 , nu - 1 i1 = i + ( j - 1 ) * nu i2 = i1 + 1 i3 = i + j * nu WRITE ( 300 , '(I3,3I12)' ) 3 , i1 - 1 , i2 - 1 , i3 - 1 i1 = i + ( j - 1 ) * nu + 1 i2 = i + j * nu i3 = i2 + 1 WRITE ( 300 , '(I3,3I12)' ) 3 , i1 - 1 , i2 - 1 , i3 - 1 END DO END DO WRITE ( 300 , * ) WRITE ( 300 , '(A,I12)' ) 'CELL_TYPES' , 2 * ( nv - 1 ) * ( nu - 1 ) DO j = 1 , nv - 1 DO i = 1 , nu - 1 WRITE ( 300 , '(I2)' ) 5 WRITE ( 300 , '(I2)' ) 5 END DO END DO WRITE ( 300 , '(A,I12)' ) 'POINT_DATA' , nv * nu WRITE ( 300 , '(A)' ) 'SCALARS scalars float 1' WRITE ( 300 , '(A)' ) 'LOOKUP_TABLE default' DO j = 1 , nv DO i = 1 , nu WRITE ( 300 , '(ES15.7)' ) 1.0_RP END DO END DO CLOSE ( 300 ) END SUBROUTINE write_vessel_vtk SUBROUTINE write_vessel_txt IMPLICIT NONE !Local variables INTEGER :: i , & & j DO j = 1 , nv - 1 DO i = 1 , nu - 1 WRITE ( 200 , '(3ES15.7)' ) xx ( i , j ), yy ( i , j ), zz ( i , j ) WRITE ( 200 , '(3ES15.7)' ) xx ( i + 1 , j ), yy ( i + 1 , j ), zz ( i + 1 , j ) WRITE ( 200 , '(3ES15.7)' ) xx ( i , j + 1 ), yy ( i , j + 1 ), zz ( i , j + 1 ) WRITE ( 200 , '(3ES15.7)' ) xx ( i , j ), yy ( i , j ), zz ( i , j ) WRITE ( 200 , * ) WRITE ( 200 , '(3ES15.7)' ) xx ( i + 1 , j ), yy ( i + 1 , j ), zz ( i + 1 , j ) WRITE ( 200 , '(3ES15.7)' ) xx ( i , j + 1 ), yy ( i , j + 1 ), zz ( i , j + 1 ) WRITE ( 200 , '(3ES15.7)' ) xx ( i + 1 , j + 1 ), yy ( i + 1 , j + 1 ), zz ( i + 1 , j + 1 ) WRITE ( 200 , '(3ES15.7)' ) xx ( i + 1 , j ), yy ( i + 1 , j ), zz ( i + 1 , j ) WRITE ( 200 , * ) END DO WRITE ( 200 , * ) WRITE ( 200 , * ) END DO END SUBROUTINE write_vessel_txt SUBROUTINE vessel ( phi , & !(in) & r1 , z1 & !(out) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: phi REAL ( RP ), INTENT ( OUT ) :: r1 ( nu ), & & z1 ( nu ) !Local variables INTEGER :: iphi REAL ( RP ) :: phi0 , & & phi1 , & & dtor1 , & & alpha iphi = phi / pi2m phi1 = phi - pi2m * iphi IF ( phi1 < 0.0_RP ) phi1 = phi1 + pi2m IF ( phi1 >= pi2m ) phi1 = phi1 - pi2m iphi = phi1 / dtor phi0 = dtor * iphi dtor1 = phi1 - phi0 iphi = iphi + 1 alpha = dtor1 / dtor r1 (:) = rr (:, iphi ) + alpha * ( rr (:, iphi + 1 ) - rr (:, iphi )) z1 (:) = zz (:, iphi ) + alpha * ( zz (:, iphi + 1 ) - zz (:, iphi )) END SUBROUTINE vessel SUBROUTINE check_vessel ( r , phi , z , & !(in) & iout & !(out) & ) IMPLICIT NONE !Arguments INTEGER , INTENT ( OUT ) :: iout REAL ( RP ), INTENT ( IN ) :: r , & & phi , & & z !Local variables INTEGER :: iphi , & & itheta , & & i REAL ( RP ) :: theta , & & theta0 , & & theta1 , & & dtheta , & & r1 ( nu ), & & z1 ( nu ) CALL vessel ( phi , r1 , z1 ) theta = 0.0_RP theta0 = ATAN2 ( z1 ( 1 ) - z , r1 ( 1 ) - r ) IF ( theta0 < 0.0_RP ) theta0 = theta0 + pi2 DO i = 2 , nu theta1 = ATAN2 ( z1 ( i ) - z , r1 ( i ) - r ) IF ( theta1 < 0.0_RP ) theta1 = theta1 + pi2 dtheta = theta1 - theta0 IF ( dtheta > pi ) dtheta = dtheta - pi2 IF ( dtheta < - pi ) dtheta = dtheta + pi2 theta = theta + dtheta theta0 = theta1 END DO theta = theta / pi2 IF ( theta >= 0.0_RP ) THEN theta = theta + 1.0e-06_RP ELSE theta = theta - 1.0e-06_RP END IF itheta = theta iout = 0 IF ( itheta == 0 ) iout = 1 END SUBROUTINE check_vessel SUBROUTINE vessel_loss ( r0 , phi0 , z0 , r1 , phi1 , z1 , & !(in) & intersect , beta , point & !(out) & ) IMPLICIT NONE INTEGER , INTENT ( OUT ) :: intersect REAL ( RP ), INTENT ( IN ) :: r0 , & & phi0 , & & z0 , & & r1 , & & phi1 , & & z1 REAL ( RP ), INTENT ( OUT ) :: beta , & & point ( 3 ) INTEGER :: i , & & j , & & k INTEGER :: iphi0 , & & iphi1 REAL ( RP ) :: x0 , & & y0 , & & x1 , & & y1 , & & p0 , & & p1 , & & dis , & & dis_ps , & & dis_pe , & & dis_12 , & & dis_13 , & & nn ( 3 ), & & a ( 3 ), & & b ( 3 ), & & c ( 3 ), & & ab ( 3 ), & & ac ( 3 ), & & bc ( 3 ), & & ca ( 3 ), & & ps ( 3 ), & & pe ( 3 ), & & aps ( 3 ), & & ape ( 3 ), & & ap ( 3 ), & & bp ( 3 ), & & cp ( 3 ), & & abxap ( 3 ), & & bcxbp ( 3 ), & & caxcp ( 3 ) intersect = 0 iphi0 = phi0 / pi2m iphi1 = phi1 / pi2m p0 = phi0 - pi2m * iphi0 p1 = phi1 - pi2m * iphi1 IF ( p0 < 0.0_RP ) p0 = p0 + pi2m IF ( p0 >= pi2m ) p0 = p0 - pi2m IF ( p1 < 0.0_RP ) p1 = p1 + pi2m IF ( p1 >= pi2m ) p1 = p1 - pi2m iphi0 = p0 / dtor + 1 iphi1 = p1 / dtor + 1 x0 = r0 * COS ( p0 ) y0 = r0 * SIN ( p0 ) x1 = r1 * COS ( p1 ) y1 = r1 * SIN ( p1 ) ps ( 1 ) = x0 ps ( 2 ) = y0 ps ( 3 ) = z0 pe ( 1 ) = x1 pe ( 2 ) = y1 pe ( 3 ) = z1 DO k = 1 , 3 IF ( k == 1 ) THEN j = iphi0 ELSE IF ( k == 2 ) THEN j = iphi0 + 1 IF ( j == nv ) THEN j = 1 END IF ELSE j = iphi0 - 1 IF ( j == 0 ) THEN j = nv - 1 END IF END IF DO i = 1 , nu - 1 a ( 1 ) = xx ( i , j ) a ( 2 ) = yy ( i , j ) a ( 3 ) = zz ( i , j ) b ( 1 ) = xx ( i + 1 , j ) b ( 2 ) = yy ( i + 1 , j ) b ( 3 ) = zz ( i + 1 , j ) c ( 1 ) = xx ( i , j + 1 ) c ( 2 ) = yy ( i , j + 1 ) c ( 3 ) = zz ( i , j + 1 ) ab ( 1 : 3 ) = b ( 1 : 3 ) - a ( 1 : 3 ) ac ( 1 : 3 ) = c ( 1 : 3 ) - a ( 1 : 3 ) aps ( 1 : 3 ) = ps ( 1 : 3 ) - a ( 1 : 3 ) ape ( 1 : 3 ) = pe ( 1 : 3 ) - a ( 1 : 3 ) nn ( 1 ) = ab ( 2 ) * ac ( 3 ) - ab ( 3 ) * ac ( 2 ) nn ( 2 ) = ab ( 3 ) * ac ( 1 ) - ab ( 1 ) * ac ( 3 ) nn ( 3 ) = ab ( 1 ) * ac ( 2 ) - ab ( 2 ) * ac ( 1 ) dis = SQRT ( nn ( 1 ) ** 2 + nn ( 2 ) ** 2 + nn ( 3 ) ** 2 ) nn ( 1 : 3 ) = nn ( 1 : 3 ) / dis dis_ps = DOT_PRODUCT ( aps (:), nn (:)) dis_pe = DOT_PRODUCT ( ape (:), nn (:)) IF ( dis_ps * dis_pe <= 0.0_RP ) THEN beta = ABS ( dis_ps ) / ( ABS ( dis_ps ) + ABS ( dis_pe )) point ( 1 : 3 ) = ps ( 1 : 3 ) + beta * ( pe ( 1 : 3 ) - ps ( 1 : 3 )) ap ( 1 : 3 ) = point ( 1 : 3 ) - a ( 1 : 3 ) bp ( 1 : 3 ) = point ( 1 : 3 ) - b ( 1 : 3 ) cp ( 1 : 3 ) = point ( 1 : 3 ) - c ( 1 : 3 ) ab ( 1 : 3 ) = b ( 1 : 3 ) - a ( 1 : 3 ) bc ( 1 : 3 ) = c ( 1 : 3 ) - b ( 1 : 3 ) ca ( 1 : 3 ) = a ( 1 : 3 ) - c ( 1 : 3 ) abxap ( 1 ) = ab ( 2 ) * ap ( 3 ) - ab ( 3 ) * ap ( 2 ) abxap ( 2 ) = ab ( 3 ) * ap ( 1 ) - ab ( 1 ) * ap ( 3 ) abxap ( 3 ) = ab ( 1 ) * ap ( 2 ) - ab ( 2 ) * ap ( 1 ) bcxbp ( 1 ) = bc ( 2 ) * bp ( 3 ) - bc ( 3 ) * bp ( 2 ) bcxbp ( 2 ) = bc ( 3 ) * bp ( 1 ) - bc ( 1 ) * bp ( 3 ) bcxbp ( 3 ) = bc ( 1 ) * bp ( 2 ) - bc ( 2 ) * bp ( 1 ) caxcp ( 1 ) = ca ( 2 ) * cp ( 3 ) - ca ( 3 ) * cp ( 2 ) caxcp ( 2 ) = ca ( 3 ) * cp ( 1 ) - ca ( 1 ) * cp ( 3 ) caxcp ( 3 ) = ca ( 1 ) * cp ( 2 ) - ca ( 2 ) * cp ( 1 ) dis_12 = abxap ( 1 ) * bcxbp ( 1 ) + abxap ( 2 ) * bcxbp ( 2 ) + abxap ( 3 ) * bcxbp ( 3 ) dis_13 = abxap ( 1 ) * caxcp ( 1 ) + abxap ( 2 ) * caxcp ( 2 ) + abxap ( 3 ) * caxcp ( 3 ) IF ( dis_12 >= 0.0_RP . AND . dis_13 >= 0.0_RP ) THEN intersect = 1 RETURN END IF ELSE intersect = 0 END IF a ( 1 ) = xx ( i + 1 , j ) a ( 2 ) = yy ( i + 1 , j ) a ( 3 ) = zz ( i + 1 , j ) b ( 1 ) = xx ( i , j + 1 ) b ( 2 ) = yy ( i , j + 1 ) b ( 3 ) = zz ( i , j + 1 ) c ( 1 ) = xx ( i + 1 , j + 1 ) c ( 2 ) = yy ( i + 1 , j + 1 ) c ( 3 ) = zz ( i + 1 , j + 1 ) ab ( 1 : 3 ) = b ( 1 : 3 ) - a ( 1 : 3 ) ac ( 1 : 3 ) = c ( 1 : 3 ) - a ( 1 : 3 ) aps ( 1 : 3 ) = ps ( 1 : 3 ) - a ( 1 : 3 ) ape ( 1 : 3 ) = pe ( 1 : 3 ) - a ( 1 : 3 ) nn ( 1 ) = ab ( 2 ) * ac ( 3 ) - ab ( 3 ) * ac ( 2 ) nn ( 2 ) = ab ( 3 ) * ac ( 1 ) - ab ( 1 ) * ac ( 3 ) nn ( 3 ) = ab ( 1 ) * ac ( 2 ) - ab ( 2 ) * ac ( 1 ) dis = SQRT ( nn ( 1 ) ** 2 + nn ( 2 ) ** 2 + nn ( 3 ) ** 2 ) nn ( 1 : 3 ) = nn ( 1 : 3 ) / dis dis_ps = DOT_PRODUCT ( aps (:), nn (:)) dis_pe = DOT_PRODUCT ( ape (:), nn (:)) IF ( dis_ps * dis_pe <= 0.0_RP ) THEN beta = ABS ( dis_ps ) / ( ABS ( dis_ps ) + ABS ( dis_pe )) point ( 1 : 3 ) = ps ( 1 : 3 ) + beta * ( pe ( 1 : 3 ) - ps ( 1 : 3 )) ap ( 1 : 3 ) = point ( 1 : 3 ) - a ( 1 : 3 ) bp ( 1 : 3 ) = point ( 1 : 3 ) - b ( 1 : 3 ) cp ( 1 : 3 ) = point ( 1 : 3 ) - c ( 1 : 3 ) ab ( 1 : 3 ) = b ( 1 : 3 ) - a ( 1 : 3 ) bc ( 1 : 3 ) = c ( 1 : 3 ) - b ( 1 : 3 ) ca ( 1 : 3 ) = a ( 1 : 3 ) - c ( 1 : 3 ) abxap ( 1 ) = ab ( 2 ) * ap ( 3 ) - ab ( 3 ) * ap ( 2 ) abxap ( 2 ) = ab ( 3 ) * ap ( 1 ) - ab ( 1 ) * ap ( 3 ) abxap ( 3 ) = ab ( 1 ) * ap ( 2 ) - ab ( 2 ) * ap ( 1 ) bcxbp ( 1 ) = bc ( 2 ) * bp ( 3 ) - bc ( 3 ) * bp ( 2 ) bcxbp ( 2 ) = bc ( 3 ) * bp ( 1 ) - bc ( 1 ) * bp ( 3 ) bcxbp ( 3 ) = bc ( 1 ) * bp ( 2 ) - bc ( 2 ) * bp ( 1 ) caxcp ( 1 ) = ca ( 2 ) * cp ( 3 ) - ca ( 3 ) * cp ( 2 ) caxcp ( 2 ) = ca ( 3 ) * cp ( 1 ) - ca ( 1 ) * cp ( 3 ) caxcp ( 3 ) = ca ( 1 ) * cp ( 2 ) - ca ( 2 ) * cp ( 1 ) dis_12 = abxap ( 1 ) * bcxbp ( 1 ) + abxap ( 2 ) * bcxbp ( 2 ) + abxap ( 3 ) * bcxbp ( 3 ) dis_13 = abxap ( 1 ) * caxcp ( 1 ) + abxap ( 2 ) * caxcp ( 2 ) + abxap ( 3 ) * caxcp ( 3 ) IF ( dis_12 >= 0.0_RP . AND . dis_13 >= 0.0_RP ) THEN intersect = 1 RETURN END IF ELSE intersect = 0 END IF END DO END DO END SUBROUTINE vessel_loss END MODULE vessel_mod","tags":"","loc":"sourcefile/vessel_mod.f90.html"},{"title":"mesor.f90 – OFIT3D","text":"Contents Subroutines mesor Source Code mesor.f90 Source Code SUBROUTINE mesor ( rstart , pstart , zstart , w_in , stalam , dt_in , nstep , & !(in) & loss , loss_time , trap & !(out) & ) USE kind_spec USE param1 , ONLY : pi , & & qom_a USE param2 , ONLY : lvessel , & & lmonitor , & & interval USE cylindrical_coord_mod , ONLY : pi2m , & & mgval1 USE vessel_mod , ONLY : check_vessel , & & vessel_loss IMPLICIT NONE !Arguments INTEGER , INTENT ( IN ) :: nstep INTEGER , INTENT ( OUT ) :: loss , & & trap REAL ( RP ), INTENT ( IN ) :: rstart , & & pstart , & & zstart , & & w_in , & & stalam , & & dt_in REAL ( RP ), INTENT ( OUT ) :: loss_time !Local variables INTEGER :: i REAL ( RP ) :: v , & & vpara , & & vperp , & & bdotv , & & vperp2 , & & vperpr , & & vperpp , & & vperpz , & & br , & & bp , & & bz , & & bb , & & mu , & & wtotl , & & werror , & & wpara , & & wperp , rho_perp , rho ( 3 ) CHARACTER ( LEN = 100 ) :: fmt !For Runge-Kutta INTEGER :: iout REAL ( RP ) :: t , & & y ( 6 ) !External function EXTERNAL :: fun_mesor !For loss detection INTEGER :: ivessel , & & idivertor REAL ( RP ) :: dt_loss , & & y0 ( 3 ), & & loss_points ( 3 ) CALL mgval1 ( rstart , pstart , zstart , br , bp , bz , bb ) IF ( bb == 0.0_RP ) THEN PRINT * , 'Initial value(follow) is invalid.' RETURN END IF v = SQRT ( 2 * w_in * qom_a ) vpara = v * COS ( stalam * pi ) vperp = v * SIN ( stalam * pi ) fmt = '(A20, ES12.4)' rho_perp = vperp / bb / qom_a PRINT * PRINT * , '------------------------------------' PRINT fmt , '  gyro radius [m] : ' , rho_perp y ( 1 ) = 0.0_RP + vpara * br / bb y ( 2 ) = 0.0_RP + vpara * bp / bb / rstart y ( 3 ) = - vperp + vpara * bz / bb y ( 4 ) = rstart y ( 5 ) = pstart y ( 6 ) = zstart t = 0.0_RP loss = 0 trap = 0 rho ( 1 ) = - ( rstart * y ( 3 ) * bz - y ( 2 ) * bp ) / bb ** 2 / qom_a rho ( 2 ) = - ( y ( 2 ) * br - y ( 1 ) * bz ) / bb ** 2 / qom_a rho ( 3 ) = - ( y ( 1 ) * bp - rstart * y ( 3 ) * br ) / bb ** 2 / qom_a PRINT fmt , '  rho(R) [m]      : ' , rho ( 1 ) PRINT fmt , '  rho(phi) [rad]  : ' , rho ( 2 ) / rstart PRINT fmt , '  rho(Z) [m]      : ' , rho ( 3 ) PRINT fmt , '  r_c(R) [m]      : ' , rstart - rho ( 1 ) PRINT fmt , '  r_c(phi) [rad]  : ' , pstart - rho ( 2 ) / rstart PRINT fmt , '  r_c(phi) [a.u.] : ' , ( pstart - rho ( 2 ) / rstart ) / pi2m PRINT fmt , '  r_c(Z) [m]      : ' , zstart - rho ( 3 ) PRINT * IF ( lmonitor ) then bdotv = ( br * y ( 1 ) + bp * y ( 2 ) * y ( 4 ) + bz * y ( 3 )) / bb vperpr = y ( 1 ) - bdotv * br / bb vperpp = y ( 2 ) - bdotv * bp / ( bb * y ( 4 )) vperpz = y ( 3 ) - bdotv * bz / bb vperp2 = vperpr ** 2 + vperpp ** 2 * y ( 4 ) ** 2 + vperpz ** 2 mu = 0.5_RP * vperp2 / ( bb * qom_a ) wpara = 0.5_RP * bdotv * ABS ( bdotv ) / qom_a wperp = mu * bb WRITE ( 50 , '(20(ES22.12, A1))' ) t , ',' , & ! 1: t=0 [s] & y ( 4 ) * COS ( y ( 5 )), ',' , & ! 2: X@t=0 [m] & y ( 4 ) * SIN ( y ( 5 )), ',' , & ! 3: Y@t=0 [m] & y ( 6 ), ',' , & ! 4: Z@t=0 [m] & y ( 4 ), ',' , & ! 5: R@t=0 [m] & y ( 5 ), ',' , & ! 6: phi@t=0 [rad] & mu , ',' , & ! 7: mu@t=0 & bb , ',' , & ! 8: B@t=0 [T] & wpara , ',' , & ! 9: W_||@t=0 [eV] & wperp , ',' , & ! 10: W_perp@t=0 [eV] & w_in , ',' , & ! 11: initial W@t=0 [eV] & 0.0_RP , ',' ! 12: relative error of W@t=0 END IF loop10 : DO i = 1 , nstep !  ------------------------------------------------- CALL rkg6 ( t , dt_in , 6 , fun_mesor , y (:), iout ) !  ------------------------------------------------- !CALL check_vessel(y(4), y(5), y(6), ivessel) IF ( ivessel == 1 ) THEN IF ( lmonitor ) THEN CALL mgval1 ( y ( 4 ), y ( 5 ), y ( 6 ), br , bp , bz , bb ) bdotv = ( br * y ( 1 ) + bp * y ( 2 ) * y ( 4 ) + bz * y ( 3 )) / bb vperpr = y ( 1 ) - bdotv * br / bb vperpp = y ( 2 ) - bdotv * bp / ( bb * y ( 4 )) vperpz = y ( 3 ) - bdotv * bz / bb vperp2 = vperpr ** 2 + vperpp ** 2 * y ( 4 ) ** 2 + vperpz ** 2 mu = 0.5_RP * vperp2 / ( bb * qom_a ) wpara = 0.5_RP * bdotv * ABS ( bdotv ) / qom_a wperp = mu * bb wtotl = ABS ( wpara ) + wperp werror = ( wtotl - w_in ) / w_in WRITE ( 50 , '(20(ES22.12, A1))' ) t + dt_in , ',' , & ! 1: t [s] & y ( 4 ) * COS ( y ( 5 )), ',' , & ! 2: X [m] & y ( 4 ) * SIN ( y ( 5 )), ',' , & ! 3: Y [m] & y ( 6 ), ',' , & ! 4: Z [m] & y ( 4 ), ',' , & ! 5: R [m] & y ( 5 ), ',' , & ! 6: phi [rad] & mu , ',' , & ! 7: mu & bb , ',' , & ! 8: B [T] & wpara , ',' , & ! 9: W_|| [eV] & wperp , ',' , & ! 10: W_perp [eV] & wtotl , ',' , & ! 11: total W [eV] & werror , ',' ! 12: relative error of W END IF loss = 1 loss_time = t + dt_in RETURN END IF IF ( lmonitor ) THEN IF ( mod ( i , interval ) == 0 ) THEN CALL mgval1 ( y ( 4 ), y ( 5 ), y ( 6 ), br , bp , bz , bb ) bdotv = ( br * y ( 1 ) + bp * y ( 2 ) * y ( 4 ) + bz * y ( 3 )) / bb vperpr = y ( 1 ) - bdotv * br / bb vperpp = y ( 2 ) - bdotv * bp / ( bb * y ( 4 )) vperpz = y ( 3 ) - bdotv * bz / bb vperp2 = vperpr ** 2 + vperpp ** 2 * y ( 4 ) ** 2 + vperpz ** 2 mu = 0.5_RP * vperp2 / ( bb * qom_a ) wpara = 0.5_RP * bdotv * ABS ( bdotv ) / qom_a wperp = mu * bb wtotl = ABS ( wpara ) + wperp werror = ( wtotl - w_in ) / w_in WRITE ( 50 , '(20(ES22.12, A1))' ) t + dt_in , ',' , & ! 1: t [s] & y ( 4 ) * COS ( y ( 5 )), ',' , & ! 2: X [m] & y ( 4 ) * SIN ( y ( 5 )), ',' , & ! 3: Y [m] & y ( 6 ), ',' , & ! 4: Z [m] & y ( 4 ), ',' , & ! 5: R [m] & y ( 5 ), ',' , & ! 6: phi [rad] & mu , ',' , & ! 7: mu & bb , ',' , & ! 8: B [T] & wpara , ',' , & ! 9: W_|| [eV] & wperp , ',' , & ! 10: W_perp [eV] & wtotl , ',' , & ! 11: total W [eV] & werror , ',' ! 12: relative error of W END IF END IF bdotv = ( br * y ( 1 ) + bp * y ( 2 ) * y ( 4 ) + bz * y ( 3 )) / bb IF (( i /= 1 ) . and . ( bdotv * vpara < 0.0_RP )) THEN trap = 1 END IF t = t + dt_in END DO loop10 loss_time = t RETURN END SUBROUTINE mesor","tags":"","loc":"sourcefile/mesor.f90.html"},{"title":"spline_mod.f90 – OFIT3D","text":"Contents Modules spline_mod Source Code spline_mod.f90 Source Code !=spline_mod.f90 ! !==Version ! ! $Revision: $ ! $Id: $ ! !==Overview ! !    This subroutine is written by Yasuhiro Suzuki !        at National Institute for Fusion Science ( NIFS ) !         2010/12/12 ! !    Based program is wrtten by T.Watanabe !        at NIFS !         1990/8/29 ! !  Multi-Dimensional Spline Interpolation  ( 4th ) ! !  This module contains following public routines. ! !   1. splin1 : Initializing 1-dimensional interpolation. !   2. splin2 : Initializing 2-dimensional interpolation. !   3. splin3 : Initializing 3-dimensional interpolation. !   4. sp1df  : 1-dimensional interpolation. !   5. sp1dd  : 1-dimensional interpolation and derivation along X. !   6. sp2df  : 2-dimensional interpolation. !   7. sp2dd  : 2-dimensional interpolation and derivation along X and Y. !   8. sp3df  : 3-dimensional interpolation. !   9. sp3dd  : 3-dimensional interpolation and derivation along X, Y and Z. ! ! !              xsc                          xlc !               <------------- x ------------> !      1--+--+--4-------------------------nxxm-3-+--+--nxxm  a(i) !      +--------+----------------------------+---------+ !               <----------------------------> ! ! ! !==Reference ! !  \"Multi-Dimension Highly Accurate Spline Interpolation Method\" !  by T.Watanabe  The Japan Society for Industrial and Applied Mathmatics ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! MODULE spline_mod IMPLICIT NONE PRIVATE INTEGER , PRIVATE , PARAMETER :: RP = SELECTED_REAL_KIND ( 15 ) INTEGER :: l1d = 1 , & & l2d = 1 , & & l3d = 3 , & & nx1d , & & nx2d , & & ny2d , & & nx3d , & & ny3d , & & nz3d REAL ( RP ), PARAMETER :: c411 = - 5.0_RP / 204 8.0_RP , & & c412 = 961 1.0_RP / 73728 0.0_RP , & & c413 = 25 9.0_RP / 2304 0.0_RP , & & c414 = - 662 9.0_RP / 4608 0.0_RP , & & c415 = - 7.0_RP / 115 2.0_RP , & & c416 = 81 9.0_RP / 102 4.0_RP , & & c417 = 1.0_RP / 144 0.0_RP , & & c418 = - 106 7.0_RP / 36 0.0_RP , & & c41a = 394 1.0_RP / 57 6.0_RP , & & c41c = - 160 3.0_RP / 18 0.0_RP , & & c41e = 90 1.0_RP / 18 0.0_RP , & & c421 = 4 9.0_RP / 204 8.0_RP , & & c422 = - 7073 3.0_RP / 73728 0.0_RP , & & c423 = - 49 9.0_RP / 460 8.0_RP , & & c424 = 4736 3.0_RP / 4608 0.0_RP , & & c425 = 5 9.0_RP / 115 2.0_RP , & & c426 = - 8612 3.0_RP / 1536 0.0_RP , & & c427 = - 1.0_RP / 28 8.0_RP , & & c431 = - 24 5.0_RP / 204 8.0_RP , & & c432 = 2775 9.0_RP / 8192 0.0_RP , & & c433 = 129 9.0_RP / 256 0.0_RP , & & c434 = - 5056 3.0_RP / 1536 0.0_RP , & & c435 = - 1 5.0_RP / 12 8.0_RP , & & c436 = 5172 5.0_RP / 307 2.0_RP , & & c437 = 1.0_RP / 16 0.0_RP , & & c441 = 122 5.0_RP / 204 8.0_RP , & & c442 = - 24007 7.0_RP / 14745 6.0_RP , & & c443 = - 189 1.0_RP / 460 8.0_RP , & & c444 = 5293 1.0_RP / 921 6.0_RP , & & c445 = 8 3.0_RP / 115 2.0_RP , & & c446 = - 8625 1.0_RP / 307 2.0_RP , & & c447 = - 1.0_RP / 28 8.0_RP , & & d413 = c413 * 2.0_RP , & & d423 = c423 * 2.0_RP , & & d433 = c433 * 2.0_RP , & & d443 = c443 * 2.0_RP , & & d414 = c414 * 3.0_RP , & & d424 = c424 * 3.0_RP , & & d434 = c434 * 3.0_RP , & & d444 = c444 * 3.0_RP , & & d415 = c415 * 4.0_RP , & & d425 = c425 * 4.0_RP , & & d435 = c435 * 4.0_RP , & & d445 = c445 * 4.0_RP , & & d416 = c416 * 5.0_RP , & & d426 = c426 * 5.0_RP , & & d436 = c436 * 5.0_RP , & & d446 = c446 * 5.0_RP , & & d417 = c417 * 6.0_RP , & & d427 = c427 * 6.0_RP , & & d437 = c437 * 6.0_RP , & & d447 = c447 * 6.0_RP , & & d418 = c418 * 7.0_RP , & & d41a = c41a * 9.0_RP , & & d41c = c41c * 1 1.0_RP , & & d41e = c41e * 1 3.0_RP REAL ( RP ) :: h1x , & & h2x , & & h2y , & & h3x , & & h3y , & & h3z , & & xs1 , & & xs2 , & & ys2 , & & xs3 , & & ys3 , & & zs3 , & & xl1 , & & xl2 , & & yl2 , & & xl3 , & & yl3 , & & zl3 REAL ( RP ), ALLOCATABLE :: f1d (:,:), & & f2d (:,:,:), & & f3d (:,:,:,:) !$acc declare create (f3d) PUBLIC :: l1d , & & l2d , & & l3d , & & nx1d , & & nx2d , & & ny2d , & & nx3d , & & ny3d , & & nz3d , & & f1d , & & f2d , & & f3d , & & splin1 , & & splin2 , & & splin3 , & & spl1df , & & spl1dd , & & spl2df , & & spl2dd , & & spl3df , & & spl3dd CONTAINS SUBROUTINE splin1 ( xsd , xld & ! (in) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: xsd , & & xld xs1 = xsd xl1 = xld h1x = ( xld - xsd ) / ( nx1d - 1 ) END SUBROUTINE splin1 SUBROUTINE splin2 ( xsd , xld , ysd , yld & ! (in) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: xsd , & & xld , & & ysd , & & yld xs2 = xsd xl2 = xld h2x = ( xld - xsd ) / ( nx2d - 1 ) ys2 = ysd yl2 = yld h2y = ( yld - ysd ) / ( ny2d - 1 ) END SUBROUTINE splin2 SUBROUTINE splin3 ( xsd , xld , ysd , yld , zsd , zld & ! (in) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: xsd , & & xld , & & ysd , & & yld , & & zsd , & & zld xs3 = xsd xl3 = xld h3x = ( xld - xsd ) / ( nx3d - 1 ) ys3 = ysd yl3 = yld h3y = ( yld - ysd ) / ( ny3d - 1 ) zs3 = zsd zl3 = zld h3z = ( zld - zsd ) / ( nz3d - 1 ) END SUBROUTINE splin3 SUBROUTINE spl1df ( xd , & !(in) & w0 & !(out) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: xd REAL ( RP ), INTENT ( OUT ) :: w0 ( l1d ) !Local variables INTEGER , PARAMETER :: m2 = 8 INTEGER :: l , & & ix REAL ( RP ) :: x , & & ux , & & usx , & & x400 , & & x41m , & & x41p , & & x42m , & & x42p , & & x43m , & & x43p , & & x44m , & & x44p w0 (:) = 0.0_RP x = xd IF ( x < xs1 ) RETURN IF ( x > xl1 ) RETURN ux = ( x - xs1 ) / h1x ix = ux IF ( ix >= nx1d - 1 ) THEN ix = nx1d - 2 ux = nx1d - 1 END IF ux = ux - ix - 0.5_RP usx = ux * ux !###########       case for m == 4       ############################# x400 = ((( c41e * usx + c41c ) * usx + c41a ) * usx + c418 ) * usx x41m = ((( x400 + c416 ) * usx + c414 ) * usx + c412 ) * ux x41p = (( c417 * usx + c415 ) * usx + c413 ) * usx + c411 x42m = ((( - x400 * 7.0_RP + c426 ) * usx + c424 ) * usx + c422 ) * ux x42p = (( c427 * usx + c425 ) * usx + c423 ) * usx + c421 x43m = ((( x400 * 2 1.0_RP + c436 ) * usx + c434 ) * usx + c432 ) * ux x43p = (( c437 * usx + c435 ) * usx + c433 ) * usx + c431 x44m = ((( - x400 * 3 5.0_RP + c446 ) * usx + c444 ) * usx + c442 ) * ux x44p = (( c447 * usx + c445 ) * usx + c443 ) * usx + c441 loop010 : DO l = 1 , l1d w0 ( l ) = (( x41p + x41m ) * f1d ( l , ix - 2 ) & & + ( x42p + x42m ) * f1d ( l , ix - 1 ) & & + ( x43p + x43m ) * f1d ( l , ix ) & & + ( x44p + x44m ) * f1d ( l , ix + 1 ) & & + ( x44p - x44m ) * f1d ( l , ix + 2 ) & & + ( x43p - x43m ) * f1d ( l , ix + 3 ) & & + ( x42p - x42m ) * f1d ( l , ix + 4 ) & & + ( x41p - x41m ) * f1d ( l , ix + 5 )) END DO loop010 END SUBROUTINE spl1df SUBROUTINE spl1dd ( xd , & !(in) & w0 , wx & !(out) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: xd ( 2 ) REAL ( RP ), INTENT ( OUT ) :: w0 ( l1d ), & & wx ( l1d ) !Local variables INTEGER , PARAMETER :: m2 = 8 INTEGER :: l , & & ix REAL ( RP ) :: x , & & ux , & & usx , & & x400 , & & x41m , & & x41p , & & x42m , & & x42p , & & x43m , & & x43p , & & x44m , & & x44p , & & dx400 , & & dx41m , & & dx41p , & & dx42m , & & dx42p , & & dx43m , & & dx43p , & & dx44m , & & dx44p w0 (:) = 0.0_RP wx (:) = 0.0_RP x = xd ( 1 ) IF ( x < xs1 ) RETURN IF ( x > xl1 ) RETURN ux = ( x - xs1 ) / h1x ix = ux IF ( ix >= nx1d - 1 ) THEN ix = nx1d - 2 ux = nx1d - 1 END IF ux = ux - ix - 0.5_RP usx = ux * ux !############       case for m == 4       ########################### x400 = ((( c41e * usx + c41c ) * usx + c41a ) * usx + c418 ) * usx dx400 = ((( d41e * usx + d41c ) * usx + d41a ) * usx + d418 ) * usx x41m = ((( x400 + c416 ) * usx + c414 ) * usx + c412 ) * ux x41p = (( c417 * usx + c415 ) * usx + c413 ) * usx + c411 dx41m = (( dx400 + d416 ) * usx + d414 ) * usx + c412 dx41p = (( d417 * usx + d415 ) * usx + d413 ) * ux x42m = ((( - x400 * 7.0_RP + c426 ) * usx + c424 ) * usx + c422 ) * ux x42p = (( c427 * usx + c425 ) * usx + c423 ) * usx + c421 dx42m = (( - dx400 * 7.0_RP + d426 ) * usx + d424 ) * usx + c422 dx42p = (( d427 * usx + d425 ) * usx + d423 ) * ux x43m = ((( x400 * 2 1.0_RP + c436 ) * usx + c434 ) * usx + c432 ) * ux x43p = (( c437 * usx + c435 ) * usx + c433 ) * usx + c431 dx43m = (( dx400 * 2 1.0_RP + d436 ) * usx + d434 ) * usx + c432 dx43p = (( d437 * usx + d435 ) * usx + d433 ) * ux x44m = ((( - x400 * 3 5.0_RP + c446 ) * usx + c444 ) * usx + c442 ) * ux x44p = (( c447 * usx + c445 ) * usx + c443 ) * usx + c441 dx44m = (( - dx400 * 3 5.0_RP + d446 ) * usx + d444 ) * usx + c442 dx44p = (( d447 * usx + d445 ) * usx + d443 ) * ux loop010 : DO l = 1 , l1d w0 ( l ) = (( x41p + x41m ) * f1d ( l , ix - 2 ) & & + ( x42p + x42m ) * f1d ( l , ix - 1 ) & & + ( x43p + x43m ) * f1d ( l , ix ) & & + ( x44p + x44m ) * f1d ( l , ix + 1 ) & & + ( x44p - x44m ) * f1d ( l , ix + 2 ) & & + ( x43p - x43m ) * f1d ( l , ix + 3 ) & & + ( x42p - x42m ) * f1d ( l , ix + 4 ) & & + ( x41p - x41m ) * f1d ( l , ix + 5 )) wx ( l ) = (( dx41p + dx41m ) * f1d ( l , ix - 2 ) & & + ( dx42p + dx42m ) * f1d ( l , ix - 1 ) & & + ( dx43p + dx43m ) * f1d ( l , ix ) & & + ( dx44p + dx44m ) * f1d ( l , ix + 1 ) & & + ( dx44p - dx44m ) * f1d ( l , ix + 2 ) & & + ( dx43p - dx43m ) * f1d ( l , ix + 3 ) & & + ( dx42p - dx42m ) * f1d ( l , ix + 4 ) & & + ( dx41p - dx41m ) * f1d ( l , ix + 5 )) wx ( l ) = wx ( l ) / h1x END DO loop010 END SUBROUTINE spl1dd SUBROUTINE spl2df ( xd , & !(in) & w0 & !(out) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: xd ( 2 ) REAL ( RP ), INTENT ( OUT ) :: w0 ( l2d ) !Local variables INTEGER , PARAMETER :: m2 = 8 INTEGER :: l , & & my , & & ly , & & ix , & & iy REAL ( RP ) :: x , & & y , & & ux , & & uy , & & usx , & & usy , & & x400 , & & y400 , & & x41m , & & y41m , & & x41p , & & y41p , & & x42m , & & y42m , & & x42p , & & y42p , & & x43m , & & y43m , & & x43p , & & y43p , & & x44m , & & y44m , & & x44p , & & y44p , & & cy ( 8 ) w0 (:) = 0.0_RP x = xd ( 1 ) IF ( x < xs2 ) RETURN IF ( x > xl2 ) RETURN y = xd ( 2 ) IF ( y < ys2 ) RETURN IF ( y > yl2 ) RETURN ux = ( x - xs2 ) / h2x ix = ux IF ( ix >= nx2d - 1 ) THEN ix = nx2d - 2 ux = nx2d - 1 END IF uy = ( y - ys2 ) / h2y iy = uy IF ( iy >= ny2d - 1 ) THEN iy = ny2d - 2 uy = ny2d - 1 END IF ux = ux - ix - 0.5_RP uy = uy - iy - 0.5_RP usx = ux * ux usy = uy * uy !###########       case for m == 4       ############################# x400 = ((( c41e * usx + c41c ) * usx + c41a ) * usx + c418 ) * usx y400 = ((( c41e * usy + c41c ) * usy + c41a ) * usy + c418 ) * usy x41m = ((( x400 + c416 ) * usx + c414 ) * usx + c412 ) * ux x41p = (( c417 * usx + c415 ) * usx + c413 ) * usx + c411 y41m = ((( y400 + c416 ) * usy + c414 ) * usy + c412 ) * uy y41p = (( c417 * usy + c415 ) * usy + c413 ) * usy + c411 x42m = ((( - x400 * 7.0_RP + c426 ) * usx + c424 ) * usx + c422 ) * ux x42p = (( c427 * usx + c425 ) * usx + c423 ) * usx + c421 y42m = ((( - y400 * 7.0_RP + c426 ) * usy + c424 ) * usy + c422 ) * uy y42p = (( c427 * usy + c425 ) * usy + c423 ) * usy + c421 x43m = ((( x400 * 2 1.0_RP + c436 ) * usx + c434 ) * usx + c432 ) * ux x43p = (( c437 * usx + c435 ) * usx + c433 ) * usx + c431 y43m = ((( y400 * 2 1.0_RP + c436 ) * usy + c434 ) * usy + c432 ) * uy y43p = (( c437 * usy + c435 ) * usy + c433 ) * usy + c431 x44m = ((( - x400 * 3 5.0_RP + c446 ) * usx + c444 ) * usx + c442 ) * ux x44p = (( c447 * usx + c445 ) * usx + c443 ) * usx + c441 y44m = ((( - y400 * 3 5.0_RP + c446 ) * usy + c444 ) * usy + c442 ) * uy y44p = (( c447 * usy + c445 ) * usy + c443 ) * usy + c441 cy ( 1 ) = y41p + y41m cy ( 2 ) = y42p + y42m cy ( 3 ) = y43p + y43m cy ( 4 ) = y44p + y44m cy ( 5 ) = y44p - y44m cy ( 6 ) = y43p - y43m cy ( 7 ) = y42p - y42m cy ( 8 ) = y41p - y41m loop010 : DO l = 1 , l2d loop020 : DO my = 1 , m2 ly = iy + my - 3 w0 ( l ) = (( x41p + x41m ) * f2d ( l , ix - 2 , ly ) & & + ( x42p + x42m ) * f2d ( l , ix - 1 , ly ) & & + ( x43p + x43m ) * f2d ( l , ix , ly ) & & + ( x44p + x44m ) * f2d ( l , ix + 1 , ly ) & & + ( x44p - x44m ) * f2d ( l , ix + 2 , ly ) & & + ( x43p - x43m ) * f2d ( l , ix + 3 , ly ) & & + ( x42p - x42m ) * f2d ( l , ix + 4 , ly ) & & + ( x41p - x41m ) * f2d ( l , ix + 5 , ly )) * cy ( my ) + w0 ( l ) END DO loop020 END DO loop010 END SUBROUTINE spl2df SUBROUTINE spl2dd ( xd , & !(in) & w0 , wx , wy & !(out) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: xd ( 2 ) REAL ( RP ), INTENT ( OUT ) :: w0 ( l2d ), & & wx ( l2d ), & & wy ( l2d ) !Local variables INTEGER , PARAMETER :: m2 = 8 INTEGER :: l , & & ix , & & iy , & & my , & & ly REAL ( RP ) :: x , & & y , & & ux , & & uy , & & usx , & & usy , & & x400 , & & y400 , & & x41m , & & y41m , & & x41p , & & y41p , & & x42m , & & y42m , & & x42p , & & y42p , & & x43m , & & y43m , & & x43p , & & y43p , & & x44m , & & y44m , & & x44p , & & y44p , & & dx400 , & & dy400 , & & dx41m , & & dy41m , & & dx41p , & & dy41p , & & dx42m , & & dy42m , & & dx42p , & & dy42p , & & dx43m , & & dy43m , & & dx43p , & & dy43p , & & dx44m , & & dy44m , & & dx44p , & & dy44p , & & w0l , & & wxl , & & wyl , & & ww , & & cy ( 8 ), & & dy ( 8 ) w0 (:) = 0.0_RP wx (:) = 0.0_RP wy (:) = 0.0_RP x = xd ( 1 ) IF ( x < xs2 ) RETURN IF ( x > xl2 ) RETURN y = xd ( 2 ) IF ( y < ys2 ) RETURN IF ( y > yl2 ) RETURN ux = ( x - xs2 ) / h2x ix = ux IF ( ix >= nx2d - 1 ) THEN ix = nx2d - 2 ux = nx2d - 1 END IF uy = ( y - ys2 ) / h2y iy = uy IF ( iy >= ny2d - 1 ) THEN iy = ny2d - 2 uy = ny2d - 1 END IF ux = ux - ix - 0.5_RP uy = uy - iy - 0.5_RP usx = ux * ux usy = uy * uy !############       case for m == 4       ########################### x400 = ((( c41e * usx + c41c ) * usx + c41a ) * usx + c418 ) * usx y400 = ((( c41e * usy + c41c ) * usy + c41a ) * usy + c418 ) * usy dx400 = ((( d41e * usx + d41c ) * usx + d41a ) * usx + d418 ) * usx dy400 = ((( d41e * usy + d41c ) * usy + d41a ) * usy + d418 ) * usy x41m = ((( x400 + c416 ) * usx + c414 ) * usx + c412 ) * ux y41m = ((( y400 + c416 ) * usy + c414 ) * usy + c412 ) * uy x41p = (( c417 * usx + c415 ) * usx + c413 ) * usx + c411 y41p = (( c417 * usy + c415 ) * usy + c413 ) * usy + c411 dx41m = (( dx400 + d416 ) * usx + d414 ) * usx + c412 dy41m = (( dy400 + d416 ) * usy + d414 ) * usy + c412 dx41p = (( d417 * usx + d415 ) * usx + d413 ) * ux dy41p = (( d417 * usy + d415 ) * usy + d413 ) * uy x42m = ((( - x400 * 7.0_RP + c426 ) * usx + c424 ) * usx + c422 ) * ux y42m = ((( - y400 * 7.0_RP + c426 ) * usy + c424 ) * usy + c422 ) * uy x42p = (( c427 * usx + c425 ) * usx + c423 ) * usx + c421 y42p = (( c427 * usy + c425 ) * usy + c423 ) * usy + c421 dx42m = (( - dx400 * 7.0_RP + d426 ) * usx + d424 ) * usx + c422 dy42m = (( - dy400 * 7.0_RP + d426 ) * usy + d424 ) * usy + c422 dx42p = (( d427 * usx + d425 ) * usx + d423 ) * ux dy42p = (( d427 * usy + d425 ) * usy + d423 ) * uy x43m = ((( x400 * 2 1.0_RP + c436 ) * usx + c434 ) * usx + c432 ) * ux y43m = ((( y400 * 2 1.0_RP + c436 ) * usy + c434 ) * usy + c432 ) * uy x43p = (( c437 * usx + c435 ) * usx + c433 ) * usx + c431 y43p = (( c437 * usy + c435 ) * usy + c433 ) * usy + c431 dx43m = (( dx400 * 2 1.0_RP + d436 ) * usx + d434 ) * usx + c432 dy43m = (( dy400 * 2 1.0_RP + d436 ) * usy + d434 ) * usy + c432 dx43p = (( d437 * usx + d435 ) * usx + d433 ) * ux dy43p = (( d437 * usy + d435 ) * usy + d433 ) * uy x44m = ((( - x400 * 3 5.0_RP + c446 ) * usx + c444 ) * usx + c442 ) * ux y44m = ((( - y400 * 3 5.0_RP + c446 ) * usy + c444 ) * usy + c442 ) * uy x44p = (( c447 * usx + c445 ) * usx + c443 ) * usx + c441 y44p = (( c447 * usy + c445 ) * usy + c443 ) * usy + c441 dx44m = (( - dx400 * 3 5.0_RP + d446 ) * usx + d444 ) * usx + c442 dy44m = (( - dy400 * 3 5.0_RP + d446 ) * usy + d444 ) * usy + c442 dx44p = (( d447 * usx + d445 ) * usx + d443 ) * ux dy44p = (( d447 * usy + d445 ) * usy + d443 ) * uy cy ( 1 ) = y41p + y41m cy ( 2 ) = y42p + y42m cy ( 3 ) = y43p + y43m cy ( 4 ) = y44p + y44m cy ( 5 ) = y44p - y44m cy ( 6 ) = y43p - y43m cy ( 7 ) = y42p - y42m cy ( 8 ) = y41p - y41m dy ( 1 ) = dy41p + dy41m dy ( 2 ) = dy42p + dy42m dy ( 3 ) = dy43p + dy43m dy ( 4 ) = dy44p + dy44m dy ( 5 ) = dy44p - dy44m dy ( 6 ) = dy43p - dy43m dy ( 7 ) = dy42p - dy42m dy ( 8 ) = dy41p - dy41m loop010 : DO l = 1 , l2d w0l = 0.0_RP wxl = 0.0_RP wyl = 0.0_RP loop020 : DO my = 1 , m2 ly = iy + my - 3 ww = (( x41p + x41m ) * f2d ( l , ix - 2 , ly ) & & + ( x42p + x42m ) * f2d ( l , ix - 1 , ly ) & & + ( x43p + x43m ) * f2d ( l , ix , ly ) & & + ( x44p + x44m ) * f2d ( l , ix + 1 , ly ) & & + ( x44p - x44m ) * f2d ( l , ix + 2 , ly ) & & + ( x43p - x43m ) * f2d ( l , ix + 3 , ly ) & & + ( x42p - x42m ) * f2d ( l , ix + 4 , ly ) & & + ( x41p - x41m ) * f2d ( l , ix + 5 , ly )) w0l = ww * cy ( my ) + w0l wyl = ww * dy ( my ) + wyl wxl = (( dx41p + dx41m ) * f2d ( l , ix - 2 , ly ) & & + ( dx42p + dx42m ) * f2d ( l , ix - 1 , ly ) & & + ( dx43p + dx43m ) * f2d ( l , ix , ly ) & & + ( dx44p + dx44m ) * f2d ( l , ix + 1 , ly ) & & + ( dx44p - dx44m ) * f2d ( l , ix + 2 , ly ) & & + ( dx43p - dx43m ) * f2d ( l , ix + 3 , ly ) & & + ( dx42p - dx42m ) * f2d ( l , ix + 4 , ly ) & & + ( dx41p - dx41m ) * f2d ( l , ix + 5 , ly )) * cy ( my ) + wxl END DO loop020 w0 ( l ) = w0l wx ( l ) = wxl / h2x wy ( l ) = wyl / h2y END DO loop010 RETURN END SUBROUTINE spl2dd SUBROUTINE spl3df ( xd , & !(in) & w0 & !(out) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: xd ( 3 ) REAL ( RP ), INTENT ( OUT ) :: w0 ( l3d ) !Local variables INTEGER , PARAMETER :: m2 = 8 INTEGER :: l , & & mz , & & lz , & & my , & & ly , & & ix , & & iy , & & iz REAL ( RP ) :: x , & & y , & & z , & & ux , & & uy , & & uz , & & usx , & & usy , & & usz , & & x400 , & & y400 , & & z400 , & & x41m , & & y41m , & & z41m , & & x41p , & & y41p , & & z41p , & & x42m , & & y42m , & & z42m , & & x42p , & & y42p , & & z42p , & & x43m , & & y43m , & & z43m , & & x43p , & & y43p , & & z43p , & & x44m , & & y44m , & & z44m , & & x44p , & & y44p , & & z44p , & & cyz , & & cy ( 8 ), & & cz ( 8 ) w0 (:) = 0.0_RP x = xd ( 1 ) IF ( x < xs3 ) RETURN IF ( x > xl3 ) RETURN y = xd ( 2 ) IF ( y < ys3 ) RETURN IF ( y > yl3 ) RETURN z = xd ( 3 ) IF ( z < zs3 ) z = zs3 IF ( z > zl3 ) z = zl3 ux = ( x - xs3 ) / h3x ix = ux IF ( ix >= nx3d - 1 ) THEN ix = nx3d - 2 ux = nx3d - 1 END IF uy = ( y - ys3 ) / h3y iy = uy IF ( iy >= ny3d - 1 ) THEN iy = ny3d - 2 uy = ny3d - 1 END IF uz = ( z - zs3 ) / h3z iz = uz IF ( iz >= nz3d - 1 ) THEN iz = nz3d - 2 uz = nz3d - 1 END IF ux = ux - ix - 0.5_RP uy = uy - iy - 0.5_RP uz = uz - iz - 0.5_RP usx = ux * ux usy = uy * uy usz = uz * uz !###########       case for m == 4       ############################# x400 = ((( c41e * usx + c41c ) * usx + c41a ) * usx + c418 ) * usx y400 = ((( c41e * usy + c41c ) * usy + c41a ) * usy + c418 ) * usy z400 = ((( c41e * usz + c41c ) * usz + c41a ) * usz + c418 ) * usz x41m = ((( x400 + c416 ) * usx + c414 ) * usx + c412 ) * ux x41p = (( c417 * usx + c415 ) * usx + c413 ) * usx + c411 y41m = ((( y400 + c416 ) * usy + c414 ) * usy + c412 ) * uy y41p = (( c417 * usy + c415 ) * usy + c413 ) * usy + c411 z41m = ((( z400 + c416 ) * usz + c414 ) * usz + c412 ) * uz z41p = (( c417 * usz + c415 ) * usz + c413 ) * usz + c411 x42m = ((( - x400 * 7.0_RP + c426 ) * usx + c424 ) * usx + c422 ) * ux x42p = (( c427 * usx + c425 ) * usx + c423 ) * usx + c421 y42m = ((( - y400 * 7.0_RP + c426 ) * usy + c424 ) * usy + c422 ) * uy y42p = (( c427 * usy + c425 ) * usy + c423 ) * usy + c421 z42m = ((( - z400 * 7.0_RP + c426 ) * usz + c424 ) * usz + c422 ) * uz z42p = (( c427 * usz + c425 ) * usz + c423 ) * usz + c421 x43m = ((( x400 * 2 1.0_RP + c436 ) * usx + c434 ) * usx + c432 ) * ux x43p = (( c437 * usx + c435 ) * usx + c433 ) * usx + c431 y43m = ((( y400 * 2 1.0_RP + c436 ) * usy + c434 ) * usy + c432 ) * uy y43p = (( c437 * usy + c435 ) * usy + c433 ) * usy + c431 z43m = ((( z400 * 2 1.0_RP + c436 ) * usz + c434 ) * usz + c432 ) * uz z43p = (( c437 * usz + c435 ) * usz + c433 ) * usz + c431 x44m = ((( - x400 * 3 5.0_RP + c446 ) * usx + c444 ) * usx + c442 ) * ux x44p = (( c447 * usx + c445 ) * usx + c443 ) * usx + c441 y44m = ((( - y400 * 3 5.0_RP + c446 ) * usy + c444 ) * usy + c442 ) * uy y44p = (( c447 * usy + c445 ) * usy + c443 ) * usy + c441 z44m = ((( - z400 * 3 5.0_RP + c446 ) * usz + c444 ) * usz + c442 ) * uz z44p = (( c447 * usz + c445 ) * usz + c443 ) * usz + c441 cy ( 1 ) = y41p + y41m cy ( 2 ) = y42p + y42m cy ( 3 ) = y43p + y43m cy ( 4 ) = y44p + y44m cy ( 5 ) = y44p - y44m cy ( 6 ) = y43p - y43m cy ( 7 ) = y42p - y42m cy ( 8 ) = y41p - y41m cz ( 1 ) = z41p + z41m cz ( 2 ) = z42p + z42m cz ( 3 ) = z43p + z43m cz ( 4 ) = z44p + z44m cz ( 5 ) = z44p - z44m cz ( 6 ) = z43p - z43m cz ( 7 ) = z42p - z42m cz ( 8 ) = z41p - z41m loop010 : DO l = 1 , l3d loop020 : DO mz = 1 , m2 lz = iz + mz - 3 loop030 : DO my = 1 , m2 ly = iy + my - 3 cyz = cy ( my ) * cz ( mz ) w0 ( l ) = (( x41p + x41m ) * f3d ( l , ix - 2 , ly , lz ) & & + ( x42p + x42m ) * f3d ( l , ix - 1 , ly , lz ) & & + ( x43p + x43m ) * f3d ( l , ix , ly , lz ) & & + ( x44p + x44m ) * f3d ( l , ix + 1 , ly , lz ) & & + ( x44p - x44m ) * f3d ( l , ix + 2 , ly , lz ) & & + ( x43p - x43m ) * f3d ( l , ix + 3 , ly , lz ) & & + ( x42p - x42m ) * f3d ( l , ix + 4 , ly , lz ) & & + ( x41p - x41m ) * f3d ( l , ix + 5 , ly , lz )) * cyz + w0 ( l ) END DO loop030 END DO loop020 END DO loop010 RETURN END SUBROUTINE spl3df SUBROUTINE spl3dd ( xd , & !(in) & w0 , wx , wy , wz & !(out) & ) IMPLICIT NONE !Arguments REAL ( RP ), INTENT ( IN ) :: xd ( 3 ) REAL ( RP ), INTENT ( OUT ) :: w0 ( l3d ), & & wx ( l3d ), & & wy ( l3d ), & & wz ( l3d ) !Local variables INTEGER , PARAMETER :: m2 = 8 INTEGER :: l , & & ix , & & iy , & & iz , & & mz , & & lz , & & ix1 , & & ix2 , & & ix4 , & & ix5 , & & ix6 , & & ix7 , & & ix8 , & & iy1 , & & iy2 , & & iy4 , & & iy5 , & & iy6 , & & iy7 , & & iy8 REAL ( RP ) :: x , & & y , & & z , & & ux , & & uy , & & uz , & & usx , & & usy , & & usz , & & x400 , & & y400 , & & z400 , & & x41m , & & y41m , & & z41m , & & x41p , & & y41p , & & z41p , & & x42m , & & y42m , & & z42m , & & x42p , & & y42p , & & z42p , & & x43m , & & y43m , & & z43m , & & x43p , & & y43p , & & z43p , & & x44m , & & y44m , & & z44m , & & x44p , & & y44p , & & z44p , & & dx400 , & & dy400 , & & dz400 , & & dx41m , & & dy41m , & & dz41m , & & dx41p , & & dy41p , & & dz41p , & & dx42m , & & dy42m , & & dz42m , & & dx42p , & & dy42p , & & dz42p , & & dx43m , & & dy43m , & & dz43m , & & dx43p , & & dy43p , & & dz43p , & & dx44m , & & dy44m , & & dz44m , & & dx44p , & & dy44p , & & dz44p , & & cx1 , & & cx2 , & & cx3 , & & cx4 , & & cx5 , & & cx6 , & & cx7 , & & cx8 , & & cy1 , & & cy2 , & & cy3 , & & cy4 , & & cy5 , & & cy6 , & & cy7 , & & cy8 , & & dx1 , & & dx2 , & & dx3 , & & dx4 , & & dx5 , & & dx6 , & & dx7 , & & dx8 , & & dy1 , & & dy2 , & & dy3 , & & dy4 , & & dy5 , & & dy6 , & & dy7 , & & dy8 , & & w0l , & & wxl , & & wyl , & & wzl , & & w01 , & & w02 , & & w03 , & & w04 , & & w05 , & & w06 , & & w07 , & & w08 , & & w00 , & & cz ( 8 ), & & dz ( 8 ) w0 (:) = 0.0_RP wx (:) = 0.0_RP wy (:) = 0.0_RP wz (:) = 0.0_RP x = xd ( 1 ) IF ( x < xs3 ) RETURN IF ( x > xl3 ) RETURN y = xd ( 2 ) IF ( y < ys3 ) RETURN IF ( y > yl3 ) RETURN z = xd ( 3 ) IF ( z < zs3 ) z = zs3 IF ( z > zl3 ) z = zl3 ux = ( x - xs3 ) / h3x ix = ux IF ( ix >= nx3d - 1 ) THEN ix = nx3d - 2 ux = nx3d - 1 END IF uy = ( y - ys3 ) / h3y iy = uy IF ( iy >= ny3d - 1 ) THEN iy = ny3d - 2 uy = ny3d - 1 END IF uz = ( z - zs3 ) / h3z iz = uz IF ( iz >= nz3d - 1 ) THEN iz = nz3d - 2 uz = nz3d - 1 END IF ux = ux - ix - 0.5_RP uy = uy - iy - 0.5_RP uz = uz - iz - 0.5_RP usx = ux * ux usy = uy * uy usz = uz * uz ix1 = ix - 2 ix2 = ix - 1 ix4 = ix + 1 ix5 = ix + 2 ix6 = ix + 3 ix7 = ix + 4 ix8 = ix + 5 iy1 = iy - 2 iy2 = iy - 1 iy4 = iy + 1 iy5 = iy + 2 iy6 = iy + 3 iy7 = iy + 4 iy8 = iy + 5 !############       case for m == 4       ########################### x400 = ((( c41e * usx + c41c ) * usx + c41a ) * usx + c418 ) * usx y400 = ((( c41e * usy + c41c ) * usy + c41a ) * usy + c418 ) * usy z400 = ((( c41e * usz + c41c ) * usz + c41a ) * usz + c418 ) * usz dx400 = ((( d41e * usx + d41c ) * usx + d41a ) * usx + d418 ) * usx dy400 = ((( d41e * usy + d41c ) * usy + d41a ) * usy + d418 ) * usy dz400 = ((( d41e * usz + d41c ) * usz + d41a ) * usz + d418 ) * usz x41m = ((( x400 + c416 ) * usx + c414 ) * usx + c412 ) * ux y41m = ((( y400 + c416 ) * usy + c414 ) * usy + c412 ) * uy z41m = ((( z400 + c416 ) * usz + c414 ) * usz + c412 ) * uz x41p = (( c417 * usx + c415 ) * usx + c413 ) * usx + c411 y41p = (( c417 * usy + c415 ) * usy + c413 ) * usy + c411 z41p = (( c417 * usz + c415 ) * usz + c413 ) * usz + c411 dx41m = (( dx400 + d416 ) * usx + d414 ) * usx + c412 dy41m = (( dy400 + d416 ) * usy + d414 ) * usy + c412 dz41m = (( dz400 + d416 ) * usz + d414 ) * usz + c412 dx41p = (( d417 * usx + d415 ) * usx + d413 ) * ux dy41p = (( d417 * usy + d415 ) * usy + d413 ) * uy dz41p = (( d417 * usz + d415 ) * usz + d413 ) * uz x42m = ((( - x400 * 7.0_RP + c426 ) * usx + c424 ) * usx + c422 ) * ux y42m = ((( - y400 * 7.0_RP + c426 ) * usy + c424 ) * usy + c422 ) * uy z42m = ((( - z400 * 7.0_RP + c426 ) * usz + c424 ) * usz + c422 ) * uz x42p = (( c427 * usx + c425 ) * usx + c423 ) * usx + c421 y42p = (( c427 * usy + c425 ) * usy + c423 ) * usy + c421 z42p = (( c427 * usz + c425 ) * usz + c423 ) * usz + c421 dx42m = (( - dx400 * 7.0_RP + d426 ) * usx + d424 ) * usx + c422 dy42m = (( - dy400 * 7.0_RP + d426 ) * usy + d424 ) * usy + c422 dz42m = (( - dz400 * 7.0_RP + d426 ) * usz + d424 ) * usz + c422 dx42p = (( d427 * usx + d425 ) * usx + d423 ) * ux dy42p = (( d427 * usy + d425 ) * usy + d423 ) * uy dz42p = (( d427 * usz + d425 ) * usz + d423 ) * uz x43m = ((( x400 * 2 1.0_RP + c436 ) * usx + c434 ) * usx + c432 ) * ux y43m = ((( y400 * 2 1.0_RP + c436 ) * usy + c434 ) * usy + c432 ) * uy z43m = ((( z400 * 2 1.0_RP + c436 ) * usz + c434 ) * usz + c432 ) * uz x43p = (( c437 * usx + c435 ) * usx + c433 ) * usx + c431 y43p = (( c437 * usy + c435 ) * usy + c433 ) * usy + c431 z43p = (( c437 * usz + c435 ) * usz + c433 ) * usz + c431 dx43m = (( dx400 * 2 1.0_RP + d436 ) * usx + d434 ) * usx + c432 dy43m = (( dy400 * 2 1.0_RP + d436 ) * usy + d434 ) * usy + c432 dz43m = (( dz400 * 2 1.0_RP + d436 ) * usz + d434 ) * usz + c432 dx43p = (( d437 * usx + d435 ) * usx + d433 ) * ux dy43p = (( d437 * usy + d435 ) * usy + d433 ) * uy dz43p = (( d437 * usz + d435 ) * usz + d433 ) * uz x44m = ((( - x400 * 3 5.0_RP + c446 ) * usx + c444 ) * usx + c442 ) * ux y44m = ((( - y400 * 3 5.0_RP + c446 ) * usy + c444 ) * usy + c442 ) * uy z44m = ((( - z400 * 3 5.0_RP + c446 ) * usz + c444 ) * usz + c442 ) * uz x44p = (( c447 * usx + c445 ) * usx + c443 ) * usx + c441 y44p = (( c447 * usy + c445 ) * usy + c443 ) * usy + c441 z44p = (( c447 * usz + c445 ) * usz + c443 ) * usz + c441 dx44m = (( - dx400 * 3 5.0_RP + d446 ) * usx + d444 ) * usx + c442 dy44m = (( - dy400 * 3 5.0_RP + d446 ) * usy + d444 ) * usy + c442 dz44m = (( - dz400 * 3 5.0_RP + d446 ) * usz + d444 ) * usz + c442 dx44p = (( d447 * usx + d445 ) * usx + d443 ) * ux dy44p = (( d447 * usy + d445 ) * usy + d443 ) * uy dz44p = (( d447 * usz + d445 ) * usz + d443 ) * uz cx1 = x41p + x41m cx2 = x42p + x42m cx3 = x43p + x43m cx4 = x44p + x44m cx5 = x44p - x44m cx6 = x43p - x43m cx7 = x42p - x42m cx8 = x41p - x41m cy1 = y41p + y41m cy2 = y42p + y42m cy3 = y43p + y43m cy4 = y44p + y44m cy5 = y44p - y44m cy6 = y43p - y43m cy7 = y42p - y42m cy8 = y41p - y41m cz ( 1 ) = z41p + z41m cz ( 2 ) = z42p + z42m cz ( 3 ) = z43p + z43m cz ( 4 ) = z44p + z44m cz ( 5 ) = z44p - z44m cz ( 6 ) = z43p - z43m cz ( 7 ) = z42p - z42m cz ( 8 ) = z41p - z41m dx1 = dx41p + dx41m dx2 = dx42p + dx42m dx3 = dx43p + dx43m dx4 = dx44p + dx44m dx5 = dx44p - dx44m dx6 = dx43p - dx43m dx7 = dx42p - dx42m dx8 = dx41p - dx41m dy1 = dy41p + dy41m dy2 = dy42p + dy42m dy3 = dy43p + dy43m dy4 = dy44p + dy44m dy5 = dy44p - dy44m dy6 = dy43p - dy43m dy7 = dy42p - dy42m dy8 = dy41p - dy41m dz ( 1 ) = dz41p + dz41m dz ( 2 ) = dz42p + dz42m dz ( 3 ) = dz43p + dz43m dz ( 4 ) = dz44p + dz44m dz ( 5 ) = dz44p - dz44m dz ( 6 ) = dz43p - dz43m dz ( 7 ) = dz42p - dz42m dz ( 8 ) = dz41p - dz41m loop010 : DO l = 1 , l3d w0l = 0.0_RP wxl = 0.0_RP wyl = 0.0_RP wzl = 0.0_RP loop020 : DO mz = 1 , m2 lz = iz + mz - 3 w01 = cx1 * f3d ( l , ix1 , iy1 , lz ) + cx2 * f3d ( l , ix2 , iy1 , lz ) & & + cx3 * f3d ( l , ix , iy1 , lz ) + cx4 * f3d ( l , ix4 , iy1 , lz ) & & + cx5 * f3d ( l , ix5 , iy1 , lz ) + cx6 * f3d ( l , ix6 , iy1 , lz ) & & + cx7 * f3d ( l , ix7 , iy1 , lz ) + cx8 * f3d ( l , ix8 , iy1 , lz ) w02 = cx1 * f3d ( l , ix1 , iy2 , lz ) + cx2 * f3d ( l , ix2 , iy2 , lz ) & & + cx3 * f3d ( l , ix , iy2 , lz ) + cx4 * f3d ( l , ix4 , iy2 , lz ) & & + cx5 * f3d ( l , ix5 , iy2 , lz ) + cx6 * f3d ( l , ix6 , iy2 , lz ) & & + cx7 * f3d ( l , ix7 , iy2 , lz ) + cx8 * f3d ( l , ix8 , iy2 , lz ) w03 = cx1 * f3d ( l , ix1 , iy , lz ) + cx2 * f3d ( l , ix2 , iy , lz ) & & + cx3 * f3d ( l , ix , iy , lz ) + cx4 * f3d ( l , ix4 , iy , lz ) & & + cx5 * f3d ( l , ix5 , iy , lz ) + cx6 * f3d ( l , ix6 , iy , lz ) & & + cx7 * f3d ( l , ix7 , iy , lz ) + cx8 * f3d ( l , ix8 , iy , lz ) w04 = cx1 * f3d ( l , ix1 , iy4 , lz ) + cx2 * f3d ( l , ix2 , iy4 , lz ) & & + cx3 * f3d ( l , ix , iy4 , lz ) + cx4 * f3d ( l , ix4 , iy4 , lz ) & & + cx5 * f3d ( l , ix5 , iy4 , lz ) + cx6 * f3d ( l , ix6 , iy4 , lz ) & & + cx7 * f3d ( l , ix7 , iy4 , lz ) + cx8 * f3d ( l , ix8 , iy4 , lz ) w05 = cx1 * f3d ( l , ix1 , iy5 , lz ) + cx2 * f3d ( l , ix2 , iy5 , lz ) & & + cx3 * f3d ( l , ix , iy5 , lz ) + cx4 * f3d ( l , ix4 , iy5 , lz ) & & + cx5 * f3d ( l , ix5 , iy5 , lz ) + cx6 * f3d ( l , ix6 , iy5 , lz ) & & + cx7 * f3d ( l , ix7 , iy5 , lz ) + cx8 * f3d ( l , ix8 , iy5 , lz ) w06 = cx1 * f3d ( l , ix1 , iy6 , lz ) + cx2 * f3d ( l , ix2 , iy6 , lz ) & & + cx3 * f3d ( l , ix , iy6 , lz ) + cx4 * f3d ( l , ix4 , iy6 , lz ) & & + cx5 * f3d ( l , ix5 , iy6 , lz ) + cx6 * f3d ( l , ix6 , iy6 , lz ) & & + cx7 * f3d ( l , ix7 , iy6 , lz ) + cx8 * f3d ( l , ix8 , iy6 , lz ) w07 = cx1 * f3d ( l , ix1 , iy7 , lz ) + cx2 * f3d ( l , ix2 , iy7 , lz ) & & + cx3 * f3d ( l , ix , iy7 , lz ) + cx4 * f3d ( l , ix4 , iy7 , lz ) & & + cx5 * f3d ( l , ix5 , iy7 , lz ) + cx6 * f3d ( l , ix6 , iy7 , lz ) & & + cx7 * f3d ( l , ix7 , iy7 , lz ) + cx8 * f3d ( l , ix8 , iy7 , lz ) w08 = cx1 * f3d ( l , ix1 , iy8 , lz ) + cx2 * f3d ( l , ix2 , iy8 , lz ) & & + cx3 * f3d ( l , ix , iy8 , lz ) + cx4 * f3d ( l , ix4 , iy8 , lz ) & & + cx5 * f3d ( l , ix5 , iy8 , lz ) + cx6 * f3d ( l , ix6 , iy8 , lz ) & & + cx7 * f3d ( l , ix7 , iy8 , lz ) + cx8 * f3d ( l , ix8 , iy8 , lz ) wxl = (( dx1 * f3d ( l , ix1 , iy1 , lz ) + dx2 * f3d ( l , ix2 , iy1 , lz ) & & + dx3 * f3d ( l , ix , iy1 , lz ) + dx4 * f3d ( l , ix4 , iy1 , lz ) & & + dx5 * f3d ( l , ix5 , iy1 , lz ) + dx6 * f3d ( l , ix6 , iy1 , lz ) & & + dx7 * f3d ( l , ix7 , iy1 , lz ) + dx8 * f3d ( l , ix8 , iy1 , lz )) * cy1 & & + ( dx1 * f3d ( l , ix1 , iy2 , lz ) + dx2 * f3d ( l , ix2 , iy2 , lz ) & & + dx3 * f3d ( l , ix , iy2 , lz ) + dx4 * f3d ( l , ix4 , iy2 , lz ) & & + dx5 * f3d ( l , ix5 , iy2 , lz ) + dx6 * f3d ( l , ix6 , iy2 , lz ) & & + dx7 * f3d ( l , ix7 , iy2 , lz ) + dx8 * f3d ( l , ix8 , iy2 , lz )) * cy2 & & + ( dx1 * f3d ( l , ix1 , iy , lz ) + dx2 * f3d ( l , ix2 , iy , lz ) & & + dx3 * f3d ( l , ix , iy , lz ) + dx4 * f3d ( l , ix4 , iy , lz ) & & + dx5 * f3d ( l , ix5 , iy , lz ) + dx6 * f3d ( l , ix6 , iy , lz ) & & + dx7 * f3d ( l , ix7 , iy , lz ) + dx8 * f3d ( l , ix8 , iy , lz )) * cy3 & & + ( dx1 * f3d ( l , ix1 , iy4 , lz ) + dx2 * f3d ( l , ix2 , iy4 , lz ) & & + dx3 * f3d ( l , ix , iy4 , lz ) + dx4 * f3d ( l , ix4 , iy4 , lz ) & & + dx5 * f3d ( l , ix5 , iy4 , lz ) + dx6 * f3d ( l , ix6 , iy4 , lz ) & & + dx7 * f3d ( l , ix7 , iy4 , lz ) + dx8 * f3d ( l , ix8 , iy4 , lz )) * cy4 & & + ( dx1 * f3d ( l , ix1 , iy5 , lz ) + dx2 * f3d ( l , ix2 , iy5 , lz ) & & + dx3 * f3d ( l , ix , iy5 , lz ) + dx4 * f3d ( l , ix4 , iy5 , lz ) & & + dx5 * f3d ( l , ix5 , iy5 , lz ) + dx6 * f3d ( l , ix6 , iy5 , lz ) & & + dx7 * f3d ( l , ix7 , iy5 , lz ) + dx8 * f3d ( l , ix8 , iy5 , lz )) * cy5 & & + ( dx1 * f3d ( l , ix1 , iy6 , lz ) + dx2 * f3d ( l , ix2 , iy6 , lz ) & & + dx3 * f3d ( l , ix , iy6 , lz ) + dx4 * f3d ( l , ix4 , iy6 , lz ) & & + dx5 * f3d ( l , ix5 , iy6 , lz ) + dx6 * f3d ( l , ix6 , iy6 , lz ) & & + dx7 * f3d ( l , ix7 , iy6 , lz ) + dx8 * f3d ( l , ix8 , iy6 , lz )) * cy6 & & + ( dx1 * f3d ( l , ix1 , iy7 , lz ) + dx2 * f3d ( l , ix2 , iy7 , lz ) & & + dx3 * f3d ( l , ix , iy7 , lz ) + dx4 * f3d ( l , ix4 , iy7 , lz ) & & + dx5 * f3d ( l , ix5 , iy7 , lz ) + dx6 * f3d ( l , ix6 , iy7 , lz ) & & + dx7 * f3d ( l , ix7 , iy7 , lz ) + dx8 * f3d ( l , ix8 , iy7 , lz )) * cy7 & & + ( dx1 * f3d ( l , ix1 , iy8 , lz ) + dx2 * f3d ( l , ix2 , iy8 , lz ) & & + dx3 * f3d ( l , ix , iy8 , lz ) + dx4 * f3d ( l , ix4 , iy8 , lz ) & & + dx5 * f3d ( l , ix5 , iy8 , lz ) + dx6 * f3d ( l , ix6 , iy8 , lz ) & & + dx7 * f3d ( l , ix7 , iy8 , lz ) + dx8 * f3d ( l , ix8 , iy8 , lz )) * cy8 ) & & * cz ( mz ) + wxl w00 = w01 * cy1 + w02 * cy2 + w03 * cy3 + w04 * cy4 & & + w05 * cy5 + w06 * cy6 + w07 * cy7 + w08 * cy8 w0l = w00 * cz ( mz ) + w0l wzl = w00 * dz ( mz ) + wzl wyl = ( w01 * dy1 + w02 * dy2 + w03 * dy3 + w04 * dy4 & & + w05 * dy5 + w06 * dy6 + w07 * dy7 + w08 * dy8 ) * cz ( mz ) & & + wyl END DO loop020 w0 ( l ) = w0l wx ( l ) = wxl / h3x wy ( l ) = wyl / h3y wz ( l ) = wzl / h3z END DO loop010 RETURN END SUBROUTINE spl3dd END MODULE spline_mod","tags":"","loc":"sourcefile/spline_mod.f90.html"},{"title":"divertor_mod.f90 – OFIT3D","text":"Contents Modules divertor_mod Source Code divertor_mod.f90 Source Code !> @file divertor_mod.f90 !------------------------------------------------------------------------------ ! ! MODULE: divertor_mod ! !> @author !> Yasuhiro Suzuki, National Institute for Fusion Science ! ! DESCRIPTION: !> @brief !> ! ! REVISION HISTORY: !> @date 19 Apr 2020 ! !> @version Initial Version ! !------------------------------------------------------------------------------ MODULE divertor_mod USE kind_spec USE param1 , ONLY : pi2 IMPLICIT NONE PRIVATE LOGICAL :: ldivertor = . false ., & & ldivertor_vtk = . false . INTEGER :: num_nodes = 18 , & & num_elements = 20 CHARACTER ( LEN = 10 ) :: divertor_model = '' CHARACTER ( LEN = 300 ) :: divertor_file = '' , & & nodes_file = '' , & & elements_file = '' INTEGER , ALLOCATABLE :: def_elements (:,:) REAL ( RP ), ALLOCATABLE :: x_nodes (:), & & y_nodes (:), & & z_nodes (:) PUBLIC :: ldivertor , & & ldivertor_vtk , & & divertor_model , & & num_nodes , & & num_elements , & & divertor_file , & & nodes_file , & & elements_file , & & read_divertor , & & free_mem_divertor , & & divertor_loss CONTAINS SUBROUTINE make_mem_divertor IMPLICIT NONE ALLOCATE ( def_elements ( num_elements , 3 ), x_nodes ( num_nodes ), y_nodes ( num_nodes ), z_nodes ( num_nodes )) END SUBROUTINE make_mem_divertor SUBROUTINE free_mem_divertor IMPLICIT NONE DEALLOCATE ( def_elements , x_nodes , y_nodes , z_nodes ) END SUBROUTINE free_mem_divertor SUBROUTINE read_divertor IMPLICIT NONE SELECT CASE ( TRIM ( divertor_model )) CASE ( 'w7code' ) CALL read_divertor_w7code CASE DEFAULT CALL make_mem_divertor CALL read_nodes CALL read_elements END SELECT IF ( ldivertor_vtk ) CALL write_divertor_vtk END SUBROUTINE read_divertor SUBROUTINE read_nodes IMPLICIT NONE INTEGER :: itemp , & & i DO i = 1 , num_nodes READ ( 32 , * ) itemp , x_nodes ( i ), y_nodes ( i ), z_nodes ( i ) END DO END SUBROUTINE read_nodes SUBROUTINE read_elements IMPLICIT NONE INTEGER :: itemp , & & i DO i = 1 , num_elements READ ( 33 , * ) itemp , def_elements ( i , 1 ), def_elements ( i , 2 ), def_elements ( i , 3 ) END DO def_elements ( 1 : num_elements , 1 : 3 ) = def_elements ( 1 : num_elements , 1 : 3 ) - 1 END SUBROUTINE read_elements SUBROUTINE read_divertor_w7code IMPLICIT NONE INTEGER :: mtor , & & nu , & & nv !Local variables INTEGER :: i1 , & & i2 , & & i3 , & & i , & & j , & & k REAL ( RP ) :: r , & & phi , & & z READ ( 31 , * ) READ ( 31 , * ) nv , nu , mtor num_nodes = nv * nu num_elements = 2 * ( nv - 1 ) * ( nu - 1 ) CALL make_mem_divertor k = 0 DO j = 1 , nv READ ( 31 , * ) phi phi = phi * pi2 / 36 0.0_RP DO i = 1 , nu k = k + 1 READ ( 31 , * ) r , z x_nodes ( k ) = 1.0E-02_RP * r * COS ( phi ) y_nodes ( k ) = 1.0E-02_RP * r * SIN ( phi ) z_nodes ( k ) = 1.0E-02_RP * z END DO END DO k = 0 DO j = 1 , nv - 1 DO i = 1 , nu - 1 i1 = i + ( j - 1 ) * nu i2 = i1 + 1 i3 = i + j * nu k = k + 1 def_elements ( k , 1 ) = i1 - 1 def_elements ( k , 2 ) = i2 - 1 def_elements ( k , 3 ) = i3 - 1 i1 = i + ( j - 1 ) * nu + 1 i2 = i + j * nu i3 = i2 + 1 k = k + 1 def_elements ( k , 1 ) = i1 - 1 def_elements ( k , 2 ) = i2 - 1 def_elements ( k , 3 ) = i3 - 1 END DO END DO END SUBROUTINE read_divertor_w7code SUBROUTINE write_divertor_vtk IMPLICIT NONE !Local variables INTEGER :: i1 , & & i2 , & & i3 , & & i OPEN ( 301 , FILE = 'divertor.vtk' , FORM = 'formatted' , STATUS = 'unknown' ) WRITE ( 301 , '(A)' ) '# vtk DataFile Version 3.0' WRITE ( 301 , '(A)' ) 'Unstructured Grid' WRITE ( 301 , '(A)' ) 'ASCII' WRITE ( 301 , * ) WRITE ( 301 , '(A)' ) 'DATASET UNSTRUCTURED_GRID' WRITE ( 301 , '(A,I12,A)' ) 'POINTS ' , num_nodes , ' float' DO i = 1 , num_nodes WRITE ( 301 , '(3(ES12.4))' ) x_nodes ( i ), y_nodes ( i ), z_nodes ( i ) END DO WRITE ( 301 , * ) WRITE ( 301 , '(A,2I12)' ) 'CELLS' , num_elements , 4 * num_elements DO i = 1 , num_elements WRITE ( 301 , '(I3,3I12)' ) 3 , def_elements ( i , 1 ), def_elements ( i , 2 ), def_elements ( i , 3 ) END DO WRITE ( 301 , * ) WRITE ( 301 , '(A,I12)' ) 'CELL_TYPES' , num_elements DO i = 1 , num_elements WRITE ( 301 , '(I2)' ) 5 END DO WRITE ( 301 , '(A,I12)' ) 'POINT_DATA' , num_nodes WRITE ( 301 , '(A)' ) 'SCALARS scalars float 1' WRITE ( 301 , '(A)' ) 'LOOKUP_TABLE default' DO i = 1 , num_nodes WRITE ( 301 , '(ES12.4)' ) 5.0_RP END DO CLOSE ( 301 ) END SUBROUTINE write_divertor_vtk SUBROUTINE divertor_loss ( r0 , phi0 , z0 , r1 , phi1 , z1 , & !(in) & intersect , beta , point & !(out) & ) IMPLICIT NONE INTEGER , INTENT ( OUT ) :: intersect REAL ( RP ), INTENT ( IN ) :: r0 , & & phi0 , & & z0 , & & r1 , & & phi1 , & & z1 REAL ( RP ), INTENT ( OUT ) :: beta , & & point ( 3 ) INTEGER :: i1 , & & i2 , & & i3 , & & i , & & j , & & k REAL ( RP ) :: x0 , & & y0 , & & x1 , & & y1 , & & p0 , & & p1 , & & dis , & & dis_ps , & & dis_pe , & & dis_12 , & & dis_13 , & & nn ( 3 ), & & a ( 3 ), & & b ( 3 ), & & c ( 3 ), & & ab ( 3 ), & & ac ( 3 ), & & bc ( 3 ), & & ca ( 3 ), & & ps ( 3 ), & & pe ( 3 ), & & aps ( 3 ), & & ape ( 3 ), & & ap ( 3 ), & & bp ( 3 ), & & cp ( 3 ), & & abxap ( 3 ), & & bcxbp ( 3 ), & & caxcp ( 3 ) intersect = 0 x0 = r0 * COS ( p0 ) y0 = r0 * SIN ( p0 ) x1 = r1 * COS ( p1 ) y1 = r1 * SIN ( p1 ) ps ( 1 ) = x0 ps ( 2 ) = y0 ps ( 3 ) = z0 pe ( 1 ) = x1 pe ( 2 ) = y1 pe ( 3 ) = z1 DO i = 1 , num_elements i1 = def_elements ( i , 1 ) + 1 i2 = def_elements ( i , 2 ) + 1 i3 = def_elements ( i , 3 ) + 1 a ( 1 ) = x_nodes ( i1 ) a ( 2 ) = y_nodes ( i1 ) a ( 3 ) = z_nodes ( i1 ) b ( 1 ) = x_nodes ( i2 ) b ( 2 ) = y_nodes ( i2 ) b ( 3 ) = z_nodes ( i2 ) c ( 1 ) = x_nodes ( i3 ) c ( 2 ) = y_nodes ( i3 ) c ( 3 ) = z_nodes ( i3 ) ab ( 1 : 3 ) = b ( 1 : 3 ) - a ( 1 : 3 ) ac ( 1 : 3 ) = c ( 1 : 3 ) - a ( 1 : 3 ) aps ( 1 : 3 ) = ps ( 1 : 3 ) - a ( 1 : 3 ) ape ( 1 : 3 ) = pe ( 1 : 3 ) - a ( 1 : 3 ) nn ( 1 ) = ab ( 2 ) * ac ( 3 ) - ab ( 3 ) * ac ( 2 ) nn ( 2 ) = ab ( 3 ) * ac ( 1 ) - ab ( 1 ) * ac ( 3 ) nn ( 3 ) = ab ( 1 ) * ac ( 2 ) - ab ( 2 ) * ac ( 1 ) dis = SQRT ( nn ( 1 ) ** 2 + nn ( 2 ) ** 2 + nn ( 3 ) ** 2 ) nn ( 1 : 3 ) = nn ( 1 : 3 ) / dis dis_ps = DOT_PRODUCT ( aps ( 1 : 3 ), nn ( 1 : 3 )) dis_pe = DOT_PRODUCT ( ape ( 1 : 3 ), nn ( 1 : 3 )) IF ( dis_ps * dis_pe <= 0.0_RP ) THEN beta = ABS ( dis_ps ) / ( ABS ( dis_ps ) + ABS ( dis_pe )) point ( 1 : 3 ) = ps ( 1 : 3 ) + beta * ( pe ( 1 : 3 ) - ps ( 1 : 3 )) ap ( 1 : 3 ) = point ( 1 : 3 ) - a ( 1 : 3 ) bp ( 1 : 3 ) = point ( 1 : 3 ) - b ( 1 : 3 ) cp ( 1 : 3 ) = point ( 1 : 3 ) - c ( 1 : 3 ) ab ( 1 : 3 ) = b ( 1 : 3 ) - a ( 1 : 3 ) bc ( 1 : 3 ) = c ( 1 : 3 ) - b ( 1 : 3 ) ca ( 1 : 3 ) = a ( 1 : 3 ) - c ( 1 : 3 ) abxap ( 1 ) = ab ( 2 ) * ap ( 3 ) - ab ( 3 ) * ap ( 2 ) abxap ( 2 ) = ab ( 3 ) * ap ( 1 ) - ab ( 1 ) * ap ( 3 ) abxap ( 3 ) = ab ( 1 ) * ap ( 2 ) - ab ( 2 ) * ap ( 1 ) bcxbp ( 1 ) = bc ( 2 ) * bp ( 3 ) - bc ( 3 ) * bp ( 2 ) bcxbp ( 2 ) = bc ( 3 ) * bp ( 1 ) - bc ( 1 ) * bp ( 3 ) bcxbp ( 3 ) = bc ( 1 ) * bp ( 2 ) - bc ( 2 ) * bp ( 1 ) caxcp ( 1 ) = ca ( 2 ) * cp ( 3 ) - ca ( 3 ) * cp ( 2 ) caxcp ( 2 ) = ca ( 3 ) * cp ( 1 ) - ca ( 1 ) * cp ( 3 ) caxcp ( 3 ) = ca ( 1 ) * cp ( 2 ) - ca ( 2 ) * cp ( 1 ) dis_12 = abxap ( 1 ) * bcxbp ( 1 ) + abxap ( 2 ) * bcxbp ( 2 ) + abxap ( 3 ) * bcxbp ( 3 ) dis_13 = abxap ( 1 ) * caxcp ( 1 ) + abxap ( 2 ) * caxcp ( 2 ) + abxap ( 3 ) * caxcp ( 3 ) IF (( dis_12 >= 0.0_RP ) . AND . ( dis_13 >= 0.0_RP )) THEN intersect = 1 RETURN END IF ELSE intersect = 0 END IF END DO END SUBROUTINE divertor_loss END MODULE divertor_mod","tags":"","loc":"sourcefile/divertor_mod.f90.html"},{"title":"driver.f90 – OFIT3D","text":"Contents Subroutines driver Source Code driver.f90 Source Code !=driver.f90 ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! SUBROUTINE driver USE kind_spec USE param2 , ONLY : ldivertor , & & run_mode USE vessel_mod , ONLY : read_vessel , & & free_mem_vessel USE divertor_mod , ONLY : read_divertor , & & free_mem_divertor USE info_mod , ONLY : drive_time USE mpi_param_mod , ONLY : myrank USE mpi IMPLICIT NONE ! REAL ( RP ) :: t1 , & & t2 !for MPI INTEGER :: ierr t1 = MPI_WTIME () IF ( myrank == 0 ) THEN PRINT * PRINT * , ' ----------------------------------------------------------------' PRINT * , '          SUBROUTINE DRIVER                                      ' PRINT * , ' ----------------------------------------------------------------' PRINT * END IF CALL read_vessel IF ( ldivertor ) CALL read_divertor SELECT CASE ( run_mode ) CASE ( 'single' , 'SINGLE' ) CALL single_particles CASE ( 'multi' , 'MULTI' ) CALL multi_particles END SELECT CALL free_mem_vessel IF ( ldivertor ) CALL free_mem_divertor t2 = MPI_WTIME () drive_time = t2 - t1 CALL MPI_BARRIER ( MPI_COMM_WORLD , ierr ) END SUBROUTINE driver","tags":"","loc":"sourcefile/driver.f90.html"},{"title":"gcr.f90 – OFIT3D","text":"Contents Subroutines gcr Source Code gcr.f90 Source Code !=gcr.f90 ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! SUBROUTINE gcr ( rstart , pstart , zstart , w_in , stalam , dt_in , nstep , & !(in) & loss , loss_time , trap & !(out) & ) USE kind_spec USE param1 , ONLY : pi , & & pi2 , & & qom_a , & & ma , & & mb USE param2 , ONLY : ladaptive , & & lcoll , & & lano , & & lmonitor , & & lpunc , & & lvessel , & & ldivertor , & & interval , & & collision_type , & & anomalous_type , & & slimit USE inv_val_mod , ONLY : mu USE cylindrical_coord_mod , ONLY : sedge , & & pi2m , & & mgval1 , & & mgval3 , mgval2 USE collision_parameter_mod , ONLY : nu_dxtau , & & nu_extau , & & collision_step , & & rho_col , & & v_th_a , & & v_th_b , & & nu_ab USE vessel_mod , ONLY : check_vessel , & & vessel_loss USE divertor_mod , ONLY : divertor_loss USE mt95 IMPLICIT NONE !Arguments INTEGER , INTENT ( IN ) :: nstep INTEGER , INTENT ( OUT ) :: loss , & & trap REAL ( RP ), INTENT ( IN ) :: rstart , & & pstart , & & zstart , & & w_in , & & stalam , & & dt_in REAL ( RP ), INTENT ( OUT ) :: loss_time !Local variables INTEGER :: i , & & k REAL ( RP ) :: dt , & & v , & & vpara , & & vperp , & & vpara1 , & & vperp1 , & & br , & & bz , & & bp , & & bb , & & s , & & wtotl , & & werror , & & wpara , & & wperp , bvec ( 4 ), dbdr ( 4 ), dbdp ( 4 ), dbdz ( 4 ) !Collision parameters INTEGER :: it_array ( 3 ), & & iseed REAL ( RP ) :: random1 , & & random2 , & & pitch , & & phase , & & p , & & gamma_ab , & & u , & & erfu , & & erfpu , & & dvv2_ave , & & dvv_ave , & & dvce2_ave , & & muc , & & sigma , & & dvv , & & dvc , & & dve !For Runge-Kutta INTEGER :: iout REAL ( RP ) :: t , y ( 4 ) !External function EXTERNAL :: fun_gcr !For loss detection INTEGER :: ivessel , & & idivertor REAL ( RP ) :: dt_loss , & & y0 ( 3 ), & & loss_points ( 3 ) IF ( lcoll ) THEN CALL itime ( it_array (:)) iseed = it_array ( 2 ) * it_array ( 3 ) + it_array ( 1 ) CALL genrand_init ( iseed ) END IF CALL mgval1 ( rstart , pstart , zstart , br , bp , bz , bb ) CALL mgval3 ( rstart , pstart , zstart , s ) IF ( bb == 0.0_RP ) THEN PRINT * , ' Initial value is invalid. ' RETURN END IF dt = dt_in v = SQRT ( 2 * w_in * qom_a ) vpara = v * COS ( stalam * pi ) vperp = v * SIN ( stalam * pi ) mu = vperp ** 2 / ( bb + bb ) y ( 1 ) = rstart y ( 2 ) = pstart y ( 3 ) = zstart y ( 4 ) = vpara t = 0.0_RP loss = 0 trap = 0 IF ( lmonitor ) THEN wpara = 0.5_RP * vpara * ABS ( vpara ) / qom_a wperp = mu * bb / qom_a #ifdef BIN WRITE ( 50 ) t , y ( 1 ) * COS ( y ( 2 )), y ( 1 ) * SIN ( y ( 2 )), y ( 3 ), y ( 1 ), y ( 2 ), bb , s , wpara , wperp , w_in , 0.0_RP #else WRITE ( 50 , '(20(ES22.12, A1))' ) t , ',' , y ( 1 ) * COS ( y ( 2 )), ',' , y ( 1 ) * SIN ( y ( 2 )), ',' , y ( 3 ), ',' , y ( 1 ), ',' , y ( 2 ), ',' , bb , ',' , s , ',' , wpara , ',' , wperp , ',' , w_in , ',' , 0.0_RP , ',' #endif END IF !IF(interval == 0) interval =  10 !IF(nstep > 1000)  interval =  nstep / 1000 DO i = 1 , nstep y0 ( 1 ) = y ( 1 ) y0 ( 2 ) = y ( 2 ) y0 ( 3 ) = y ( 3 ) !  -------------------------------------------- CALL rkg6 ( t , dt , 4 , fun_gcr , y (:), iout ) !  -------------------------------------------- CALL mgval3 ( y ( 1 ), y ( 2 ), y ( 3 ), s ) IF ( s >= sedge ) THEN IF ( ldivertor ) THEN CALL divertor_loss ( y0 ( 1 ), y0 ( 2 ), y0 ( 3 ), y ( 1 ), y ( 2 ), y ( 3 ), idivertor , dt_loss , loss_points ) IF ( idivertor == 1 ) THEN #ifdef BIN WRITE ( 52 ) loss_points ( 1 ), loss_points ( 2 ), loss_points ( 3 ), SIGN ( 1.0_RP , y ( 4 )) #else WRITE ( 52 , '(4ES22.12)' ) loss_points ( 1 ), loss_points ( 2 ), loss_points ( 3 ), SIGN ( 1.0_RP , y ( 4 )) #endif IF ( lmonitor ) THEN CALL mgval1 ( y ( 1 ), y ( 2 ), y ( 3 ), br , bp , bz , bb ) wpara = 0.5_RP * y ( 4 ) * ABS ( y ( 4 )) / qom_a wperp = mu * bb / qom_a wtotl = ABS ( wpara ) + wperp werror = ( wtotl - w_in ) / w_in #ifdef BIN WRITE ( 50 ) t + dt_loss , y ( 1 ) * COS ( y ( 2 )), y ( 1 ) * SIN ( y ( 2 )), y ( 3 ), y ( 1 ), y ( 2 ), bb , s , wpara , wperp , wtotl , werror #else WRITE ( 50 , '(20(ES22.12, A1))' ) t + dt_loss , ',' , y ( 1 ) * COS ( y ( 2 )), ',' , y ( 1 ) * SIN ( y ( 2 )), ',' , y ( 3 ), ',' , y ( 1 ), ',' , y ( 2 ), ',' , bb , ',' , s , ',' , wpara , ',' , wperp , ',' , wtotl , ',' , werror , ',' #endif END IF loss = 1 loss_time = t + dt_loss RETURN END IF END IF CALL check_vessel ( y ( 1 ), y ( 2 ), y ( 3 ), ivessel ) IF ( ivessel == 1 ) THEN CALL vessel_loss ( y0 ( 1 ), y0 ( 2 ), y0 ( 3 ), y ( 1 ), y ( 2 ), y ( 3 ), ivessel , dt_loss , loss_points ) #ifdef BIN WRITE ( 51 ) loss_points ( 1 ), loss_points ( 2 ), loss_points ( 3 ), SIGN ( 1.0_RP , y ( 4 )) #else WRITE ( 51 , '(4ES22.12)' ) loss_points ( 1 ), loss_points ( 2 ), loss_points ( 3 ), SIGN ( 1.0_RP , y ( 4 )) #endif IF ( lmonitor ) THEN CALL mgval1 ( y ( 1 ), y ( 2 ), y ( 3 ), br , bp , bz , bb ) wpara = 0.5_RP * y ( 4 ) * ABS ( y ( 4 )) / qom_a wperp = mu * bb / qom_a wtotl = ABS ( wpara ) + wperp werror = ( wtotl - w_in ) / w_in #ifdef BIN WRITE ( 50 ) t + dt , y ( 1 ) * COS ( y ( 2 )), y ( 1 ) * SIN ( y ( 2 )), y ( 3 ), y ( 1 ), y ( 2 ), bb , s , wpara , wperp , wtotl , werror #else WRITE ( 50 , '(20(ES22.12, A1))' ) t + dt , ',' , y ( 1 ) * COS ( y ( 2 )), ',' , y ( 1 ) * SIN ( y ( 2 )), ',' , y ( 3 ), ',' , y ( 1 ), ',' , y ( 2 ), ',' , bb , ',' , s , ',' , wpara , ',' , wperp , ',' , wtotl , ',' , werror , ',' #endif END IF loss = 1 loss_time = t + dt RETURN END IF ELSE IF ( lcoll ) THEN SELECT CASE ( collision_type ) CASE ( 'pitch' ) CALL mgval1 ( y ( 1 ), y ( 2 ), y ( 3 ), br , bp , bz , bb ) wtotl = ( 0.5_RP * y ( 4 ) ** 2 + mu * bb ) / qom_a v = SQRT ( 2 * wtotl * qom_a ) !pitch =  y(4) * bb / v pitch = y ( 4 ) / v CALL genrand_real1 ( random1 ) random1 = random1 - 0.5_RP p = ( 1.0_RP - pitch ** 2 ) * nu_dxtau pitch = pitch * ( 1.0_RP - nu_dxtau ) + SIGN ( 1.0_RP , random1 ) * SQRT ( p ) pitch = MAX ( pitch , - 1.0_RP ) ! fail safe pitch = MIN ( pitch , 1.0_RP ) ! fail safe !CALL genrand_real1(random1) !wtotl   =  wtotl * (1 - random1 * dt) !v       =  SQRT(2.0_RP * wtotl * qom_a) y ( 4 ) = v * pitch vperp = v * SQRT ( 1.0_RP - pitch ** 2 ) mu = vperp ** 2 / ( bb + bb ) CASE ( 'slow' ) vpara = y ( 4 ) vperp = SQRT ( 2 * mu * bb ) CALL mgval1 ( y ( 1 ), y ( 2 ), y ( 3 ), br , bp , bz , bb ) wtotl = ( 0.5_RP * y ( 4 ) ** 2 + mu * bb ) / qom_a v = SQRT ( 2 * wtotl * qom_a ) gamma_ab = nu_ab * v_th_a ** 3 u = v / ( SQRT ( 2.0_RP ) * v_th_b ) erfu = ERF ( u ) erfpu = ( 2 / SQRT ( pi )) * EXP ( - u ** 2 ) dvv2_ave = gamma_ab / ( 2 * v ) * ( erfu / u ** 2 - erfpu / u ) * dt * 2 dvv_ave = - ( 1 + ma / mb ) * gamma_ab / v ** 2 * ( erfu - u * erfpu ) * dt dvce2_ave = gamma_ab / ( 4 * v ) * (( 2 - 1 / u ** 2 ) * erfu + erfpu / u ) * dt * 2 muc = dvv_ave sigma = SQRT ( dvv2_ave - dvv_ave ** 2 ) CALL genrand_real3 ( random1 ) CALL genrand_real1 ( random2 ) dvv = muc + sigma * SQRT ( - 2.0_RP * LOG ( random1 )) * SIN ( pi2 * random2 ) sigma = SQRT ( dvce2_ave ) CALL genrand_real3 ( random1 ) CALL genrand_real1 ( random2 ) dvc = sigma * SQRT ( - 2.0_RP * LOG ( random1 )) * SIN ( pi2 * random2 ) sigma = SQRT ( dvce2_ave ) CALL genrand_real3 ( random1 ) CALL genrand_real1 ( random2 ) dve = sigma * SQRT ( - 2.0_RP * LOG ( random1 )) * SIN ( pi2 * random2 ) vpara1 = vpara + dvv * vpara / v - dvc * vperp / v vperp1 = SQRT (( vperp + dvv * vperp / v + dvc * vpara / v ) ** 2 + dve ** 2 ) vpara = vpara1 vperp = vperp1 mu = vperp ** 2 / ( bb + bb ) y ( 4 ) = vpara END SELECT END IF END IF IF ( lano ) THEN !SELECT CASE('anomalous_type') !  CASE('classical') IF ( MOD ( i , collision_step ( 2 )) == 0 ) THEN CALL mgval1 ( y ( 1 ), y ( 2 ), y ( 3 ), br , bp , bz , bb ) wtotl = ( 0.5_RP * y ( 4 ) ** 2 + mu * bb ) / qom_a v = SQRT ( 2 * wtotl * qom_a ) pitch = y ( 4 ) / v vperp = v * SQRT ( 1.0_RP - pitch ** 2 ) CALL genrand_real1 ( random2 ) phase = pi2 * random2 y ( 1 ) = y ( 1 ) + rho_col * COS ( phase ) y ( 2 ) = y ( 2 ) + rho_col * SIN ( phase ) CALL mgval1 ( y ( 1 ), y ( 2 ), y ( 3 ), br , bp , bz , bb ) mu = vperp ** 2 / ( bb + bb ) END IF !END SELECT END IF IF ( lmonitor ) THEN IF ( MOD ( i , interval ) == 0 ) THEN CALL mgval1 ( y ( 1 ), y ( 2 ), y ( 3 ), br , bp , bz , bb ) CALL mgval2 ( y ( 1 ), y ( 2 ), y ( 3 ), bvec , dbdr , dbdp , dbdz ) wpara = 0.5_RP * y ( 4 ) * ABS ( y ( 4 )) / qom_a wperp = mu * bb / qom_a wtotl = ABS ( wpara ) + wperp werror = ( wtotl - w_in ) / w_in #ifdef BIN WRITE ( 50 ) t , y ( 1 ) * COS ( y ( 2 )), y ( 1 ) * SIN ( y ( 2 )), y ( 3 ), y ( 1 ), y ( 2 ), bb , s , wpara , wperp , wtotl , werror #else WRITE ( 50 , '(20(ES22.12, A1))' ) t , ',' , y ( 1 ) * COS ( y ( 2 )), ',' , y ( 1 ) * SIN ( y ( 2 )), ',' , y ( 3 ), ',' , y ( 1 ), ',' , y ( 2 ), ',' , bb , ',' , s , ',' , wpara , ',' , wperp , ',' , wtotl , ',' , werror , ',' #endif END IF END IF IF (( i /= 1 ) . and . ( y ( 4 ) * vpara < 0.0_RP )) THEN trap = 1 END IF t = t + dt IF ( ladaptive ) THEN wtotl = ( 0.5_RP * y ( 4 ) ** 2 + mu * bb ) / qom_a v = SQRT ( 2 * wtotl * qom_a ) !dt    =  0.002_RP / v dt = 0.0095720401164064_RP / v END IF END DO loss_time = t RETURN END SUBROUTINE gcr","tags":"","loc":"sourcefile/gcr.f90.html"},{"title":"fun_gcr.f90 – OFIT3D","text":"Contents Subroutines fun_gcr Source Code fun_gcr.f90 Source Code !=fun_gcr.f90 ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! SUBROUTINE fun_gcr ( t , y , & ! (in) & yp , iout & ! (out) & ) USE kind_spec USE param1 , ONLY : qa , & & ma USE inv_val_mod , ONLY : mu USE cylindrical_coord_mod , ONLY : mgval2 IMPLICIT NONE !Arguments INTEGER , INTENT ( OUT ) :: iout REAL ( RP ), INTENT ( IN ) :: t , & & y ( 4 ) REAL ( RP ), INTENT ( OUT ) :: yp ( 4 ) !Local variables REAL ( RP ) :: vvv , & & bmod , & & dbdr , & & dbdp , & & dbdz , & & rotbr , & & rotbp , & & rotbz , & & bgradb , & & rbgrdb , & & efac , & & delta , & & vpara , & & vpara2 , & & ombinv , & & eps , & & aa1 , & & aa2 , & & aa3 , & & bvec ( 4 ), & & dbvdr ( 4 ), & & dbvdp ( 4 ), & & dbvdz ( 4 ), & & s , & & grads ( 3 ) iout = 0 CALL mgval2 ( y ( 1 ), y ( 2 ), y ( 3 ), bvec (:), dbvdr (:), dbvdp (:), dbvdz (:)) bmod = bvec ( 4 ) IF ( bmod == 0.0_RP ) THEN yp (:) = 0.0_RP iout = 1 RETURN END IF dbdr = dbvdr ( 4 ) dbdp = dbvdp ( 4 ) / y ( 1 ) dbdz = dbvdz ( 4 ) rotbr = dbvdp ( 3 ) / y ( 1 ) - dbvdz ( 2 ) rotbp = dbvdz ( 1 ) - dbvdr ( 3 ) rotbz = dbvdr ( 2 ) - dbvdp ( 1 ) / y ( 1 ) + bvec ( 2 ) / y ( 1 ) delta = bvec ( 1 ) * rotbr + bvec ( 2 ) * rotbp + bvec ( 3 ) * rotbz vpara = y ( 4 ) vpara2 = y ( 4 ) * y ( 4 ) ombinv = ma / ( qa * bmod ** 2 ) aa1 = vpara / bmod aa2 = ombinv * ( mu + vpara2 / bmod ) aa3 = ombinv * vpara2 bgradb = bvec ( 1 ) * dbdr + bvec ( 2 ) * dbdp + bvec ( 3 ) * dbdz rbgrdb = rotbr * dbdr + rotbp * dbdp + rotbz * dbdz ! corrected by J. Morimoto yp ( 1 ) = aa1 * bvec ( 1 ) + aa2 * ( bvec ( 2 ) * dbdz - bvec ( 3 ) * dbdp ) + aa3 * rotbr yp ( 2 ) = ( aa1 * bvec ( 2 ) + aa2 * ( bvec ( 3 ) * dbdr - bvec ( 1 ) * dbdz ) + aa3 * rotbp ) / y ( 1 ) yp ( 3 ) = aa1 * bvec ( 3 ) + aa2 * ( bvec ( 1 ) * dbdp - bvec ( 2 ) * dbdr ) + aa3 * rotbz yp ( 4 ) = - mu * ( bgradb / bmod + rbgrdb * ombinv * y ( 4 )) eps = ( ombinv / bmod ) * vpara * delta efac = 1.0_RP / ( 1.0_RP + eps ) yp ( 1 ) = efac * yp ( 1 ) yp ( 2 ) = efac * yp ( 2 ) yp ( 3 ) = efac * yp ( 3 ) yp ( 4 ) = efac * yp ( 4 ) RETURN END SUBROUTINE fun_gcr","tags":"","loc":"sourcefile/fun_gcr.f90.html"},{"title":"multi.f90 – OFIT3D","text":"Contents Subroutines multi_particles Source Code multi.f90 Source Code !=driver.f90 ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! SUBROUTINE multi_particles USE kind_spec USE param1 , ONLY : pi , & & qom_a USE param2 , ONLY : ladaptive , & & lcoll , & & lano , & & lmonitor , & & lpunc , & & lvessel , & & ldivertor , & & lfile , & & nparticles , & & interval , & & dt , & & quit_t , & & mode , & & multi_mode USE cylindrical_coord_mod , ONLY : pi2m USE mpi_param_mod , ONLY : nprocs , & & myrank , & & nsta , & & nend , & & para_range USE mpi IMPLICIT NONE INTEGER :: nstep , & & loss , & & trap , & & loss_n_p , & & loss_n_t , & & loss_t_p , & & loss_t_t , & & loss_tol , & & ii , & & n REAL ( RP ) :: loss_time , & & v , & & x , & & y , & & temp REAL ( RP ), ALLOCATABLE :: rstart (:), & & zstart (:), & & pstart (:), & & wk_in (:), & & stalam (:) CHARACTER ( LEN = 100 ) :: fmt CHARACTER ( LEN = 200 ) :: label !for MPI INTEGER :: ierr IF ( myrank == 0 ) THEN PRINT * PRINT * , '  RUN CONTROL PARAMETERS ' PRINT * PRINT * , '  ladaptive   lcoll     lano' PRINT * , '-------------------------------' fmt = '(3X, L5, 5X, L5, 5X, L5)' PRINT fmt , ladaptive , lcoll , lano PRINT * , '   lvessel  ldivertor' PRINT * , '------------------------' PRINT fmt , lvessel , ldivertor PRINT * , '   lmonitor   lpunc     lfile' PRINT * , '--------------------------------' PRINT fmt , lmonitor , lpunc , lfile PRINT * PRINT * PRINT * , '  RUN_MODE: MULTI_PARTICLES' PRINT * PRINT * , '   mode' PRINT * , '-----------' fmt = '(A10)' PRINT fmt , TRIM ( mode ) END IF CALL MPI_BARRIER ( MPI_COMM_WORLD , ierr ) SELECT CASE ( multi_mode ) CASE DEFAULT nparticles = 231 ALLOCATE ( rstart ( nparticles ), zstart ( nparticles ), pstart ( nparticles ), wk_in ( nparticles ), stalam ( nparticles )) DO n = 1 , nparticles READ ( 60 , * ) ii , rstart ( n ), zstart ( n ), pstart ( n ), wk_in ( n ), stalam ( n ), temp END DO CALL para_range ( 1 , nparticles , nprocs , myrank , nsta , nend ) CALL MPI_BARRIER ( MPI_COMM_WORLD , ierr ) IF ( myrank == 0 ) THEN PRINT * PRINT * , '   PARTICLE DISTRIBUTION ON EACH NODES' PRINT * , '----------------------------------------------------------------------------' END IF fmt = '(A, I10, A, I10, A, I10, I10, A, I10)' PRINT fmt , '   #rank =' , myrank , ' nsta =' , nsta , ' nend =' , nend , nend - nsta + 1 , '/' , nparticles CALL MPI_BARRIER ( MPI_COMM_WORLD , ierr ) loss_n_p = 0 loss_n_t = 0 loss_t_p = 0 loss_t_t = 0 DO n = nsta , nend pstart ( n ) = pi2m * pstart ( n ) v = SQRT ( 2 * wk_in ( n ) * qom_a ) !dt        =  0.002_RP / v dt = 0.0095720401164064_RP / v nstep = quit_t / dt interval = nstep / 100000 WRITE ( label , fmt = '(A,I0,A)' ) 'multi.' , n , '.dat' OPEN ( 11 , FILE = label , FORM = 'formatted' , STATUS = 'unknown' ) IF ( lmonitor ) THEN WRITE ( label , fmt = '(A,I0,A)' ) 'multi.' , n , '.gcr' #ifdef BIN OPEN ( 50 , FILE = label , FORM = 'unformatted' , STATUS = 'unknown' ) #else OPEN ( 50 , FILE = label , FORM = 'formatted' , STATUS = 'unknown' ) #endif END IF WRITE ( label , fmt = '(A,I0,A)' ) 'multi.' , n , '.loss' OPEN ( 88 , FILE = label , FORM = 'formatted' , STATUS = 'unknown' ) fmt = '(A18, I12, A1, I12, A7, I12)' WRITE ( 11 , fmt ) ' Particle Number =' , n , '/' , nparticles , ' Rank# ' , myrank WRITE ( 11 , * ) WRITE ( 11 , * ) '    R[m]      phi[deg]      Z[m]       lamda      E_K[keV]' WRITE ( 11 , * ) '-------------------------------------------------------------' fmt = '(5ES12.4)' WRITE ( 11 , fmt ) rstart ( n ), pstart ( n ) * 18 0.0_RP / pi , zstart ( n ), COS ( stalam ( n ) * pi ), 1.0E-03_RP * wk_in ( n ) WRITE ( 11 , * ) WRITE ( 11 , * ) '    dt[s]     t_end[s]       nstep       interval' WRITE ( 11 , * ) '---------------------------------------------------' fmt = '(2ES12.4, 2I12)' WRITE ( 11 , fmt ) dt , quit_t , nstep , interval #ifdef GC !---------------------------------------------------------------------------------------------------------- CALL gcr ( rstart ( n ), pstart ( n ), zstart ( n ), wk_in ( n ), stalam ( n ), dt , nstep , loss , loss_time , trap ) !---------------------------------------------------------------------------------------------------------- #elif FULL !---------------------------------------------------------------------------------------------------------- CALL mesor ( rstart ( n ), pstart ( n ), zstart ( n ), wk_in ( n ), stalam ( n ), dt , nstep , loss , loss_time , trap ) !---------------------------------------------------------------------------------------------------------- #endif WRITE ( 11 , * ) WRITE ( 11 , * ) '  t_loss[s]' WRITE ( 11 , * ) '-----------------------------------' x = rstart ( n ) y = COS ( stalam ( n ) * pi ) fmt = '(ES12.4, A22)' IF (( loss == 0 ) . AND . ( trap == 0 )) THEN WRITE ( 11 , fmt ) loss_time , \"    'untrapped unloss'\" WRITE ( 88 , '(13(ES12.4, A), I3, A)' ) rstart ( n ), ',' , pstart ( n ), ',' , zstart ( n ), ',' , stalam ( n ), ',' , x , ',' , y , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , loss_time , ',' , 1 , ',' ELSE IF (( loss == 0 ) . AND . ( trap == 1 )) THEN WRITE ( 11 , fmt ) loss_time , \"    'trapped unloss'\" WRITE ( 88 , '(13(ES12.4, A), I3, A)' ) rstart ( n ), ',' , pstart ( n ), ',' , zstart ( n ), ',' , stalam ( n ), ',' , 0.0 , ',' , 0.0 , ',' , x , ',' , y , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , loss_time , ',' , 2 , ',' ELSE IF (( loss == 1 ) . and . ( trap == 0 )) THEN loss_n_p = loss_n_p + 1 WRITE ( 11 , fmt ) loss_time , \"    'untrapped loss'\" WRITE ( 88 , '(13(ES12.4, A), I3, A)' ) rstart ( n ), ',' , pstart ( n ), ',' , zstart ( n ), ',' , stalam ( n ), ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , x , ',' , y , ',' , 0.0 , ',' , 0.0 , ',' , loss_time , ',' , 3 , ',' ELSE IF (( loss == 1 ) . and . ( trap == 1 )) THEN loss_n_t = loss_n_t + 1 WRITE ( 11 , fmt ) loss_time , \"    'trapped loss'\" WRITE ( 88 , '(13(ES12.4, A), I3, A)' ) rstart ( n ), ',' , pstart ( n ), ',' , zstart ( n ), ',' , stalam ( n ), ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , 0.0 , ',' , x , ',' , y , ',' , loss_time , ',' , 4 , ',' END IF CLOSE ( 88 ) CLOSE ( 50 ) CLOSE ( 11 ) END DO CALL MPI_REDUCE ( loss_n_p , loss_t_p , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) CALL MPI_REDUCE ( loss_n_t , loss_t_t , 1 , MPI_INTEGER , MPI_SUM , 0 , MPI_COMM_WORLD , ierr ) loss_tol = loss_t_p + loss_t_t fmt = '(A40, I12, A, I12)' IF ( myrank == 0 ) THEN PRINT * PRINT fmt , ' Number of Prompt Loss Particle  = ' , loss_t_p , '/' , nparticles PRINT fmt , ' Number of Trapped Loss Particle = ' , loss_t_t , '/' , nparticles PRINT fmt , ' Total Number of Lost Particle   = ' , loss_tol , '/' , nparticles PRINT * END IF DEALLOCATE ( rstart , zstart , pstart , wk_in , stalam ) END SELECT END SUBROUTINE multi_particles","tags":"","loc":"sourcefile/multi.f90.html"},{"title":"precal.f90 – OFIT3D","text":"Contents Subroutines precal Source Code precal.f90 Source Code !=precal.f90 ! !==Version ! ! $Revision$ ! $Id$ ! !==Overview ! !==Reference ! !==Error Handlings ! !==Known Bugs ! !==Note ! !==TODO ! SUBROUTINE precal USE kind_spec USE param1 , ONLY : ee , & & mi , & & mn , & & me , & & epsi0 , & & pi4 , & & qa , & & qb , & & ma , & & mb , & & qom_a , & & qom_b USE param2 , ONLY : lcoll , & & wk_in , & & dt , & & mode USE cylindrical_coord_mod , ONLY : magset USE collision_parameter_mod , ONLY : collision_step , & & n_e , & & t_bg , & & d_ano , & & rho_col , & & ln_lamda , & & v_th_a , & & v_th_b , & & nu_ab , & & tau , & & nu_d , & & nu_dxtau , & & nu_e , & & nu_extau USE info_mod , ONLY : pre_time USE mpi_param_mod , ONLY : myrank USE mpi IMPLICIT NONE REAL ( RP ) :: & & v , & & xa , & & xb , & & upsilon , & & xsi , & & dupsilon REAL ( RP ), EXTERNAL :: upsilon_cal , & & xsi_cal CHARACTER ( LEN = 100 ) :: fmt ! REAL ( RP ) :: t1 , & & t2 !for MPI INTEGER :: ierr t1 = MPI_WTIME () IF ( myrank == 0 ) THEN PRINT * PRINT * , ' ----------------------------------------------------------------' PRINT * , '          SUBROUTINE PRECALC                                     ' PRINT * , ' ----------------------------------------------------------------' PRINT * END IF ! ! set test particle ! SELECT CASE ( mode ) CASE ( 'proton' ) ma = mi mb = me qa = ee qb = - ee qom_a = ABS ( qa ) / ma qom_b = ABS ( qb ) / mb CASE ( 'deuteron' ) ma = mi + mn mb = me qa = ee qb = - ee qom_a = ABS ( qa ) / ma qom_b = ABS ( qb ) / mb CASE ( 'triton' ) ma = mi + mn + mn mb = me qa = ee qb = - ee qom_a = ABS ( qa ) / ma qom_b = ABS ( qb ) / mb CASE ( 'electron' ) ma = me mb = me qa = - ee qb = - ee qom_a = ABS ( qa ) / ma qom_b = ABS ( qb ) / mb CASE ( 'alpha' ) ma = mi + mi + mn + mn mb = me qa = ee + ee qb = - ee qom_a = ABS ( qa ) / ma qom_b = ABS ( qb ) / mb CASE ( 'c6+' , 'C6+' ) ma = 6 * mi + 6 * mn mb = me qa = 6 * ee qb = - ee qom_a = ABS ( qa ) / ma qom_b = ABS ( qb ) / mb CASE DEFAULT ma = mi mb = me qa = ee qb = - ee qom_a = ABS ( qa ) / ma qom_b = ABS ( qb ) / mb END SELECT ! ! read magnetic field ! CALL magset ! ! if collisionless case, return ! IF ( lcoll ) THEN ln_lamda = 1 5.2_RP - 0.5_RP * LOG ( n_e / 1.0e+20_RP ) + LOG ( t_bg / 1.0e+03_RP ) v_th_a = SQRT ( 2 * t_bg * qom_a ) v_th_b = SQRT ( 2 * t_bg * qom_b ) v = SQRT ( 2 * wk_in * qom_a ) IF ( myrank == 0 ) THEN fmt = '(A)' PRINT * PRINT fmt , ' PARAMETERS OF BACKGROUD PLASMA' PRINT fmt , '------------------------------------------------' PRINT fmt , '    Te[eV]         n_e[m&#94;-3]     ln_lamda' fmt = '(3ES15.7)' PRINT fmt , t_bg , n_e , ln_lamda END IF nu_ab = n_e * qa ** 2 * qb ** 2 * ln_lamda / ( pi4 * epsi0 ** 2 * ma ** 2 * v_th_a ** 3 ) xa = v / v_th_a xb = v / v_th_b upsilon = upsilon_cal ( xb ) xsi = xsi_cal ( xb ) nu_d = nu_ab * ( upsilon - xsi ) / xa ** 3 nu_e = 2 * nu_ab * xsi / xa ** 3 IF ( myrank == 0 ) THEN fmt = '(A)' PRINT * PRINT fmt , ' COLLISION FREQUENCY' PRINT fmt , '--------------------------------------------------------------------------------------------' PRINT fmt , '    v[m/s]        v_th_a[m/s]    v_th_b[m/s]     nu_ab[1/s]     nu_d[1/s]      nu_e[1/s]' fmt = '(6ES15.7)' PRINT fmt , v , v_th_a , v_th_b , nu_ab , nu_d , nu_e END IF tau = dt nu_dxtau = nu_d * tau nu_extau = nu_e * tau IF ( myrank == 0 ) THEN fmt = '(A)' PRINT * PRINT fmt , ' MONTECARLO PARAMETERS' PRINT fmt , '------------------------------------------------' PRINT fmt , '    tau[s]       nu_d x tau     nu_e x tau' fmt = '(3ES15.7)' PRINT fmt , tau , nu_dxtau , nu_extau END IF collision_step ( 2 ) = 1.0_RP / nu_d !rho_col           =  1.2e-03_RP d_ano = rho_col ** 2 / ( dt * collision_step ( 2 )) IF ( myrank == 0 ) THEN fmt = '(A)' PRINT * PRINT fmt , ' ANOUMALOUS TRANSPORT' PRINT fmt , '------------------------------------------------' PRINT * , '  rho_ano[m]     tau_ano[s]     D_ano[m&#94;2/s]' fmt = '(3ES15.7)' PRINT fmt , rho_col , dt * collision_step ( 2 ), d_ano END IF END IF IF ( myrank == 0 ) THEN PRINT * PRINT * END IF t2 = MPI_WTIME () pre_time = t2 - t1 CALL MPI_BARRIER ( MPI_COMM_WORLD , ierr ) END SUBROUTINE precal","tags":"","loc":"sourcefile/precal.f90.html"}]}